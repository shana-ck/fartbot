"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target2, all) => {
  for (var name3 in all)
    __defProp(target2, name3, { get: all[name3], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target2) => (target2 = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target2, "default", { value: mod2, enumerable: true }) : target2, mod2));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// ../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/boundaries.js
var require_boundaries = __commonJS({
  "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/boundaries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EXTENDED_PICTOGRAPHIC = exports.CLUSTER_BREAK = void 0;
    var CLUSTER_BREAK;
    (function(CLUSTER_BREAK2) {
      CLUSTER_BREAK2[CLUSTER_BREAK2["CR"] = 0] = "CR";
      CLUSTER_BREAK2[CLUSTER_BREAK2["LF"] = 1] = "LF";
      CLUSTER_BREAK2[CLUSTER_BREAK2["CONTROL"] = 2] = "CONTROL";
      CLUSTER_BREAK2[CLUSTER_BREAK2["EXTEND"] = 3] = "EXTEND";
      CLUSTER_BREAK2[CLUSTER_BREAK2["REGIONAL_INDICATOR"] = 4] = "REGIONAL_INDICATOR";
      CLUSTER_BREAK2[CLUSTER_BREAK2["SPACINGMARK"] = 5] = "SPACINGMARK";
      CLUSTER_BREAK2[CLUSTER_BREAK2["L"] = 6] = "L";
      CLUSTER_BREAK2[CLUSTER_BREAK2["V"] = 7] = "V";
      CLUSTER_BREAK2[CLUSTER_BREAK2["T"] = 8] = "T";
      CLUSTER_BREAK2[CLUSTER_BREAK2["LV"] = 9] = "LV";
      CLUSTER_BREAK2[CLUSTER_BREAK2["LVT"] = 10] = "LVT";
      CLUSTER_BREAK2[CLUSTER_BREAK2["OTHER"] = 11] = "OTHER";
      CLUSTER_BREAK2[CLUSTER_BREAK2["PREPEND"] = 12] = "PREPEND";
      CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE"] = 13] = "E_BASE";
      CLUSTER_BREAK2[CLUSTER_BREAK2["E_MODIFIER"] = 14] = "E_MODIFIER";
      CLUSTER_BREAK2[CLUSTER_BREAK2["ZWJ"] = 15] = "ZWJ";
      CLUSTER_BREAK2[CLUSTER_BREAK2["GLUE_AFTER_ZWJ"] = 16] = "GLUE_AFTER_ZWJ";
      CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE_GAZ"] = 17] = "E_BASE_GAZ";
    })(CLUSTER_BREAK = exports.CLUSTER_BREAK || (exports.CLUSTER_BREAK = {}));
    exports.EXTENDED_PICTOGRAPHIC = 101;
  }
});

// ../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/GraphemerHelper.js
var require_GraphemerHelper = __commonJS({
  "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/GraphemerHelper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var boundaries_1 = require_boundaries();
    var NotBreak = 0;
    var BreakStart = 1;
    var Break = 2;
    var BreakLastRegional = 3;
    var BreakPenultimateRegional = 4;
    var GraphemerHelper = class {
      static isSurrogate(str, pos) {
        return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
      }
      static codePointAt(str, idx) {
        if (idx === void 0) {
          idx = 0;
        }
        const code4 = str.charCodeAt(idx);
        if (55296 <= code4 && code4 <= 56319 && idx < str.length - 1) {
          const hi = code4;
          const low = str.charCodeAt(idx + 1);
          if (56320 <= low && low <= 57343) {
            return (hi - 55296) * 1024 + (low - 56320) + 65536;
          }
          return hi;
        }
        if (56320 <= code4 && code4 <= 57343 && idx >= 1) {
          const hi = str.charCodeAt(idx - 1);
          const low = code4;
          if (55296 <= hi && hi <= 56319) {
            return (hi - 55296) * 1024 + (low - 56320) + 65536;
          }
          return low;
        }
        return code4;
      }
      static shouldBreak(start, mid, end, startEmoji, midEmoji, endEmoji) {
        const all = [start].concat(mid).concat([end]);
        const allEmoji = [startEmoji].concat(midEmoji).concat([endEmoji]);
        const previous = all[all.length - 2];
        const next = end;
        const nextEmoji = endEmoji;
        const rIIndex = all.lastIndexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR);
        if (rIIndex > 0 && all.slice(1, rIIndex).every(function(c) {
          return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
        }) && [boundaries_1.CLUSTER_BREAK.PREPEND, boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(previous) === -1) {
          if (all.filter(function(c) {
            return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
          }).length % 2 === 1) {
            return BreakLastRegional;
          } else {
            return BreakPenultimateRegional;
          }
        }
        if (previous === boundaries_1.CLUSTER_BREAK.CR && next === boundaries_1.CLUSTER_BREAK.LF) {
          return NotBreak;
        } else if (previous === boundaries_1.CLUSTER_BREAK.CONTROL || previous === boundaries_1.CLUSTER_BREAK.CR || previous === boundaries_1.CLUSTER_BREAK.LF) {
          return BreakStart;
        } else if (next === boundaries_1.CLUSTER_BREAK.CONTROL || next === boundaries_1.CLUSTER_BREAK.CR || next === boundaries_1.CLUSTER_BREAK.LF) {
          return BreakStart;
        } else if (previous === boundaries_1.CLUSTER_BREAK.L && (next === boundaries_1.CLUSTER_BREAK.L || next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.LV || next === boundaries_1.CLUSTER_BREAK.LVT)) {
          return NotBreak;
        } else if ((previous === boundaries_1.CLUSTER_BREAK.LV || previous === boundaries_1.CLUSTER_BREAK.V) && (next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.T)) {
          return NotBreak;
        } else if ((previous === boundaries_1.CLUSTER_BREAK.LVT || previous === boundaries_1.CLUSTER_BREAK.T) && next === boundaries_1.CLUSTER_BREAK.T) {
          return NotBreak;
        } else if (next === boundaries_1.CLUSTER_BREAK.EXTEND || next === boundaries_1.CLUSTER_BREAK.ZWJ) {
          return NotBreak;
        } else if (next === boundaries_1.CLUSTER_BREAK.SPACINGMARK) {
          return NotBreak;
        } else if (previous === boundaries_1.CLUSTER_BREAK.PREPEND) {
          return NotBreak;
        }
        const previousNonExtendIndex = allEmoji.slice(0, -1).lastIndexOf(boundaries_1.EXTENDED_PICTOGRAPHIC);
        if (previousNonExtendIndex !== -1 && allEmoji[previousNonExtendIndex] === boundaries_1.EXTENDED_PICTOGRAPHIC && all.slice(previousNonExtendIndex + 1, -2).every(function(c) {
          return c === boundaries_1.CLUSTER_BREAK.EXTEND;
        }) && previous === boundaries_1.CLUSTER_BREAK.ZWJ && nextEmoji === boundaries_1.EXTENDED_PICTOGRAPHIC) {
          return NotBreak;
        }
        if (mid.indexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1) {
          return Break;
        }
        if (previous === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR && next === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) {
          return NotBreak;
        }
        return BreakStart;
      }
    };
    exports.default = GraphemerHelper;
  }
});

// ../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/GraphemerIterator.js
var require_GraphemerIterator = __commonJS({
  "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/GraphemerIterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var GraphemerIterator = class {
      constructor(str, nextBreak) {
        this._index = 0;
        this._str = str;
        this._nextBreak = nextBreak;
      }
      [Symbol.iterator]() {
        return this;
      }
      next() {
        let brk;
        if ((brk = this._nextBreak(this._str, this._index)) < this._str.length) {
          const value = this._str.slice(this._index, brk);
          this._index = brk;
          return { value, done: false };
        }
        if (this._index < this._str.length) {
          const value = this._str.slice(this._index);
          this._index = this._str.length;
          return { value, done: false };
        }
        return { value: void 0, done: true };
      }
    };
    exports.default = GraphemerIterator;
  }
});

// ../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/Graphemer.js
var require_Graphemer = __commonJS({
  "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/Graphemer.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var boundaries_1 = require_boundaries();
    var GraphemerHelper_1 = __importDefault(require_GraphemerHelper());
    var GraphemerIterator_1 = __importDefault(require_GraphemerIterator());
    var Graphemer2 = class {
      static nextBreak(string3, index) {
        if (index === void 0) {
          index = 0;
        }
        if (index < 0) {
          return 0;
        }
        if (index >= string3.length - 1) {
          return string3.length;
        }
        const prevCP = GraphemerHelper_1.default.codePointAt(string3, index);
        const prev = Graphemer2.getGraphemeBreakProperty(prevCP);
        const prevEmoji = Graphemer2.getEmojiProperty(prevCP);
        const mid = [];
        const midEmoji = [];
        for (let i = index + 1; i < string3.length; i++) {
          if (GraphemerHelper_1.default.isSurrogate(string3, i - 1)) {
            continue;
          }
          const nextCP = GraphemerHelper_1.default.codePointAt(string3, i);
          const next = Graphemer2.getGraphemeBreakProperty(nextCP);
          const nextEmoji = Graphemer2.getEmojiProperty(nextCP);
          if (GraphemerHelper_1.default.shouldBreak(prev, mid, next, prevEmoji, midEmoji, nextEmoji)) {
            return i;
          }
          mid.push(next);
          midEmoji.push(nextEmoji);
        }
        return string3.length;
      }
      splitGraphemes(str) {
        const res = [];
        let index = 0;
        let brk;
        while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
          res.push(str.slice(index, brk));
          index = brk;
        }
        if (index < str.length) {
          res.push(str.slice(index));
        }
        return res;
      }
      iterateGraphemes(str) {
        return new GraphemerIterator_1.default(str, Graphemer2.nextBreak);
      }
      countGraphemes(str) {
        let count = 0;
        let index = 0;
        let brk;
        while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
          index = brk;
          count++;
        }
        if (index < str.length) {
          count++;
        }
        return count;
      }
      static getGraphemeBreakProperty(code4) {
        if (code4 < 48905) {
          if (code4 < 44116) {
            if (code4 < 4141) {
              if (code4 < 2818) {
                if (code4 < 2363) {
                  if (code4 < 1759) {
                    if (code4 < 1471) {
                      if (code4 < 127) {
                        if (code4 < 11) {
                          if (code4 < 10) {
                            if (0 <= code4 && code4 <= 9) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code4 === 10) {
                              return boundaries_1.CLUSTER_BREAK.LF;
                            }
                          }
                        } else {
                          if (code4 < 13) {
                            if (11 <= code4 && code4 <= 12) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code4 < 14) {
                              if (code4 === 13) {
                                return boundaries_1.CLUSTER_BREAK.CR;
                              }
                            } else {
                              if (14 <= code4 && code4 <= 31) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 768) {
                          if (code4 < 173) {
                            if (127 <= code4 && code4 <= 159) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code4 === 173) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          }
                        } else {
                          if (code4 < 1155) {
                            if (768 <= code4 && code4 <= 879) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 1425) {
                              if (1155 <= code4 && code4 <= 1161) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (1425 <= code4 && code4 <= 1469) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 1552) {
                        if (code4 < 1476) {
                          if (code4 < 1473) {
                            if (code4 === 1471) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1473 <= code4 && code4 <= 1474) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 1479) {
                            if (1476 <= code4 && code4 <= 1477) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 1536) {
                              if (code4 === 1479) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (1536 <= code4 && code4 <= 1541) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 1648) {
                          if (code4 < 1564) {
                            if (1552 <= code4 && code4 <= 1562) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 1611) {
                              if (code4 === 1564) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (1611 <= code4 && code4 <= 1631) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 1750) {
                            if (code4 === 1648) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 1757) {
                              if (1750 <= code4 && code4 <= 1756) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 1757) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 2075) {
                      if (code4 < 1840) {
                        if (code4 < 1770) {
                          if (code4 < 1767) {
                            if (1759 <= code4 && code4 <= 1764) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1767 <= code4 && code4 <= 1768) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 1807) {
                            if (1770 <= code4 && code4 <= 1773) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 1807) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                            if (code4 === 1809) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code4 < 2027) {
                          if (code4 < 1958) {
                            if (1840 <= code4 && code4 <= 1866) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1958 <= code4 && code4 <= 1968) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 2045) {
                            if (2027 <= code4 && code4 <= 2035) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 2070) {
                              if (code4 === 2045) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2070 <= code4 && code4 <= 2073) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 2200) {
                        if (code4 < 2089) {
                          if (code4 < 2085) {
                            if (2075 <= code4 && code4 <= 2083) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (2085 <= code4 && code4 <= 2087) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 2137) {
                            if (2089 <= code4 && code4 <= 2093) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 2192) {
                              if (2137 <= code4 && code4 <= 2139) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2192 <= code4 && code4 <= 2193) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 2275) {
                          if (code4 < 2250) {
                            if (2200 <= code4 && code4 <= 2207) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 2274) {
                              if (2250 <= code4 && code4 <= 2273) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 2274) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 2307) {
                            if (2275 <= code4 && code4 <= 2306) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 2307) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (code4 === 2362) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 2561) {
                    if (code4 < 2434) {
                      if (code4 < 2381) {
                        if (code4 < 2366) {
                          if (code4 === 2363) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (code4 === 2364) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code4 < 2369) {
                            if (2366 <= code4 && code4 <= 2368) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 2377) {
                              if (2369 <= code4 && code4 <= 2376) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2377 <= code4 && code4 <= 2380) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 2385) {
                          if (code4 < 2382) {
                            if (code4 === 2381) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (2382 <= code4 && code4 <= 2383) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 2402) {
                            if (2385 <= code4 && code4 <= 2391) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 2433) {
                              if (2402 <= code4 && code4 <= 2403) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 2433) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 2503) {
                        if (code4 < 2494) {
                          if (code4 < 2492) {
                            if (2434 <= code4 && code4 <= 2435) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 === 2492) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 2495) {
                            if (code4 === 2494) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 2497) {
                              if (2495 <= code4 && code4 <= 2496) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2497 <= code4 && code4 <= 2500) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 2519) {
                          if (code4 < 2507) {
                            if (2503 <= code4 && code4 <= 2504) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 2509) {
                              if (2507 <= code4 && code4 <= 2508) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code4 === 2509) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 2530) {
                            if (code4 === 2519) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 2558) {
                              if (2530 <= code4 && code4 <= 2531) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 2558) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 2691) {
                      if (code4 < 2631) {
                        if (code4 < 2620) {
                          if (code4 < 2563) {
                            if (2561 <= code4 && code4 <= 2562) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 2563) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 2622) {
                            if (code4 === 2620) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 2625) {
                              if (2622 <= code4 && code4 <= 2624) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2625 <= code4 && code4 <= 2626) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 2672) {
                          if (code4 < 2635) {
                            if (2631 <= code4 && code4 <= 2632) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 2641) {
                              if (2635 <= code4 && code4 <= 2637) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 2641) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 2677) {
                            if (2672 <= code4 && code4 <= 2673) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 2689) {
                              if (code4 === 2677) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2689 <= code4 && code4 <= 2690) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 2761) {
                        if (code4 < 2750) {
                          if (code4 === 2691) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (code4 === 2748) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code4 < 2753) {
                            if (2750 <= code4 && code4 <= 2752) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 2759) {
                              if (2753 <= code4 && code4 <= 2757) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2759 <= code4 && code4 <= 2760) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 2786) {
                          if (code4 < 2763) {
                            if (code4 === 2761) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 2765) {
                              if (2763 <= code4 && code4 <= 2764) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code4 === 2765) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 2810) {
                            if (2786 <= code4 && code4 <= 2787) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 2817) {
                              if (2810 <= code4 && code4 <= 2815) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 2817) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code4 < 3315) {
                  if (code4 < 3076) {
                    if (code4 < 2946) {
                      if (code4 < 2887) {
                        if (code4 < 2878) {
                          if (code4 < 2876) {
                            if (2818 <= code4 && code4 <= 2819) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 === 2876) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 2880) {
                            if (2878 <= code4 && code4 <= 2879) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 2881) {
                              if (code4 === 2880) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2881 <= code4 && code4 <= 2884) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 2893) {
                          if (code4 < 2891) {
                            if (2887 <= code4 && code4 <= 2888) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (2891 <= code4 && code4 <= 2892) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 2901) {
                            if (code4 === 2893) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 2914) {
                              if (2901 <= code4 && code4 <= 2903) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2914 <= code4 && code4 <= 2915) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 3014) {
                        if (code4 < 3007) {
                          if (code4 === 2946) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (code4 === 3006) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code4 < 3008) {
                            if (code4 === 3007) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 3009) {
                              if (code4 === 3008) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3009 <= code4 && code4 <= 3010) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 3031) {
                          if (code4 < 3018) {
                            if (3014 <= code4 && code4 <= 3016) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 3021) {
                              if (3018 <= code4 && code4 <= 3020) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code4 === 3021) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 3072) {
                            if (code4 === 3031) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 3073) {
                              if (code4 === 3072) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3073 <= code4 && code4 <= 3075) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 3262) {
                      if (code4 < 3146) {
                        if (code4 < 3134) {
                          if (code4 === 3076) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (code4 === 3132) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code4 < 3137) {
                            if (3134 <= code4 && code4 <= 3136) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 3142) {
                              if (3137 <= code4 && code4 <= 3140) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3142 <= code4 && code4 <= 3144) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 3201) {
                          if (code4 < 3157) {
                            if (3146 <= code4 && code4 <= 3149) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 3170) {
                              if (3157 <= code4 && code4 <= 3158) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3170 <= code4 && code4 <= 3171) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 3202) {
                            if (code4 === 3201) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 3260) {
                              if (3202 <= code4 && code4 <= 3203) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code4 === 3260) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 3270) {
                        if (code4 < 3264) {
                          if (code4 === 3262) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (code4 === 3263) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code4 < 3266) {
                            if (3264 <= code4 && code4 <= 3265) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 3267) {
                              if (code4 === 3266) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3267 <= code4 && code4 <= 3268) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 3276) {
                          if (code4 < 3271) {
                            if (code4 === 3270) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 3274) {
                              if (3271 <= code4 && code4 <= 3272) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3274 <= code4 && code4 <= 3275) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code4 < 3285) {
                            if (3276 <= code4 && code4 <= 3277) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 3298) {
                              if (3285 <= code4 && code4 <= 3286) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3298 <= code4 && code4 <= 3299) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 3551) {
                    if (code4 < 3406) {
                      if (code4 < 3391) {
                        if (code4 < 3330) {
                          if (code4 < 3328) {
                            if (code4 === 3315) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (3328 <= code4 && code4 <= 3329) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 3387) {
                            if (3330 <= code4 && code4 <= 3331) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 3390) {
                              if (3387 <= code4 && code4 <= 3388) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 3390) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 3398) {
                          if (code4 < 3393) {
                            if (3391 <= code4 && code4 <= 3392) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (3393 <= code4 && code4 <= 3396) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 3402) {
                            if (3398 <= code4 && code4 <= 3400) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 3405) {
                              if (3402 <= code4 && code4 <= 3404) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code4 === 3405) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 3530) {
                        if (code4 < 3426) {
                          if (code4 === 3406) {
                            return boundaries_1.CLUSTER_BREAK.PREPEND;
                          }
                          if (code4 === 3415) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code4 < 3457) {
                            if (3426 <= code4 && code4 <= 3427) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 3458) {
                              if (code4 === 3457) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3458 <= code4 && code4 <= 3459) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 3538) {
                          if (code4 < 3535) {
                            if (code4 === 3530) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 3536) {
                              if (code4 === 3535) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3536 <= code4 && code4 <= 3537) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code4 < 3542) {
                            if (3538 <= code4 && code4 <= 3540) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 3544) {
                              if (code4 === 3542) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3544 <= code4 && code4 <= 3550) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 3893) {
                      if (code4 < 3655) {
                        if (code4 < 3633) {
                          if (code4 < 3570) {
                            if (code4 === 3551) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (3570 <= code4 && code4 <= 3571) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 3635) {
                            if (code4 === 3633) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 3636) {
                              if (code4 === 3635) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3636 <= code4 && code4 <= 3642) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 3764) {
                          if (code4 < 3761) {
                            if (3655 <= code4 && code4 <= 3662) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 3761) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (code4 === 3763) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 3784) {
                            if (3764 <= code4 && code4 <= 3772) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 3864) {
                              if (3784 <= code4 && code4 <= 3790) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3864 <= code4 && code4 <= 3865) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 3967) {
                        if (code4 < 3897) {
                          if (code4 === 3893) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (code4 === 3895) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code4 < 3902) {
                            if (code4 === 3897) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 3953) {
                              if (3902 <= code4 && code4 <= 3903) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3953 <= code4 && code4 <= 3966) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 3981) {
                          if (code4 < 3968) {
                            if (code4 === 3967) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 3974) {
                              if (3968 <= code4 && code4 <= 3972) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3974 <= code4 && code4 <= 3975) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 3993) {
                            if (3981 <= code4 && code4 <= 3991) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 4038) {
                              if (3993 <= code4 && code4 <= 4028) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 4038) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code4 < 7204) {
                if (code4 < 6448) {
                  if (code4 < 5938) {
                    if (code4 < 4226) {
                      if (code4 < 4157) {
                        if (code4 < 4146) {
                          if (code4 < 4145) {
                            if (4141 <= code4 && code4 <= 4144) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 4145) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 4153) {
                            if (4146 <= code4 && code4 <= 4151) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 4155) {
                              if (4153 <= code4 && code4 <= 4154) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (4155 <= code4 && code4 <= 4156) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 4184) {
                          if (code4 < 4182) {
                            if (4157 <= code4 && code4 <= 4158) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (4182 <= code4 && code4 <= 4183) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 4190) {
                            if (4184 <= code4 && code4 <= 4185) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 4209) {
                              if (4190 <= code4 && code4 <= 4192) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (4209 <= code4 && code4 <= 4212) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 4352) {
                        if (code4 < 4229) {
                          if (code4 === 4226) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (code4 === 4228) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                        } else {
                          if (code4 < 4237) {
                            if (4229 <= code4 && code4 <= 4230) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 4237) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (code4 === 4253) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code4 < 4957) {
                          if (code4 < 4448) {
                            if (4352 <= code4 && code4 <= 4447) {
                              return boundaries_1.CLUSTER_BREAK.L;
                            }
                          } else {
                            if (code4 < 4520) {
                              if (4448 <= code4 && code4 <= 4519) {
                                return boundaries_1.CLUSTER_BREAK.V;
                              }
                            } else {
                              if (4520 <= code4 && code4 <= 4607) {
                                return boundaries_1.CLUSTER_BREAK.T;
                              }
                            }
                          }
                        } else {
                          if (code4 < 5906) {
                            if (4957 <= code4 && code4 <= 4959) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 5909) {
                              if (5906 <= code4 && code4 <= 5908) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 5909) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 6089) {
                      if (code4 < 6070) {
                        if (code4 < 5970) {
                          if (code4 < 5940) {
                            if (5938 <= code4 && code4 <= 5939) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 5940) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 6002) {
                            if (5970 <= code4 && code4 <= 5971) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 6068) {
                              if (6002 <= code4 && code4 <= 6003) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6068 <= code4 && code4 <= 6069) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 6078) {
                          if (code4 < 6071) {
                            if (code4 === 6070) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (6071 <= code4 && code4 <= 6077) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 6086) {
                            if (6078 <= code4 && code4 <= 6085) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 6087) {
                              if (code4 === 6086) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6087 <= code4 && code4 <= 6088) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 6277) {
                        if (code4 < 6155) {
                          if (code4 < 6109) {
                            if (6089 <= code4 && code4 <= 6099) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 6109) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 6158) {
                            if (6155 <= code4 && code4 <= 6157) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 6158) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                            if (code4 === 6159) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code4 < 6435) {
                          if (code4 < 6313) {
                            if (6277 <= code4 && code4 <= 6278) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 6432) {
                              if (code4 === 6313) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6432 <= code4 && code4 <= 6434) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 6439) {
                            if (6435 <= code4 && code4 <= 6438) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 6441) {
                              if (6439 <= code4 && code4 <= 6440) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6441 <= code4 && code4 <= 6443) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 6971) {
                    if (code4 < 6744) {
                      if (code4 < 6681) {
                        if (code4 < 6451) {
                          if (code4 < 6450) {
                            if (6448 <= code4 && code4 <= 6449) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 === 6450) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 6457) {
                            if (6451 <= code4 && code4 <= 6456) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 6679) {
                              if (6457 <= code4 && code4 <= 6459) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6679 <= code4 && code4 <= 6680) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 6741) {
                          if (code4 < 6683) {
                            if (6681 <= code4 && code4 <= 6682) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 === 6683) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 6742) {
                            if (code4 === 6741) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 === 6742) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (code4 === 6743) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 6771) {
                        if (code4 < 6754) {
                          if (code4 < 6752) {
                            if (6744 <= code4 && code4 <= 6750) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 6752) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 6757) {
                            if (code4 === 6754) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 6765) {
                              if (6757 <= code4 && code4 <= 6764) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6765 <= code4 && code4 <= 6770) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 6912) {
                          if (code4 < 6783) {
                            if (6771 <= code4 && code4 <= 6780) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 6832) {
                              if (code4 === 6783) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6832 <= code4 && code4 <= 6862) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 6916) {
                            if (6912 <= code4 && code4 <= 6915) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 6964) {
                              if (code4 === 6916) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (6964 <= code4 && code4 <= 6970) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 7080) {
                      if (code4 < 7019) {
                        if (code4 < 6973) {
                          if (code4 === 6971) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (code4 === 6972) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code4 < 6978) {
                            if (6973 <= code4 && code4 <= 6977) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 6979) {
                              if (code4 === 6978) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6979 <= code4 && code4 <= 6980) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 7073) {
                          if (code4 < 7040) {
                            if (7019 <= code4 && code4 <= 7027) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 7042) {
                              if (7040 <= code4 && code4 <= 7041) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 7042) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code4 < 7074) {
                            if (code4 === 7073) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 7078) {
                              if (7074 <= code4 && code4 <= 7077) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7078 <= code4 && code4 <= 7079) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 7144) {
                        if (code4 < 7083) {
                          if (code4 < 7082) {
                            if (7080 <= code4 && code4 <= 7081) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 7082) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 7142) {
                            if (7083 <= code4 && code4 <= 7085) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 7142) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (code4 === 7143) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      } else {
                        if (code4 < 7150) {
                          if (code4 < 7146) {
                            if (7144 <= code4 && code4 <= 7145) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 7149) {
                              if (7146 <= code4 && code4 <= 7148) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code4 === 7149) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 7151) {
                            if (code4 === 7150) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 7154) {
                              if (7151 <= code4 && code4 <= 7153) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7154 <= code4 && code4 <= 7155) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code4 < 43346) {
                  if (code4 < 11647) {
                    if (code4 < 7415) {
                      if (code4 < 7380) {
                        if (code4 < 7220) {
                          if (code4 < 7212) {
                            if (7204 <= code4 && code4 <= 7211) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (7212 <= code4 && code4 <= 7219) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 7222) {
                            if (7220 <= code4 && code4 <= 7221) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 7376) {
                              if (7222 <= code4 && code4 <= 7223) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7376 <= code4 && code4 <= 7378) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 7394) {
                          if (code4 < 7393) {
                            if (7380 <= code4 && code4 <= 7392) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 7393) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 7405) {
                            if (7394 <= code4 && code4 <= 7400) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 7405) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (code4 === 7412) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 8205) {
                        if (code4 < 7616) {
                          if (code4 < 7416) {
                            if (code4 === 7415) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (7416 <= code4 && code4 <= 7417) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 8203) {
                            if (7616 <= code4 && code4 <= 7679) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 8203) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                            if (code4 === 8204) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code4 < 8288) {
                          if (code4 < 8206) {
                            if (code4 === 8205) {
                              return boundaries_1.CLUSTER_BREAK.ZWJ;
                            }
                          } else {
                            if (code4 < 8232) {
                              if (8206 <= code4 && code4 <= 8207) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (8232 <= code4 && code4 <= 8238) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        } else {
                          if (code4 < 8400) {
                            if (8288 <= code4 && code4 <= 8303) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code4 < 11503) {
                              if (8400 <= code4 && code4 <= 8432) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (11503 <= code4 && code4 <= 11505) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 43043) {
                      if (code4 < 42612) {
                        if (code4 < 12330) {
                          if (code4 < 11744) {
                            if (code4 === 11647) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (11744 <= code4 && code4 <= 11775) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 12441) {
                            if (12330 <= code4 && code4 <= 12335) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 42607) {
                              if (12441 <= code4 && code4 <= 12442) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (42607 <= code4 && code4 <= 42610) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 43010) {
                          if (code4 < 42654) {
                            if (42612 <= code4 && code4 <= 42621) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 42736) {
                              if (42654 <= code4 && code4 <= 42655) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (42736 <= code4 && code4 <= 42737) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 43014) {
                            if (code4 === 43010) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 43014) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (code4 === 43019) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 43188) {
                        if (code4 < 43047) {
                          if (code4 < 43045) {
                            if (43043 <= code4 && code4 <= 43044) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43045 <= code4 && code4 <= 43046) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 43052) {
                            if (code4 === 43047) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 43136) {
                              if (code4 === 43052) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43136 <= code4 && code4 <= 43137) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 43263) {
                          if (code4 < 43204) {
                            if (43188 <= code4 && code4 <= 43203) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 43232) {
                              if (43204 <= code4 && code4 <= 43205) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43232 <= code4 && code4 <= 43249) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 43302) {
                            if (code4 === 43263) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 43335) {
                              if (43302 <= code4 && code4 <= 43309) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43335 <= code4 && code4 <= 43345) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 43698) {
                    if (code4 < 43493) {
                      if (code4 < 43444) {
                        if (code4 < 43392) {
                          if (code4 < 43360) {
                            if (43346 <= code4 && code4 <= 43347) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43360 <= code4 && code4 <= 43388) {
                              return boundaries_1.CLUSTER_BREAK.L;
                            }
                          }
                        } else {
                          if (code4 < 43395) {
                            if (43392 <= code4 && code4 <= 43394) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 43395) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (code4 === 43443) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code4 < 43450) {
                          if (code4 < 43446) {
                            if (43444 <= code4 && code4 <= 43445) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43446 <= code4 && code4 <= 43449) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 43452) {
                            if (43450 <= code4 && code4 <= 43451) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 43454) {
                              if (43452 <= code4 && code4 <= 43453) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43454 <= code4 && code4 <= 43456) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 43573) {
                        if (code4 < 43567) {
                          if (code4 < 43561) {
                            if (code4 === 43493) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43561 <= code4 && code4 <= 43566) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 43569) {
                            if (43567 <= code4 && code4 <= 43568) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 43571) {
                              if (43569 <= code4 && code4 <= 43570) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43571 <= code4 && code4 <= 43572) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 43597) {
                          if (code4 < 43587) {
                            if (43573 <= code4 && code4 <= 43574) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 43587) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (code4 === 43596) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 43644) {
                            if (code4 === 43597) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 === 43644) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (code4 === 43696) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 44006) {
                      if (code4 < 43756) {
                        if (code4 < 43710) {
                          if (code4 < 43703) {
                            if (43698 <= code4 && code4 <= 43700) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43703 <= code4 && code4 <= 43704) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 43713) {
                            if (43710 <= code4 && code4 <= 43711) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 43713) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (code4 === 43755) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      } else {
                        if (code4 < 43766) {
                          if (code4 < 43758) {
                            if (43756 <= code4 && code4 <= 43757) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 43765) {
                              if (43758 <= code4 && code4 <= 43759) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code4 === 43765) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code4 < 44003) {
                            if (code4 === 43766) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 44005) {
                              if (44003 <= code4 && code4 <= 44004) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code4 === 44005) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 44032) {
                        if (code4 < 44009) {
                          if (code4 < 44008) {
                            if (44006 <= code4 && code4 <= 44007) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 === 44008) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 44012) {
                            if (44009 <= code4 && code4 <= 44010) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 === 44012) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (code4 === 44013) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code4 < 44061) {
                          if (code4 < 44033) {
                            if (code4 === 44032) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 44060) {
                              if (44033 <= code4 && code4 <= 44059) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 44060) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 44088) {
                            if (44061 <= code4 && code4 <= 44087) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 44089) {
                              if (code4 === 44088) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44089 <= code4 && code4 <= 44115) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code4 < 46497) {
              if (code4 < 45293) {
                if (code4 < 44704) {
                  if (code4 < 44397) {
                    if (code4 < 44256) {
                      if (code4 < 44173) {
                        if (code4 < 44144) {
                          if (code4 < 44117) {
                            if (code4 === 44116) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44117 <= code4 && code4 <= 44143) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 44145) {
                            if (code4 === 44144) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 44172) {
                              if (44145 <= code4 && code4 <= 44171) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 44172) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 44201) {
                          if (code4 < 44200) {
                            if (44173 <= code4 && code4 <= 44199) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 44200) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 44228) {
                            if (44201 <= code4 && code4 <= 44227) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 44229) {
                              if (code4 === 44228) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44229 <= code4 && code4 <= 44255) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 44313) {
                        if (code4 < 44284) {
                          if (code4 < 44257) {
                            if (code4 === 44256) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44257 <= code4 && code4 <= 44283) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 44285) {
                            if (code4 === 44284) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 44312) {
                              if (44285 <= code4 && code4 <= 44311) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 44312) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 44368) {
                          if (code4 < 44340) {
                            if (44313 <= code4 && code4 <= 44339) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 44341) {
                              if (code4 === 44340) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44341 <= code4 && code4 <= 44367) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 44369) {
                            if (code4 === 44368) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 44396) {
                              if (44369 <= code4 && code4 <= 44395) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 44396) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 44537) {
                      if (code4 < 44480) {
                        if (code4 < 44425) {
                          if (code4 < 44424) {
                            if (44397 <= code4 && code4 <= 44423) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 44424) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 44452) {
                            if (44425 <= code4 && code4 <= 44451) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 44453) {
                              if (code4 === 44452) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44453 <= code4 && code4 <= 44479) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 44508) {
                          if (code4 < 44481) {
                            if (code4 === 44480) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44481 <= code4 && code4 <= 44507) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 44509) {
                            if (code4 === 44508) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 44536) {
                              if (44509 <= code4 && code4 <= 44535) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 44536) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 44620) {
                        if (code4 < 44565) {
                          if (code4 < 44564) {
                            if (44537 <= code4 && code4 <= 44563) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 44564) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 44592) {
                            if (44565 <= code4 && code4 <= 44591) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 44593) {
                              if (code4 === 44592) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44593 <= code4 && code4 <= 44619) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 44649) {
                          if (code4 < 44621) {
                            if (code4 === 44620) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 44648) {
                              if (44621 <= code4 && code4 <= 44647) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 44648) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 44676) {
                            if (44649 <= code4 && code4 <= 44675) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 44677) {
                              if (code4 === 44676) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44677 <= code4 && code4 <= 44703) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 44985) {
                    if (code4 < 44844) {
                      if (code4 < 44761) {
                        if (code4 < 44732) {
                          if (code4 < 44705) {
                            if (code4 === 44704) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44705 <= code4 && code4 <= 44731) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 44733) {
                            if (code4 === 44732) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 44760) {
                              if (44733 <= code4 && code4 <= 44759) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 44760) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 44789) {
                          if (code4 < 44788) {
                            if (44761 <= code4 && code4 <= 44787) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 44788) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 44816) {
                            if (44789 <= code4 && code4 <= 44815) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 44817) {
                              if (code4 === 44816) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44817 <= code4 && code4 <= 44843) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 44901) {
                        if (code4 < 44872) {
                          if (code4 < 44845) {
                            if (code4 === 44844) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44845 <= code4 && code4 <= 44871) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 44873) {
                            if (code4 === 44872) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 44900) {
                              if (44873 <= code4 && code4 <= 44899) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 44900) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 44956) {
                          if (code4 < 44928) {
                            if (44901 <= code4 && code4 <= 44927) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 44929) {
                              if (code4 === 44928) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44929 <= code4 && code4 <= 44955) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 44957) {
                            if (code4 === 44956) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 44984) {
                              if (44957 <= code4 && code4 <= 44983) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 44984) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 45152) {
                      if (code4 < 45068) {
                        if (code4 < 45013) {
                          if (code4 < 45012) {
                            if (44985 <= code4 && code4 <= 45011) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 45012) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 45040) {
                            if (45013 <= code4 && code4 <= 45039) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 45041) {
                              if (code4 === 45040) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45041 <= code4 && code4 <= 45067) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 45097) {
                          if (code4 < 45069) {
                            if (code4 === 45068) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 45096) {
                              if (45069 <= code4 && code4 <= 45095) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 45096) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 45124) {
                            if (45097 <= code4 && code4 <= 45123) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 45125) {
                              if (code4 === 45124) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45125 <= code4 && code4 <= 45151) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 45209) {
                        if (code4 < 45180) {
                          if (code4 < 45153) {
                            if (code4 === 45152) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45153 <= code4 && code4 <= 45179) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 45181) {
                            if (code4 === 45180) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 45208) {
                              if (45181 <= code4 && code4 <= 45207) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 45208) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 45264) {
                          if (code4 < 45236) {
                            if (45209 <= code4 && code4 <= 45235) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 45237) {
                              if (code4 === 45236) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45237 <= code4 && code4 <= 45263) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 45265) {
                            if (code4 === 45264) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 45292) {
                              if (45265 <= code4 && code4 <= 45291) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 45292) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code4 < 45908) {
                  if (code4 < 45600) {
                    if (code4 < 45433) {
                      if (code4 < 45376) {
                        if (code4 < 45321) {
                          if (code4 < 45320) {
                            if (45293 <= code4 && code4 <= 45319) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 45320) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 45348) {
                            if (45321 <= code4 && code4 <= 45347) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 45349) {
                              if (code4 === 45348) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45349 <= code4 && code4 <= 45375) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 45404) {
                          if (code4 < 45377) {
                            if (code4 === 45376) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45377 <= code4 && code4 <= 45403) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 45405) {
                            if (code4 === 45404) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 45432) {
                              if (45405 <= code4 && code4 <= 45431) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 45432) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 45516) {
                        if (code4 < 45461) {
                          if (code4 < 45460) {
                            if (45433 <= code4 && code4 <= 45459) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 45460) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 45488) {
                            if (45461 <= code4 && code4 <= 45487) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 45489) {
                              if (code4 === 45488) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45489 <= code4 && code4 <= 45515) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 45545) {
                          if (code4 < 45517) {
                            if (code4 === 45516) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 45544) {
                              if (45517 <= code4 && code4 <= 45543) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 45544) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 45572) {
                            if (45545 <= code4 && code4 <= 45571) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 45573) {
                              if (code4 === 45572) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45573 <= code4 && code4 <= 45599) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 45741) {
                      if (code4 < 45657) {
                        if (code4 < 45628) {
                          if (code4 < 45601) {
                            if (code4 === 45600) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45601 <= code4 && code4 <= 45627) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 45629) {
                            if (code4 === 45628) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 45656) {
                              if (45629 <= code4 && code4 <= 45655) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 45656) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 45712) {
                          if (code4 < 45684) {
                            if (45657 <= code4 && code4 <= 45683) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 45685) {
                              if (code4 === 45684) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45685 <= code4 && code4 <= 45711) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 45713) {
                            if (code4 === 45712) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 45740) {
                              if (45713 <= code4 && code4 <= 45739) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 45740) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 45824) {
                        if (code4 < 45769) {
                          if (code4 < 45768) {
                            if (45741 <= code4 && code4 <= 45767) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 45768) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 45796) {
                            if (45769 <= code4 && code4 <= 45795) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 45797) {
                              if (code4 === 45796) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45797 <= code4 && code4 <= 45823) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 45853) {
                          if (code4 < 45825) {
                            if (code4 === 45824) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 45852) {
                              if (45825 <= code4 && code4 <= 45851) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 45852) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 45880) {
                            if (45853 <= code4 && code4 <= 45879) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 45881) {
                              if (code4 === 45880) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45881 <= code4 && code4 <= 45907) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 46189) {
                    if (code4 < 46048) {
                      if (code4 < 45965) {
                        if (code4 < 45936) {
                          if (code4 < 45909) {
                            if (code4 === 45908) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45909 <= code4 && code4 <= 45935) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 45937) {
                            if (code4 === 45936) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 45964) {
                              if (45937 <= code4 && code4 <= 45963) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 45964) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 45993) {
                          if (code4 < 45992) {
                            if (45965 <= code4 && code4 <= 45991) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 45992) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 46020) {
                            if (45993 <= code4 && code4 <= 46019) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 46021) {
                              if (code4 === 46020) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46021 <= code4 && code4 <= 46047) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 46105) {
                        if (code4 < 46076) {
                          if (code4 < 46049) {
                            if (code4 === 46048) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46049 <= code4 && code4 <= 46075) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 46077) {
                            if (code4 === 46076) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 46104) {
                              if (46077 <= code4 && code4 <= 46103) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 46104) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 46160) {
                          if (code4 < 46132) {
                            if (46105 <= code4 && code4 <= 46131) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 46133) {
                              if (code4 === 46132) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46133 <= code4 && code4 <= 46159) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 46161) {
                            if (code4 === 46160) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 46188) {
                              if (46161 <= code4 && code4 <= 46187) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 46188) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 46356) {
                      if (code4 < 46272) {
                        if (code4 < 46217) {
                          if (code4 < 46216) {
                            if (46189 <= code4 && code4 <= 46215) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 46216) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 46244) {
                            if (46217 <= code4 && code4 <= 46243) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 46245) {
                              if (code4 === 46244) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46245 <= code4 && code4 <= 46271) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 46301) {
                          if (code4 < 46273) {
                            if (code4 === 46272) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 46300) {
                              if (46273 <= code4 && code4 <= 46299) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 46300) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 46328) {
                            if (46301 <= code4 && code4 <= 46327) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 46329) {
                              if (code4 === 46328) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46329 <= code4 && code4 <= 46355) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 46413) {
                        if (code4 < 46384) {
                          if (code4 < 46357) {
                            if (code4 === 46356) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46357 <= code4 && code4 <= 46383) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 46385) {
                            if (code4 === 46384) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 46412) {
                              if (46385 <= code4 && code4 <= 46411) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 46412) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 46468) {
                          if (code4 < 46440) {
                            if (46413 <= code4 && code4 <= 46439) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 46441) {
                              if (code4 === 46440) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46441 <= code4 && code4 <= 46467) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 46469) {
                            if (code4 === 46468) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 46496) {
                              if (46469 <= code4 && code4 <= 46495) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 46496) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code4 < 47701) {
                if (code4 < 47112) {
                  if (code4 < 46804) {
                    if (code4 < 46637) {
                      if (code4 < 46580) {
                        if (code4 < 46525) {
                          if (code4 < 46524) {
                            if (46497 <= code4 && code4 <= 46523) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 46524) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 46552) {
                            if (46525 <= code4 && code4 <= 46551) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 46553) {
                              if (code4 === 46552) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46553 <= code4 && code4 <= 46579) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 46608) {
                          if (code4 < 46581) {
                            if (code4 === 46580) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46581 <= code4 && code4 <= 46607) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 46609) {
                            if (code4 === 46608) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 46636) {
                              if (46609 <= code4 && code4 <= 46635) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 46636) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 46720) {
                        if (code4 < 46665) {
                          if (code4 < 46664) {
                            if (46637 <= code4 && code4 <= 46663) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 46664) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 46692) {
                            if (46665 <= code4 && code4 <= 46691) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 46693) {
                              if (code4 === 46692) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46693 <= code4 && code4 <= 46719) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 46749) {
                          if (code4 < 46721) {
                            if (code4 === 46720) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 46748) {
                              if (46721 <= code4 && code4 <= 46747) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 46748) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 46776) {
                            if (46749 <= code4 && code4 <= 46775) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 46777) {
                              if (code4 === 46776) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46777 <= code4 && code4 <= 46803) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 46945) {
                      if (code4 < 46861) {
                        if (code4 < 46832) {
                          if (code4 < 46805) {
                            if (code4 === 46804) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46805 <= code4 && code4 <= 46831) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 46833) {
                            if (code4 === 46832) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 46860) {
                              if (46833 <= code4 && code4 <= 46859) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 46860) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 46916) {
                          if (code4 < 46888) {
                            if (46861 <= code4 && code4 <= 46887) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 46889) {
                              if (code4 === 46888) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46889 <= code4 && code4 <= 46915) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 46917) {
                            if (code4 === 46916) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 46944) {
                              if (46917 <= code4 && code4 <= 46943) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 46944) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 47028) {
                        if (code4 < 46973) {
                          if (code4 < 46972) {
                            if (46945 <= code4 && code4 <= 46971) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 46972) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 47e3) {
                            if (46973 <= code4 && code4 <= 46999) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 47001) {
                              if (code4 === 47e3) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47001 <= code4 && code4 <= 47027) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 47057) {
                          if (code4 < 47029) {
                            if (code4 === 47028) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 47056) {
                              if (47029 <= code4 && code4 <= 47055) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 47056) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 47084) {
                            if (47057 <= code4 && code4 <= 47083) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 47085) {
                              if (code4 === 47084) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47085 <= code4 && code4 <= 47111) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 47393) {
                    if (code4 < 47252) {
                      if (code4 < 47169) {
                        if (code4 < 47140) {
                          if (code4 < 47113) {
                            if (code4 === 47112) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47113 <= code4 && code4 <= 47139) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 47141) {
                            if (code4 === 47140) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 47168) {
                              if (47141 <= code4 && code4 <= 47167) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 47168) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 47197) {
                          if (code4 < 47196) {
                            if (47169 <= code4 && code4 <= 47195) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 47196) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 47224) {
                            if (47197 <= code4 && code4 <= 47223) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 47225) {
                              if (code4 === 47224) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47225 <= code4 && code4 <= 47251) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 47309) {
                        if (code4 < 47280) {
                          if (code4 < 47253) {
                            if (code4 === 47252) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47253 <= code4 && code4 <= 47279) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 47281) {
                            if (code4 === 47280) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 47308) {
                              if (47281 <= code4 && code4 <= 47307) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 47308) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 47364) {
                          if (code4 < 47336) {
                            if (47309 <= code4 && code4 <= 47335) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 47337) {
                              if (code4 === 47336) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47337 <= code4 && code4 <= 47363) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 47365) {
                            if (code4 === 47364) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 47392) {
                              if (47365 <= code4 && code4 <= 47391) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 47392) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 47560) {
                      if (code4 < 47476) {
                        if (code4 < 47421) {
                          if (code4 < 47420) {
                            if (47393 <= code4 && code4 <= 47419) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 47420) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 47448) {
                            if (47421 <= code4 && code4 <= 47447) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 47449) {
                              if (code4 === 47448) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47449 <= code4 && code4 <= 47475) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 47505) {
                          if (code4 < 47477) {
                            if (code4 === 47476) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 47504) {
                              if (47477 <= code4 && code4 <= 47503) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 47504) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 47532) {
                            if (47505 <= code4 && code4 <= 47531) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 47533) {
                              if (code4 === 47532) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47533 <= code4 && code4 <= 47559) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 47617) {
                        if (code4 < 47588) {
                          if (code4 < 47561) {
                            if (code4 === 47560) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47561 <= code4 && code4 <= 47587) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 47589) {
                            if (code4 === 47588) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 47616) {
                              if (47589 <= code4 && code4 <= 47615) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 47616) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 47672) {
                          if (code4 < 47644) {
                            if (47617 <= code4 && code4 <= 47643) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 47645) {
                              if (code4 === 47644) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47645 <= code4 && code4 <= 47671) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 47673) {
                            if (code4 === 47672) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 47700) {
                              if (47673 <= code4 && code4 <= 47699) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 47700) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code4 < 48316) {
                  if (code4 < 48008) {
                    if (code4 < 47841) {
                      if (code4 < 47784) {
                        if (code4 < 47729) {
                          if (code4 < 47728) {
                            if (47701 <= code4 && code4 <= 47727) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 47728) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 47756) {
                            if (47729 <= code4 && code4 <= 47755) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 47757) {
                              if (code4 === 47756) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47757 <= code4 && code4 <= 47783) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 47812) {
                          if (code4 < 47785) {
                            if (code4 === 47784) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47785 <= code4 && code4 <= 47811) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 47813) {
                            if (code4 === 47812) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 47840) {
                              if (47813 <= code4 && code4 <= 47839) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 47840) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 47924) {
                        if (code4 < 47869) {
                          if (code4 < 47868) {
                            if (47841 <= code4 && code4 <= 47867) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 47868) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 47896) {
                            if (47869 <= code4 && code4 <= 47895) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 47897) {
                              if (code4 === 47896) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47897 <= code4 && code4 <= 47923) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 47953) {
                          if (code4 < 47925) {
                            if (code4 === 47924) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 47952) {
                              if (47925 <= code4 && code4 <= 47951) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 47952) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 47980) {
                            if (47953 <= code4 && code4 <= 47979) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 47981) {
                              if (code4 === 47980) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47981 <= code4 && code4 <= 48007) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 48149) {
                      if (code4 < 48065) {
                        if (code4 < 48036) {
                          if (code4 < 48009) {
                            if (code4 === 48008) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48009 <= code4 && code4 <= 48035) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 48037) {
                            if (code4 === 48036) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 48064) {
                              if (48037 <= code4 && code4 <= 48063) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 48064) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 48120) {
                          if (code4 < 48092) {
                            if (48065 <= code4 && code4 <= 48091) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 48093) {
                              if (code4 === 48092) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48093 <= code4 && code4 <= 48119) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 48121) {
                            if (code4 === 48120) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 48148) {
                              if (48121 <= code4 && code4 <= 48147) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 48148) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 48232) {
                        if (code4 < 48177) {
                          if (code4 < 48176) {
                            if (48149 <= code4 && code4 <= 48175) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 48176) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 48204) {
                            if (48177 <= code4 && code4 <= 48203) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 48205) {
                              if (code4 === 48204) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48205 <= code4 && code4 <= 48231) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 48261) {
                          if (code4 < 48233) {
                            if (code4 === 48232) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 48260) {
                              if (48233 <= code4 && code4 <= 48259) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 48260) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 48288) {
                            if (48261 <= code4 && code4 <= 48287) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 48289) {
                              if (code4 === 48288) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48289 <= code4 && code4 <= 48315) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 48597) {
                    if (code4 < 48456) {
                      if (code4 < 48373) {
                        if (code4 < 48344) {
                          if (code4 < 48317) {
                            if (code4 === 48316) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48317 <= code4 && code4 <= 48343) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 48345) {
                            if (code4 === 48344) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 48372) {
                              if (48345 <= code4 && code4 <= 48371) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 48372) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 48401) {
                          if (code4 < 48400) {
                            if (48373 <= code4 && code4 <= 48399) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 48400) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 48428) {
                            if (48401 <= code4 && code4 <= 48427) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 48429) {
                              if (code4 === 48428) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48429 <= code4 && code4 <= 48455) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 48513) {
                        if (code4 < 48484) {
                          if (code4 < 48457) {
                            if (code4 === 48456) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48457 <= code4 && code4 <= 48483) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 48485) {
                            if (code4 === 48484) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 48512) {
                              if (48485 <= code4 && code4 <= 48511) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 48512) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 48568) {
                          if (code4 < 48540) {
                            if (48513 <= code4 && code4 <= 48539) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 48541) {
                              if (code4 === 48540) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48541 <= code4 && code4 <= 48567) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 48569) {
                            if (code4 === 48568) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 48596) {
                              if (48569 <= code4 && code4 <= 48595) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 48596) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 48764) {
                      if (code4 < 48680) {
                        if (code4 < 48625) {
                          if (code4 < 48624) {
                            if (48597 <= code4 && code4 <= 48623) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 48624) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 48652) {
                            if (48625 <= code4 && code4 <= 48651) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 48653) {
                              if (code4 === 48652) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48653 <= code4 && code4 <= 48679) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 48709) {
                          if (code4 < 48681) {
                            if (code4 === 48680) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 48708) {
                              if (48681 <= code4 && code4 <= 48707) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 48708) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 48736) {
                            if (48709 <= code4 && code4 <= 48735) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 48737) {
                              if (code4 === 48736) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48737 <= code4 && code4 <= 48763) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 48821) {
                        if (code4 < 48792) {
                          if (code4 < 48765) {
                            if (code4 === 48764) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48765 <= code4 && code4 <= 48791) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 48793) {
                            if (code4 === 48792) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 48820) {
                              if (48793 <= code4 && code4 <= 48819) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 48820) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 48876) {
                          if (code4 < 48848) {
                            if (48821 <= code4 && code4 <= 48847) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 48849) {
                              if (code4 === 48848) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48849 <= code4 && code4 <= 48875) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 48877) {
                            if (code4 === 48876) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 48904) {
                              if (48877 <= code4 && code4 <= 48903) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 48904) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (code4 < 53720) {
            if (code4 < 51312) {
              if (code4 < 50108) {
                if (code4 < 49493) {
                  if (code4 < 49212) {
                    if (code4 < 49045) {
                      if (code4 < 48988) {
                        if (code4 < 48933) {
                          if (code4 < 48932) {
                            if (48905 <= code4 && code4 <= 48931) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 48932) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 48960) {
                            if (48933 <= code4 && code4 <= 48959) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 48961) {
                              if (code4 === 48960) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48961 <= code4 && code4 <= 48987) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 49016) {
                          if (code4 < 48989) {
                            if (code4 === 48988) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48989 <= code4 && code4 <= 49015) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 49017) {
                            if (code4 === 49016) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 49044) {
                              if (49017 <= code4 && code4 <= 49043) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 49044) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 49128) {
                        if (code4 < 49073) {
                          if (code4 < 49072) {
                            if (49045 <= code4 && code4 <= 49071) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 49072) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 49100) {
                            if (49073 <= code4 && code4 <= 49099) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 49101) {
                              if (code4 === 49100) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49101 <= code4 && code4 <= 49127) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 49157) {
                          if (code4 < 49129) {
                            if (code4 === 49128) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 49156) {
                              if (49129 <= code4 && code4 <= 49155) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 49156) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 49184) {
                            if (49157 <= code4 && code4 <= 49183) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 49185) {
                              if (code4 === 49184) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49185 <= code4 && code4 <= 49211) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 49352) {
                      if (code4 < 49269) {
                        if (code4 < 49240) {
                          if (code4 < 49213) {
                            if (code4 === 49212) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49213 <= code4 && code4 <= 49239) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 49241) {
                            if (code4 === 49240) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 49268) {
                              if (49241 <= code4 && code4 <= 49267) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 49268) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 49297) {
                          if (code4 < 49296) {
                            if (49269 <= code4 && code4 <= 49295) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 49296) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 49324) {
                            if (49297 <= code4 && code4 <= 49323) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 49325) {
                              if (code4 === 49324) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49325 <= code4 && code4 <= 49351) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 49409) {
                        if (code4 < 49380) {
                          if (code4 < 49353) {
                            if (code4 === 49352) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49353 <= code4 && code4 <= 49379) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 49381) {
                            if (code4 === 49380) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 49408) {
                              if (49381 <= code4 && code4 <= 49407) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 49408) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 49464) {
                          if (code4 < 49436) {
                            if (49409 <= code4 && code4 <= 49435) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 49437) {
                              if (code4 === 49436) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49437 <= code4 && code4 <= 49463) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 49465) {
                            if (code4 === 49464) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 49492) {
                              if (49465 <= code4 && code4 <= 49491) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 49492) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 49800) {
                    if (code4 < 49633) {
                      if (code4 < 49576) {
                        if (code4 < 49521) {
                          if (code4 < 49520) {
                            if (49493 <= code4 && code4 <= 49519) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 49520) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 49548) {
                            if (49521 <= code4 && code4 <= 49547) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 49549) {
                              if (code4 === 49548) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49549 <= code4 && code4 <= 49575) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 49604) {
                          if (code4 < 49577) {
                            if (code4 === 49576) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49577 <= code4 && code4 <= 49603) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 49605) {
                            if (code4 === 49604) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 49632) {
                              if (49605 <= code4 && code4 <= 49631) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 49632) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 49716) {
                        if (code4 < 49661) {
                          if (code4 < 49660) {
                            if (49633 <= code4 && code4 <= 49659) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 49660) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 49688) {
                            if (49661 <= code4 && code4 <= 49687) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 49689) {
                              if (code4 === 49688) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49689 <= code4 && code4 <= 49715) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 49745) {
                          if (code4 < 49717) {
                            if (code4 === 49716) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 49744) {
                              if (49717 <= code4 && code4 <= 49743) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 49744) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 49772) {
                            if (49745 <= code4 && code4 <= 49771) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 49773) {
                              if (code4 === 49772) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49773 <= code4 && code4 <= 49799) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 49941) {
                      if (code4 < 49857) {
                        if (code4 < 49828) {
                          if (code4 < 49801) {
                            if (code4 === 49800) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49801 <= code4 && code4 <= 49827) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 49829) {
                            if (code4 === 49828) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 49856) {
                              if (49829 <= code4 && code4 <= 49855) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 49856) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 49912) {
                          if (code4 < 49884) {
                            if (49857 <= code4 && code4 <= 49883) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 49885) {
                              if (code4 === 49884) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49885 <= code4 && code4 <= 49911) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 49913) {
                            if (code4 === 49912) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 49940) {
                              if (49913 <= code4 && code4 <= 49939) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 49940) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 50024) {
                        if (code4 < 49969) {
                          if (code4 < 49968) {
                            if (49941 <= code4 && code4 <= 49967) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 49968) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 49996) {
                            if (49969 <= code4 && code4 <= 49995) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 49997) {
                              if (code4 === 49996) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49997 <= code4 && code4 <= 50023) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 50053) {
                          if (code4 < 50025) {
                            if (code4 === 50024) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 50052) {
                              if (50025 <= code4 && code4 <= 50051) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 50052) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 50080) {
                            if (50053 <= code4 && code4 <= 50079) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 50081) {
                              if (code4 === 50080) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50081 <= code4 && code4 <= 50107) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code4 < 50697) {
                  if (code4 < 50389) {
                    if (code4 < 50248) {
                      if (code4 < 50165) {
                        if (code4 < 50136) {
                          if (code4 < 50109) {
                            if (code4 === 50108) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50109 <= code4 && code4 <= 50135) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 50137) {
                            if (code4 === 50136) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 50164) {
                              if (50137 <= code4 && code4 <= 50163) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 50164) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 50193) {
                          if (code4 < 50192) {
                            if (50165 <= code4 && code4 <= 50191) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 50192) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 50220) {
                            if (50193 <= code4 && code4 <= 50219) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 50221) {
                              if (code4 === 50220) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50221 <= code4 && code4 <= 50247) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 50305) {
                        if (code4 < 50276) {
                          if (code4 < 50249) {
                            if (code4 === 50248) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50249 <= code4 && code4 <= 50275) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 50277) {
                            if (code4 === 50276) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 50304) {
                              if (50277 <= code4 && code4 <= 50303) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 50304) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 50360) {
                          if (code4 < 50332) {
                            if (50305 <= code4 && code4 <= 50331) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 50333) {
                              if (code4 === 50332) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50333 <= code4 && code4 <= 50359) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 50361) {
                            if (code4 === 50360) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 50388) {
                              if (50361 <= code4 && code4 <= 50387) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 50388) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 50556) {
                      if (code4 < 50472) {
                        if (code4 < 50417) {
                          if (code4 < 50416) {
                            if (50389 <= code4 && code4 <= 50415) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 50416) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 50444) {
                            if (50417 <= code4 && code4 <= 50443) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 50445) {
                              if (code4 === 50444) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50445 <= code4 && code4 <= 50471) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 50501) {
                          if (code4 < 50473) {
                            if (code4 === 50472) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 50500) {
                              if (50473 <= code4 && code4 <= 50499) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 50500) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 50528) {
                            if (50501 <= code4 && code4 <= 50527) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 50529) {
                              if (code4 === 50528) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50529 <= code4 && code4 <= 50555) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 50613) {
                        if (code4 < 50584) {
                          if (code4 < 50557) {
                            if (code4 === 50556) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50557 <= code4 && code4 <= 50583) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 50585) {
                            if (code4 === 50584) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 50612) {
                              if (50585 <= code4 && code4 <= 50611) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 50612) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 50668) {
                          if (code4 < 50640) {
                            if (50613 <= code4 && code4 <= 50639) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 50641) {
                              if (code4 === 50640) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50641 <= code4 && code4 <= 50667) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 50669) {
                            if (code4 === 50668) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 50696) {
                              if (50669 <= code4 && code4 <= 50695) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 50696) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 51004) {
                    if (code4 < 50837) {
                      if (code4 < 50780) {
                        if (code4 < 50725) {
                          if (code4 < 50724) {
                            if (50697 <= code4 && code4 <= 50723) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 50724) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 50752) {
                            if (50725 <= code4 && code4 <= 50751) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 50753) {
                              if (code4 === 50752) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50753 <= code4 && code4 <= 50779) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 50808) {
                          if (code4 < 50781) {
                            if (code4 === 50780) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50781 <= code4 && code4 <= 50807) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 50809) {
                            if (code4 === 50808) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 50836) {
                              if (50809 <= code4 && code4 <= 50835) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 50836) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 50920) {
                        if (code4 < 50865) {
                          if (code4 < 50864) {
                            if (50837 <= code4 && code4 <= 50863) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 50864) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 50892) {
                            if (50865 <= code4 && code4 <= 50891) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 50893) {
                              if (code4 === 50892) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50893 <= code4 && code4 <= 50919) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 50949) {
                          if (code4 < 50921) {
                            if (code4 === 50920) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 50948) {
                              if (50921 <= code4 && code4 <= 50947) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 50948) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 50976) {
                            if (50949 <= code4 && code4 <= 50975) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 50977) {
                              if (code4 === 50976) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50977 <= code4 && code4 <= 51003) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 51145) {
                      if (code4 < 51061) {
                        if (code4 < 51032) {
                          if (code4 < 51005) {
                            if (code4 === 51004) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51005 <= code4 && code4 <= 51031) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 51033) {
                            if (code4 === 51032) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 51060) {
                              if (51033 <= code4 && code4 <= 51059) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 51060) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 51116) {
                          if (code4 < 51088) {
                            if (51061 <= code4 && code4 <= 51087) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 51089) {
                              if (code4 === 51088) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51089 <= code4 && code4 <= 51115) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 51117) {
                            if (code4 === 51116) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 51144) {
                              if (51117 <= code4 && code4 <= 51143) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 51144) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 51228) {
                        if (code4 < 51173) {
                          if (code4 < 51172) {
                            if (51145 <= code4 && code4 <= 51171) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 51172) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 51200) {
                            if (51173 <= code4 && code4 <= 51199) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 51201) {
                              if (code4 === 51200) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51201 <= code4 && code4 <= 51227) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 51257) {
                          if (code4 < 51229) {
                            if (code4 === 51228) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 51256) {
                              if (51229 <= code4 && code4 <= 51255) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 51256) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 51284) {
                            if (51257 <= code4 && code4 <= 51283) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 51285) {
                              if (code4 === 51284) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51285 <= code4 && code4 <= 51311) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code4 < 52516) {
                if (code4 < 51901) {
                  if (code4 < 51593) {
                    if (code4 < 51452) {
                      if (code4 < 51369) {
                        if (code4 < 51340) {
                          if (code4 < 51313) {
                            if (code4 === 51312) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51313 <= code4 && code4 <= 51339) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 51341) {
                            if (code4 === 51340) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 51368) {
                              if (51341 <= code4 && code4 <= 51367) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 51368) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 51397) {
                          if (code4 < 51396) {
                            if (51369 <= code4 && code4 <= 51395) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 51396) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 51424) {
                            if (51397 <= code4 && code4 <= 51423) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 51425) {
                              if (code4 === 51424) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51425 <= code4 && code4 <= 51451) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 51509) {
                        if (code4 < 51480) {
                          if (code4 < 51453) {
                            if (code4 === 51452) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51453 <= code4 && code4 <= 51479) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 51481) {
                            if (code4 === 51480) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 51508) {
                              if (51481 <= code4 && code4 <= 51507) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 51508) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 51564) {
                          if (code4 < 51536) {
                            if (51509 <= code4 && code4 <= 51535) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 51537) {
                              if (code4 === 51536) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51537 <= code4 && code4 <= 51563) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 51565) {
                            if (code4 === 51564) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 51592) {
                              if (51565 <= code4 && code4 <= 51591) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 51592) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 51760) {
                      if (code4 < 51676) {
                        if (code4 < 51621) {
                          if (code4 < 51620) {
                            if (51593 <= code4 && code4 <= 51619) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 51620) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 51648) {
                            if (51621 <= code4 && code4 <= 51647) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 51649) {
                              if (code4 === 51648) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51649 <= code4 && code4 <= 51675) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 51705) {
                          if (code4 < 51677) {
                            if (code4 === 51676) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 51704) {
                              if (51677 <= code4 && code4 <= 51703) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 51704) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 51732) {
                            if (51705 <= code4 && code4 <= 51731) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 51733) {
                              if (code4 === 51732) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51733 <= code4 && code4 <= 51759) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 51817) {
                        if (code4 < 51788) {
                          if (code4 < 51761) {
                            if (code4 === 51760) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51761 <= code4 && code4 <= 51787) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 51789) {
                            if (code4 === 51788) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 51816) {
                              if (51789 <= code4 && code4 <= 51815) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 51816) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 51872) {
                          if (code4 < 51844) {
                            if (51817 <= code4 && code4 <= 51843) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 51845) {
                              if (code4 === 51844) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51845 <= code4 && code4 <= 51871) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 51873) {
                            if (code4 === 51872) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 51900) {
                              if (51873 <= code4 && code4 <= 51899) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 51900) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 52208) {
                    if (code4 < 52041) {
                      if (code4 < 51984) {
                        if (code4 < 51929) {
                          if (code4 < 51928) {
                            if (51901 <= code4 && code4 <= 51927) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 51928) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 51956) {
                            if (51929 <= code4 && code4 <= 51955) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 51957) {
                              if (code4 === 51956) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51957 <= code4 && code4 <= 51983) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 52012) {
                          if (code4 < 51985) {
                            if (code4 === 51984) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51985 <= code4 && code4 <= 52011) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 52013) {
                            if (code4 === 52012) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 52040) {
                              if (52013 <= code4 && code4 <= 52039) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 52040) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 52124) {
                        if (code4 < 52069) {
                          if (code4 < 52068) {
                            if (52041 <= code4 && code4 <= 52067) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 52068) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 52096) {
                            if (52069 <= code4 && code4 <= 52095) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 52097) {
                              if (code4 === 52096) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52097 <= code4 && code4 <= 52123) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 52153) {
                          if (code4 < 52125) {
                            if (code4 === 52124) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 52152) {
                              if (52125 <= code4 && code4 <= 52151) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 52152) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 52180) {
                            if (52153 <= code4 && code4 <= 52179) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 52181) {
                              if (code4 === 52180) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52181 <= code4 && code4 <= 52207) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 52349) {
                      if (code4 < 52265) {
                        if (code4 < 52236) {
                          if (code4 < 52209) {
                            if (code4 === 52208) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52209 <= code4 && code4 <= 52235) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 52237) {
                            if (code4 === 52236) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 52264) {
                              if (52237 <= code4 && code4 <= 52263) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 52264) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 52320) {
                          if (code4 < 52292) {
                            if (52265 <= code4 && code4 <= 52291) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 52293) {
                              if (code4 === 52292) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52293 <= code4 && code4 <= 52319) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 52321) {
                            if (code4 === 52320) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 52348) {
                              if (52321 <= code4 && code4 <= 52347) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 52348) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 52432) {
                        if (code4 < 52377) {
                          if (code4 < 52376) {
                            if (52349 <= code4 && code4 <= 52375) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 52376) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 52404) {
                            if (52377 <= code4 && code4 <= 52403) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 52405) {
                              if (code4 === 52404) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52405 <= code4 && code4 <= 52431) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 52461) {
                          if (code4 < 52433) {
                            if (code4 === 52432) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 52460) {
                              if (52433 <= code4 && code4 <= 52459) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 52460) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 52488) {
                            if (52461 <= code4 && code4 <= 52487) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 52489) {
                              if (code4 === 52488) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52489 <= code4 && code4 <= 52515) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code4 < 53105) {
                  if (code4 < 52797) {
                    if (code4 < 52656) {
                      if (code4 < 52573) {
                        if (code4 < 52544) {
                          if (code4 < 52517) {
                            if (code4 === 52516) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52517 <= code4 && code4 <= 52543) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 52545) {
                            if (code4 === 52544) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 52572) {
                              if (52545 <= code4 && code4 <= 52571) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 52572) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 52601) {
                          if (code4 < 52600) {
                            if (52573 <= code4 && code4 <= 52599) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 52600) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 52628) {
                            if (52601 <= code4 && code4 <= 52627) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 52629) {
                              if (code4 === 52628) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52629 <= code4 && code4 <= 52655) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 52713) {
                        if (code4 < 52684) {
                          if (code4 < 52657) {
                            if (code4 === 52656) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52657 <= code4 && code4 <= 52683) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 52685) {
                            if (code4 === 52684) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 52712) {
                              if (52685 <= code4 && code4 <= 52711) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 52712) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 52768) {
                          if (code4 < 52740) {
                            if (52713 <= code4 && code4 <= 52739) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 52741) {
                              if (code4 === 52740) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52741 <= code4 && code4 <= 52767) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 52769) {
                            if (code4 === 52768) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 52796) {
                              if (52769 <= code4 && code4 <= 52795) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 52796) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 52964) {
                      if (code4 < 52880) {
                        if (code4 < 52825) {
                          if (code4 < 52824) {
                            if (52797 <= code4 && code4 <= 52823) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 52824) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 52852) {
                            if (52825 <= code4 && code4 <= 52851) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 52853) {
                              if (code4 === 52852) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52853 <= code4 && code4 <= 52879) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 52909) {
                          if (code4 < 52881) {
                            if (code4 === 52880) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 52908) {
                              if (52881 <= code4 && code4 <= 52907) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 52908) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 52936) {
                            if (52909 <= code4 && code4 <= 52935) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 52937) {
                              if (code4 === 52936) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52937 <= code4 && code4 <= 52963) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 53021) {
                        if (code4 < 52992) {
                          if (code4 < 52965) {
                            if (code4 === 52964) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52965 <= code4 && code4 <= 52991) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 52993) {
                            if (code4 === 52992) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 53020) {
                              if (52993 <= code4 && code4 <= 53019) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 53020) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 53076) {
                          if (code4 < 53048) {
                            if (53021 <= code4 && code4 <= 53047) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 53049) {
                              if (code4 === 53048) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53049 <= code4 && code4 <= 53075) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 53077) {
                            if (code4 === 53076) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 53104) {
                              if (53077 <= code4 && code4 <= 53103) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 53104) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 53412) {
                    if (code4 < 53245) {
                      if (code4 < 53188) {
                        if (code4 < 53133) {
                          if (code4 < 53132) {
                            if (53105 <= code4 && code4 <= 53131) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 53132) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 53160) {
                            if (53133 <= code4 && code4 <= 53159) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 53161) {
                              if (code4 === 53160) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53161 <= code4 && code4 <= 53187) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 53216) {
                          if (code4 < 53189) {
                            if (code4 === 53188) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53189 <= code4 && code4 <= 53215) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 53217) {
                            if (code4 === 53216) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 53244) {
                              if (53217 <= code4 && code4 <= 53243) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 53244) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 53328) {
                        if (code4 < 53273) {
                          if (code4 < 53272) {
                            if (53245 <= code4 && code4 <= 53271) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 53272) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 53300) {
                            if (53273 <= code4 && code4 <= 53299) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 53301) {
                              if (code4 === 53300) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53301 <= code4 && code4 <= 53327) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 53357) {
                          if (code4 < 53329) {
                            if (code4 === 53328) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 53356) {
                              if (53329 <= code4 && code4 <= 53355) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 53356) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 53384) {
                            if (53357 <= code4 && code4 <= 53383) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 53385) {
                              if (code4 === 53384) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53385 <= code4 && code4 <= 53411) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 53553) {
                      if (code4 < 53469) {
                        if (code4 < 53440) {
                          if (code4 < 53413) {
                            if (code4 === 53412) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53413 <= code4 && code4 <= 53439) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 53441) {
                            if (code4 === 53440) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 53468) {
                              if (53441 <= code4 && code4 <= 53467) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 53468) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 53524) {
                          if (code4 < 53496) {
                            if (53469 <= code4 && code4 <= 53495) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 53497) {
                              if (code4 === 53496) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53497 <= code4 && code4 <= 53523) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 53525) {
                            if (code4 === 53524) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 53552) {
                              if (53525 <= code4 && code4 <= 53551) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 53552) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 53636) {
                        if (code4 < 53581) {
                          if (code4 < 53580) {
                            if (53553 <= code4 && code4 <= 53579) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 53580) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 53608) {
                            if (53581 <= code4 && code4 <= 53607) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 53609) {
                              if (code4 === 53608) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53609 <= code4 && code4 <= 53635) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 53665) {
                          if (code4 < 53637) {
                            if (code4 === 53636) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 53664) {
                              if (53637 <= code4 && code4 <= 53663) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 53664) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 53692) {
                            if (53665 <= code4 && code4 <= 53691) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 53693) {
                              if (code4 === 53692) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53693 <= code4 && code4 <= 53719) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code4 < 70459) {
              if (code4 < 54897) {
                if (code4 < 54308) {
                  if (code4 < 54001) {
                    if (code4 < 53860) {
                      if (code4 < 53777) {
                        if (code4 < 53748) {
                          if (code4 < 53721) {
                            if (code4 === 53720) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53721 <= code4 && code4 <= 53747) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 53749) {
                            if (code4 === 53748) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 53776) {
                              if (53749 <= code4 && code4 <= 53775) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 53776) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 53805) {
                          if (code4 < 53804) {
                            if (53777 <= code4 && code4 <= 53803) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 53804) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 53832) {
                            if (53805 <= code4 && code4 <= 53831) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 53833) {
                              if (code4 === 53832) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53833 <= code4 && code4 <= 53859) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 53917) {
                        if (code4 < 53888) {
                          if (code4 < 53861) {
                            if (code4 === 53860) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53861 <= code4 && code4 <= 53887) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 53889) {
                            if (code4 === 53888) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 53916) {
                              if (53889 <= code4 && code4 <= 53915) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 53916) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 53972) {
                          if (code4 < 53944) {
                            if (53917 <= code4 && code4 <= 53943) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 53945) {
                              if (code4 === 53944) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53945 <= code4 && code4 <= 53971) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 53973) {
                            if (code4 === 53972) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 54e3) {
                              if (53973 <= code4 && code4 <= 53999) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 54e3) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 54141) {
                      if (code4 < 54084) {
                        if (code4 < 54029) {
                          if (code4 < 54028) {
                            if (54001 <= code4 && code4 <= 54027) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 54028) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 54056) {
                            if (54029 <= code4 && code4 <= 54055) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 54057) {
                              if (code4 === 54056) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54057 <= code4 && code4 <= 54083) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 54112) {
                          if (code4 < 54085) {
                            if (code4 === 54084) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54085 <= code4 && code4 <= 54111) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 54113) {
                            if (code4 === 54112) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 54140) {
                              if (54113 <= code4 && code4 <= 54139) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 54140) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 54224) {
                        if (code4 < 54169) {
                          if (code4 < 54168) {
                            if (54141 <= code4 && code4 <= 54167) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 54168) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 54196) {
                            if (54169 <= code4 && code4 <= 54195) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 54197) {
                              if (code4 === 54196) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54197 <= code4 && code4 <= 54223) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 54253) {
                          if (code4 < 54225) {
                            if (code4 === 54224) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 54252) {
                              if (54225 <= code4 && code4 <= 54251) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 54252) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 54280) {
                            if (54253 <= code4 && code4 <= 54279) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 54281) {
                              if (code4 === 54280) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54281 <= code4 && code4 <= 54307) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 54589) {
                    if (code4 < 54448) {
                      if (code4 < 54365) {
                        if (code4 < 54336) {
                          if (code4 < 54309) {
                            if (code4 === 54308) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54309 <= code4 && code4 <= 54335) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 54337) {
                            if (code4 === 54336) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 54364) {
                              if (54337 <= code4 && code4 <= 54363) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 54364) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 54393) {
                          if (code4 < 54392) {
                            if (54365 <= code4 && code4 <= 54391) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 54392) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 54420) {
                            if (54393 <= code4 && code4 <= 54419) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 54421) {
                              if (code4 === 54420) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54421 <= code4 && code4 <= 54447) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 54505) {
                        if (code4 < 54476) {
                          if (code4 < 54449) {
                            if (code4 === 54448) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54449 <= code4 && code4 <= 54475) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 54477) {
                            if (code4 === 54476) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 54504) {
                              if (54477 <= code4 && code4 <= 54503) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 54504) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 54560) {
                          if (code4 < 54532) {
                            if (54505 <= code4 && code4 <= 54531) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 54533) {
                              if (code4 === 54532) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54533 <= code4 && code4 <= 54559) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 54561) {
                            if (code4 === 54560) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 54588) {
                              if (54561 <= code4 && code4 <= 54587) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 54588) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 54756) {
                      if (code4 < 54672) {
                        if (code4 < 54617) {
                          if (code4 < 54616) {
                            if (54589 <= code4 && code4 <= 54615) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 54616) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 54644) {
                            if (54617 <= code4 && code4 <= 54643) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 54645) {
                              if (code4 === 54644) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54645 <= code4 && code4 <= 54671) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 54701) {
                          if (code4 < 54673) {
                            if (code4 === 54672) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 54700) {
                              if (54673 <= code4 && code4 <= 54699) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 54700) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 54728) {
                            if (54701 <= code4 && code4 <= 54727) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 54729) {
                              if (code4 === 54728) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54729 <= code4 && code4 <= 54755) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 54813) {
                        if (code4 < 54784) {
                          if (code4 < 54757) {
                            if (code4 === 54756) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54757 <= code4 && code4 <= 54783) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 54785) {
                            if (code4 === 54784) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 54812) {
                              if (54785 <= code4 && code4 <= 54811) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 54812) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 54868) {
                          if (code4 < 54840) {
                            if (54813 <= code4 && code4 <= 54839) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 54841) {
                              if (code4 === 54840) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54841 <= code4 && code4 <= 54867) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code4 < 54869) {
                            if (code4 === 54868) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 54896) {
                              if (54869 <= code4 && code4 <= 54895) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 54896) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code4 < 69632) {
                  if (code4 < 55216) {
                    if (code4 < 55037) {
                      if (code4 < 54980) {
                        if (code4 < 54925) {
                          if (code4 < 54924) {
                            if (54897 <= code4 && code4 <= 54923) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 54924) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 54952) {
                            if (54925 <= code4 && code4 <= 54951) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 54953) {
                              if (code4 === 54952) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54953 <= code4 && code4 <= 54979) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 55008) {
                          if (code4 < 54981) {
                            if (code4 === 54980) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54981 <= code4 && code4 <= 55007) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code4 < 55009) {
                            if (code4 === 55008) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 55036) {
                              if (55009 <= code4 && code4 <= 55035) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 55036) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 55120) {
                        if (code4 < 55065) {
                          if (code4 < 55064) {
                            if (55037 <= code4 && code4 <= 55063) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 === 55064) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code4 < 55092) {
                            if (55065 <= code4 && code4 <= 55091) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 55093) {
                              if (code4 === 55092) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (55093 <= code4 && code4 <= 55119) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 55149) {
                          if (code4 < 55121) {
                            if (code4 === 55120) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code4 < 55148) {
                              if (55121 <= code4 && code4 <= 55147) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (code4 === 55148) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code4 < 55176) {
                            if (55149 <= code4 && code4 <= 55175) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code4 < 55177) {
                              if (code4 === 55176) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (55177 <= code4 && code4 <= 55203) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 68097) {
                      if (code4 < 65279) {
                        if (code4 < 64286) {
                          if (code4 < 55243) {
                            if (55216 <= code4 && code4 <= 55238) {
                              return boundaries_1.CLUSTER_BREAK.V;
                            }
                          } else {
                            if (55243 <= code4 && code4 <= 55291) {
                              return boundaries_1.CLUSTER_BREAK.T;
                            }
                          }
                        } else {
                          if (code4 < 65024) {
                            if (code4 === 64286) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 65056) {
                              if (65024 <= code4 && code4 <= 65039) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (65056 <= code4 && code4 <= 65071) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 66045) {
                          if (code4 < 65438) {
                            if (code4 === 65279) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code4 < 65520) {
                              if (65438 <= code4 && code4 <= 65439) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (65520 <= code4 && code4 <= 65531) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        } else {
                          if (code4 < 66272) {
                            if (code4 === 66045) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 66422) {
                              if (code4 === 66272) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (66422 <= code4 && code4 <= 66426) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 68325) {
                        if (code4 < 68108) {
                          if (code4 < 68101) {
                            if (68097 <= code4 && code4 <= 68099) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (68101 <= code4 && code4 <= 68102) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 68152) {
                            if (68108 <= code4 && code4 <= 68111) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 68159) {
                              if (68152 <= code4 && code4 <= 68154) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 68159) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 69373) {
                          if (code4 < 68900) {
                            if (68325 <= code4 && code4 <= 68326) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 69291) {
                              if (68900 <= code4 && code4 <= 68903) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (69291 <= code4 && code4 <= 69292) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 69446) {
                            if (69373 <= code4 && code4 <= 69375) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 69506) {
                              if (69446 <= code4 && code4 <= 69456) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (69506 <= code4 && code4 <= 69509) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 70016) {
                    if (code4 < 69815) {
                      if (code4 < 69747) {
                        if (code4 < 69634) {
                          if (code4 === 69632) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (code4 === 69633) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code4 < 69688) {
                            if (code4 === 69634) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 69744) {
                              if (69688 <= code4 && code4 <= 69702) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 69744) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 69762) {
                          if (code4 < 69759) {
                            if (69747 <= code4 && code4 <= 69748) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (69759 <= code4 && code4 <= 69761) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 69808) {
                            if (code4 === 69762) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 69811) {
                              if (69808 <= code4 && code4 <= 69810) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (69811 <= code4 && code4 <= 69814) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 69888) {
                        if (code4 < 69821) {
                          if (code4 < 69817) {
                            if (69815 <= code4 && code4 <= 69816) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (69817 <= code4 && code4 <= 69818) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 69826) {
                            if (code4 === 69821) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (code4 === 69826) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (code4 === 69837) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          }
                        }
                      } else {
                        if (code4 < 69933) {
                          if (code4 < 69927) {
                            if (69888 <= code4 && code4 <= 69890) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 69932) {
                              if (69927 <= code4 && code4 <= 69931) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 69932) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code4 < 69957) {
                            if (69933 <= code4 && code4 <= 69940) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 70003) {
                              if (69957 <= code4 && code4 <= 69958) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code4 === 70003) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 70194) {
                      if (code4 < 70082) {
                        if (code4 < 70067) {
                          if (code4 < 70018) {
                            if (70016 <= code4 && code4 <= 70017) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 70018) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 70070) {
                            if (70067 <= code4 && code4 <= 70069) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 70079) {
                              if (70070 <= code4 && code4 <= 70078) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70079 <= code4 && code4 <= 70080) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 70095) {
                          if (code4 < 70089) {
                            if (70082 <= code4 && code4 <= 70083) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (code4 < 70094) {
                              if (70089 <= code4 && code4 <= 70092) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 70094) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code4 < 70188) {
                            if (code4 === 70095) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 70191) {
                              if (70188 <= code4 && code4 <= 70190) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70191 <= code4 && code4 <= 70193) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 70209) {
                        if (code4 < 70197) {
                          if (code4 < 70196) {
                            if (70194 <= code4 && code4 <= 70195) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 === 70196) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 70198) {
                            if (code4 === 70197) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 70206) {
                              if (70198 <= code4 && code4 <= 70199) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 70206) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 70371) {
                          if (code4 < 70367) {
                            if (code4 === 70209) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 70368) {
                              if (code4 === 70367) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70368 <= code4 && code4 <= 70370) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code4 < 70400) {
                            if (70371 <= code4 && code4 <= 70378) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 70402) {
                              if (70400 <= code4 && code4 <= 70401) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70402 <= code4 && code4 <= 70403) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code4 < 72343) {
                if (code4 < 71339) {
                  if (code4 < 70841) {
                    if (code4 < 70512) {
                      if (code4 < 70471) {
                        if (code4 < 70463) {
                          if (code4 < 70462) {
                            if (70459 <= code4 && code4 <= 70460) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 70462) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 70464) {
                            if (code4 === 70463) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 70465) {
                              if (code4 === 70464) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70465 <= code4 && code4 <= 70468) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 70487) {
                          if (code4 < 70475) {
                            if (70471 <= code4 && code4 <= 70472) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (70475 <= code4 && code4 <= 70477) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 70498) {
                            if (code4 === 70487) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 70502) {
                              if (70498 <= code4 && code4 <= 70499) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70502 <= code4 && code4 <= 70508) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 70725) {
                        if (code4 < 70712) {
                          if (code4 < 70709) {
                            if (70512 <= code4 && code4 <= 70516) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (70709 <= code4 && code4 <= 70711) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 70720) {
                            if (70712 <= code4 && code4 <= 70719) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 70722) {
                              if (70720 <= code4 && code4 <= 70721) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70722 <= code4 && code4 <= 70724) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 70832) {
                          if (code4 < 70726) {
                            if (code4 === 70725) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 === 70726) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (code4 === 70750) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 70833) {
                            if (code4 === 70832) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 70835) {
                              if (70833 <= code4 && code4 <= 70834) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70835 <= code4 && code4 <= 70840) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 71096) {
                      if (code4 < 70847) {
                        if (code4 < 70843) {
                          if (code4 === 70841) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (code4 === 70842) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code4 < 70845) {
                            if (70843 <= code4 && code4 <= 70844) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 === 70845) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (code4 === 70846) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      } else {
                        if (code4 < 71087) {
                          if (code4 < 70849) {
                            if (70847 <= code4 && code4 <= 70848) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 70850) {
                              if (code4 === 70849) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70850 <= code4 && code4 <= 70851) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 71088) {
                            if (code4 === 71087) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 71090) {
                              if (71088 <= code4 && code4 <= 71089) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71090 <= code4 && code4 <= 71093) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 71216) {
                        if (code4 < 71102) {
                          if (code4 < 71100) {
                            if (71096 <= code4 && code4 <= 71099) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (71100 <= code4 && code4 <= 71101) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 71103) {
                            if (code4 === 71102) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 71132) {
                              if (71103 <= code4 && code4 <= 71104) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (71132 <= code4 && code4 <= 71133) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 71229) {
                          if (code4 < 71219) {
                            if (71216 <= code4 && code4 <= 71218) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 71227) {
                              if (71219 <= code4 && code4 <= 71226) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (71227 <= code4 && code4 <= 71228) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code4 < 71230) {
                            if (code4 === 71229) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 71231) {
                              if (code4 === 71230) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71231 <= code4 && code4 <= 71232) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 71999) {
                    if (code4 < 71463) {
                      if (code4 < 71350) {
                        if (code4 < 71341) {
                          if (code4 === 71339) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (code4 === 71340) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                        } else {
                          if (code4 < 71342) {
                            if (code4 === 71341) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 71344) {
                              if (71342 <= code4 && code4 <= 71343) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71344 <= code4 && code4 <= 71349) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 71453) {
                          if (code4 === 71350) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (code4 === 71351) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code4 < 71458) {
                            if (71453 <= code4 && code4 <= 71455) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 71462) {
                              if (71458 <= code4 && code4 <= 71461) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 71462) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 71984) {
                        if (code4 < 71727) {
                          if (code4 < 71724) {
                            if (71463 <= code4 && code4 <= 71467) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (71724 <= code4 && code4 <= 71726) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 71736) {
                            if (71727 <= code4 && code4 <= 71735) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 71737) {
                              if (code4 === 71736) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71737 <= code4 && code4 <= 71738) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 71995) {
                          if (code4 < 71985) {
                            if (code4 === 71984) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 71991) {
                              if (71985 <= code4 && code4 <= 71989) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71991 <= code4 && code4 <= 71992) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code4 < 71997) {
                            if (71995 <= code4 && code4 <= 71996) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 71997) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (code4 === 71998) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 72193) {
                      if (code4 < 72145) {
                        if (code4 < 72001) {
                          if (code4 === 71999) {
                            return boundaries_1.CLUSTER_BREAK.PREPEND;
                          }
                          if (code4 === 72e3) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                        } else {
                          if (code4 < 72002) {
                            if (code4 === 72001) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (code4 === 72002) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (code4 === 72003) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code4 < 72156) {
                          if (code4 < 72148) {
                            if (72145 <= code4 && code4 <= 72147) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 72154) {
                              if (72148 <= code4 && code4 <= 72151) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (72154 <= code4 && code4 <= 72155) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 72160) {
                            if (72156 <= code4 && code4 <= 72159) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 === 72160) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (code4 === 72164) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 72263) {
                        if (code4 < 72249) {
                          if (code4 < 72243) {
                            if (72193 <= code4 && code4 <= 72202) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (72243 <= code4 && code4 <= 72248) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 72250) {
                            if (code4 === 72249) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 72251) {
                              if (code4 === 72250) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            } else {
                              if (72251 <= code4 && code4 <= 72254) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 72281) {
                          if (code4 < 72273) {
                            if (code4 === 72263) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 72279) {
                              if (72273 <= code4 && code4 <= 72278) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (72279 <= code4 && code4 <= 72280) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code4 < 72324) {
                            if (72281 <= code4 && code4 <= 72283) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 72330) {
                              if (72324 <= code4 && code4 <= 72329) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            } else {
                              if (72330 <= code4 && code4 <= 72342) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code4 < 94033) {
                  if (code4 < 73104) {
                    if (code4 < 72881) {
                      if (code4 < 72766) {
                        if (code4 < 72751) {
                          if (code4 < 72344) {
                            if (code4 === 72343) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (72344 <= code4 && code4 <= 72345) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 72752) {
                            if (code4 === 72751) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 72760) {
                              if (72752 <= code4 && code4 <= 72758) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (72760 <= code4 && code4 <= 72765) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 72850) {
                          if (code4 === 72766) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (code4 === 72767) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code4 < 72873) {
                            if (72850 <= code4 && code4 <= 72871) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 72874) {
                              if (code4 === 72873) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (72874 <= code4 && code4 <= 72880) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 73018) {
                        if (code4 < 72884) {
                          if (code4 < 72882) {
                            if (code4 === 72881) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (72882 <= code4 && code4 <= 72883) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 72885) {
                            if (code4 === 72884) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code4 < 73009) {
                              if (72885 <= code4 && code4 <= 72886) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (73009 <= code4 && code4 <= 73014) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 73030) {
                          if (code4 < 73020) {
                            if (code4 === 73018) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 73023) {
                              if (73020 <= code4 && code4 <= 73021) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (73023 <= code4 && code4 <= 73029) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 73031) {
                            if (code4 === 73030) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (code4 < 73098) {
                              if (code4 === 73031) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (73098 <= code4 && code4 <= 73102) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 73526) {
                      if (code4 < 73459) {
                        if (code4 < 73109) {
                          if (code4 < 73107) {
                            if (73104 <= code4 && code4 <= 73105) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (73107 <= code4 && code4 <= 73108) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 73110) {
                            if (code4 === 73109) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 73110) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (code4 === 73111) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code4 < 73474) {
                          if (code4 < 73461) {
                            if (73459 <= code4 && code4 <= 73460) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 73472) {
                              if (73461 <= code4 && code4 <= 73462) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (73472 <= code4 && code4 <= 73473) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 73475) {
                            if (code4 === 73474) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (code4 < 73524) {
                              if (code4 === 73475) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (73524 <= code4 && code4 <= 73525) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 78896) {
                        if (code4 < 73536) {
                          if (code4 < 73534) {
                            if (73526 <= code4 && code4 <= 73530) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (73534 <= code4 && code4 <= 73535) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 73537) {
                            if (code4 === 73536) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 73537) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (code4 === 73538) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code4 < 92912) {
                          if (code4 < 78912) {
                            if (78896 <= code4 && code4 <= 78911) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code4 < 78919) {
                              if (code4 === 78912) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (78919 <= code4 && code4 <= 78933) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 92976) {
                            if (92912 <= code4 && code4 <= 92916) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 94031) {
                              if (92976 <= code4 && code4 <= 92982) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 94031) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 121476) {
                    if (code4 < 119143) {
                      if (code4 < 113824) {
                        if (code4 < 94180) {
                          if (code4 < 94095) {
                            if (94033 <= code4 && code4 <= 94087) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (94095 <= code4 && code4 <= 94098) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 94192) {
                            if (code4 === 94180) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 113821) {
                              if (94192 <= code4 && code4 <= 94193) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (113821 <= code4 && code4 <= 113822) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 118576) {
                          if (code4 < 118528) {
                            if (113824 <= code4 && code4 <= 113827) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (118528 <= code4 && code4 <= 118573) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 119141) {
                            if (118576 <= code4 && code4 <= 118598) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 119141) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (code4 === 119142) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 119173) {
                        if (code4 < 119150) {
                          if (code4 < 119149) {
                            if (119143 <= code4 && code4 <= 119145) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 === 119149) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code4 < 119155) {
                            if (119150 <= code4 && code4 <= 119154) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 119163) {
                              if (119155 <= code4 && code4 <= 119162) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (119163 <= code4 && code4 <= 119170) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 121344) {
                          if (code4 < 119210) {
                            if (119173 <= code4 && code4 <= 119179) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 119362) {
                              if (119210 <= code4 && code4 <= 119213) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (119362 <= code4 && code4 <= 119364) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 121403) {
                            if (121344 <= code4 && code4 <= 121398) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 121461) {
                              if (121403 <= code4 && code4 <= 121452) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 121461) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 123628) {
                      if (code4 < 122907) {
                        if (code4 < 121505) {
                          if (code4 < 121499) {
                            if (code4 === 121476) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (121499 <= code4 && code4 <= 121503) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 122880) {
                            if (121505 <= code4 && code4 <= 121519) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 122888) {
                              if (122880 <= code4 && code4 <= 122886) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (122888 <= code4 && code4 <= 122904) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 123023) {
                          if (code4 < 122915) {
                            if (122907 <= code4 && code4 <= 122913) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 122918) {
                              if (122915 <= code4 && code4 <= 122916) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (122918 <= code4 && code4 <= 122922) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 123184) {
                            if (code4 === 123023) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 123566) {
                              if (123184 <= code4 && code4 <= 123190) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 === 123566) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 127995) {
                        if (code4 < 125136) {
                          if (code4 < 124140) {
                            if (123628 <= code4 && code4 <= 123631) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (124140 <= code4 && code4 <= 124143) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code4 < 125252) {
                            if (125136 <= code4 && code4 <= 125142) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 127462) {
                              if (125252 <= code4 && code4 <= 125258) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (127462 <= code4 && code4 <= 127487) {
                                return boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 917632) {
                          if (code4 < 917504) {
                            if (127995 <= code4 && code4 <= 127999) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code4 < 917536) {
                              if (917504 <= code4 && code4 <= 917535) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (917536 <= code4 && code4 <= 917631) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code4 < 917760) {
                            if (917632 <= code4 && code4 <= 917759) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code4 < 918e3) {
                              if (917760 <= code4 && code4 <= 917999) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (918e3 <= code4 && code4 <= 921599) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return boundaries_1.CLUSTER_BREAK.OTHER;
      }
      static getEmojiProperty(code4) {
        if (code4 < 10160) {
          if (code4 < 9728) {
            if (code4 < 9e3) {
              if (code4 < 8482) {
                if (code4 < 8252) {
                  if (code4 === 169) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (code4 === 174) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code4 === 8252) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (code4 === 8265) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                }
              } else {
                if (code4 < 8596) {
                  if (code4 === 8482) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (code4 === 8505) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code4 < 8617) {
                    if (8596 <= code4 && code4 <= 8601) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 < 8986) {
                      if (8617 <= code4 && code4 <= 8618) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (8986 <= code4 && code4 <= 8987) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            } else {
              if (code4 < 9410) {
                if (code4 < 9167) {
                  if (code4 === 9e3) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (code4 === 9096) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code4 < 9193) {
                    if (code4 === 9167) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 < 9208) {
                      if (9193 <= code4 && code4 <= 9203) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (9208 <= code4 && code4 <= 9210) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code4 < 9654) {
                  if (code4 < 9642) {
                    if (code4 === 9410) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (9642 <= code4 && code4 <= 9643) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code4 < 9664) {
                    if (code4 === 9654) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 < 9723) {
                      if (code4 === 9664) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (9723 <= code4 && code4 <= 9726) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code4 < 10035) {
              if (code4 < 10004) {
                if (code4 < 9748) {
                  if (code4 < 9735) {
                    if (9728 <= code4 && code4 <= 9733) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (9735 <= code4 && code4 <= 9746) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code4 < 9872) {
                    if (9748 <= code4 && code4 <= 9861) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 < 9992) {
                      if (9872 <= code4 && code4 <= 9989) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (9992 <= code4 && code4 <= 10002) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code4 < 10013) {
                  if (code4 === 10004) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (code4 === 10006) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code4 < 10017) {
                    if (code4 === 10013) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 === 10017) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                    if (code4 === 10024) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              }
            } else {
              if (code4 < 10067) {
                if (code4 < 10055) {
                  if (code4 < 10052) {
                    if (10035 <= code4 && code4 <= 10036) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 === 10052) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code4 < 10060) {
                    if (code4 === 10055) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 === 10060) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                    if (code4 === 10062) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              } else {
                if (code4 < 10083) {
                  if (code4 < 10071) {
                    if (10067 <= code4 && code4 <= 10069) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 === 10071) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code4 < 10133) {
                    if (10083 <= code4 && code4 <= 10087) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 < 10145) {
                      if (10133 <= code4 && code4 <= 10135) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (code4 === 10145) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (code4 < 127489) {
            if (code4 < 12951) {
              if (code4 < 11035) {
                if (code4 < 10548) {
                  if (code4 === 10160) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (code4 === 10175) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code4 < 11013) {
                    if (10548 <= code4 && code4 <= 10549) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (11013 <= code4 && code4 <= 11015) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              } else {
                if (code4 < 11093) {
                  if (code4 < 11088) {
                    if (11035 <= code4 && code4 <= 11036) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 === 11088) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code4 < 12336) {
                    if (code4 === 11093) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 === 12336) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                    if (code4 === 12349) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              }
            } else {
              if (code4 < 127340) {
                if (code4 < 126976) {
                  if (code4 === 12951) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (code4 === 12953) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code4 < 127245) {
                    if (126976 <= code4 && code4 <= 127231) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 < 127279) {
                      if (127245 <= code4 && code4 <= 127247) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (code4 === 127279) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code4 < 127374) {
                  if (code4 < 127358) {
                    if (127340 <= code4 && code4 <= 127345) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (127358 <= code4 && code4 <= 127359) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code4 < 127377) {
                    if (code4 === 127374) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 < 127405) {
                      if (127377 <= code4 && code4 <= 127386) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (127405 <= code4 && code4 <= 127461) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code4 < 128981) {
              if (code4 < 127561) {
                if (code4 < 127535) {
                  if (code4 < 127514) {
                    if (127489 <= code4 && code4 <= 127503) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 === 127514) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code4 < 127538) {
                    if (code4 === 127535) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 < 127548) {
                      if (127538 <= code4 && code4 <= 127546) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (127548 <= code4 && code4 <= 127551) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code4 < 128326) {
                  if (code4 < 128e3) {
                    if (127561 <= code4 && code4 <= 127994) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (128e3 <= code4 && code4 <= 128317) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code4 < 128640) {
                    if (128326 <= code4 && code4 <= 128591) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 < 128884) {
                      if (128640 <= code4 && code4 <= 128767) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (128884 <= code4 && code4 <= 128895) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            } else {
              if (code4 < 129198) {
                if (code4 < 129096) {
                  if (code4 < 129036) {
                    if (128981 <= code4 && code4 <= 129023) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (129036 <= code4 && code4 <= 129039) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code4 < 129114) {
                    if (129096 <= code4 && code4 <= 129103) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 < 129160) {
                      if (129114 <= code4 && code4 <= 129119) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (129160 <= code4 && code4 <= 129167) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code4 < 129340) {
                  if (code4 < 129292) {
                    if (129198 <= code4 && code4 <= 129279) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (129292 <= code4 && code4 <= 129338) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code4 < 129351) {
                    if (129340 <= code4 && code4 <= 129349) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code4 < 130048) {
                      if (129351 <= code4 && code4 <= 129791) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (130048 <= code4 && code4 <= 131069) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return boundaries_1.CLUSTER_BREAK.OTHER;
      }
    };
    exports.default = Graphemer2;
  }
});

// ../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/graphemer@1.4.0/node_modules/graphemer/lib/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var Graphemer_1 = __importDefault(require_Graphemer());
    exports.default = Graphemer_1.default;
  }
});

// ../../node_modules/.pnpm/iso-datestring-validator@2.2.2/node_modules/iso-datestring-validator/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/iso-datestring-validator@2.2.2/node_modules/iso-datestring-validator/dist/index.js"(exports) {
    (() => {
      "use strict";
      var e = { d: (t2, r2) => {
        for (var n2 in r2)
          e.o(r2, n2) && !e.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: r2[n2] });
      }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      } }, t = {};
      function r(e2, t2) {
        return t2 === void 0 && (t2 = "-"), new RegExp("^(?!0{4}" + t2 + "0{2}" + t2 + "0{2})((?=[0-9]{4}" + t2 + "(((0[^2])|1[0-2])|02(?=" + t2 + "(([0-1][0-9])|2[0-8])))" + t2 + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + t2 + "02" + t2 + "29))([0-9]{4})" + t2 + "(?!((0[469])|11)" + t2 + "31)((0[1,3-9]|1[0-2])|(02(?!" + t2 + "3)))" + t2 + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(e2);
      }
      function n(e2) {
        var t2 = /\D/.exec(e2);
        return t2 ? t2[0] : "";
      }
      function i(e2, t2, r2) {
        t2 === void 0 && (t2 = ":"), r2 === void 0 && (r2 = false);
        var i2 = new RegExp("^([0-1]|2(?=([0-3])|4" + t2 + "00))[0-9]" + t2 + "[0-5][0-9](" + t2 + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
        if (!r2 || !/[Z+\-]/.test(e2))
          return i2.test(e2);
        if (/Z$/.test(e2))
          return i2.test(e2.replace("Z", ""));
        var o2 = e2.includes("+"), a2 = e2.split(/[+-]/), u2 = a2[0], d2 = a2[1];
        return i2.test(u2) && function(e3, t3, r3) {
          return r3 === void 0 && (r3 = ":"), new RegExp(t3 ? "^(0(?!(2" + r3 + "4)|0" + r3 + "3)|1(?=([0-1]|2(?=" + r3 + "[04])|[34](?=" + r3 + "0))))([03469](?=" + r3 + "[03])|[17](?=" + r3 + "0)|2(?=" + r3 + "[04])|5(?=" + r3 + "[034])|8(?=" + r3 + "[04]))" + r3 + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + r3 + "[03])|[0-24-8](?=" + r3 + "00))" + r3 + "[03]0$").test(e3);
        }(d2, o2, n(d2));
      }
      function o(e2) {
        var t2 = e2.split("T"), o2 = t2[0], a2 = t2[1], u2 = r(o2, n(o2));
        if (!a2)
          return false;
        var d2, s = (d2 = a2.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(d2) ? d2[0] : "");
        return u2 && i(a2, s, true);
      }
      function a(e2, t2) {
        return t2 === void 0 && (t2 = "-"), new RegExp("^[0-9]{4}" + t2 + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(e2);
      }
      e.r(t), e.d(t, { isValidDate: () => r, isValidISODateString: () => o, isValidTime: () => i, isValidYearMonth: () => a });
      var u = exports;
      for (var d in t)
        u[d] = t[d];
      t.__esModule && Object.defineProperty(u, "__esModule", { value: true });
    })();
  }
});

// ../../node_modules/.pnpm/detect-libc@2.0.2/node_modules/detect-libc/lib/process.js
var require_process = __commonJS({
  "../../node_modules/.pnpm/detect-libc@2.0.2/node_modules/detect-libc/lib/process.js"(exports, module2) {
    "use strict";
    var isLinux = () => process.platform === "linux";
    var report = null;
    var getReport = () => {
      if (!report) {
        report = isLinux() && process.report ? process.report.getReport() : {};
      }
      return report;
    };
    module2.exports = { isLinux, getReport };
  }
});

// ../../node_modules/.pnpm/detect-libc@2.0.2/node_modules/detect-libc/lib/filesystem.js
var require_filesystem = __commonJS({
  "../../node_modules/.pnpm/detect-libc@2.0.2/node_modules/detect-libc/lib/filesystem.js"(exports, module2) {
    "use strict";
    var fs3 = require("fs");
    var LDD_PATH = "/usr/bin/ldd";
    var readFileSync = (path) => fs3.readFileSync(path, "utf-8");
    var readFile = (path) => new Promise((resolve, reject) => {
      fs3.readFile(path, "utf-8", (err, data) => {
        if (err) {
          reject(err);
        } else {
          resolve(data);
        }
      });
    });
    module2.exports = {
      LDD_PATH,
      readFileSync,
      readFile
    };
  }
});

// ../../node_modules/.pnpm/detect-libc@2.0.2/node_modules/detect-libc/lib/detect-libc.js
var require_detect_libc = __commonJS({
  "../../node_modules/.pnpm/detect-libc@2.0.2/node_modules/detect-libc/lib/detect-libc.js"(exports, module2) {
    "use strict";
    var childProcess = require("child_process");
    var { isLinux, getReport } = require_process();
    var { LDD_PATH, readFile, readFileSync } = require_filesystem();
    var cachedFamilyFilesystem;
    var cachedVersionFilesystem;
    var command = "getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true";
    var commandOut = "";
    var safeCommand = () => {
      if (!commandOut) {
        return new Promise((resolve) => {
          childProcess.exec(command, (err, out) => {
            commandOut = err ? " " : out;
            resolve(commandOut);
          });
        });
      }
      return commandOut;
    };
    var safeCommandSync = () => {
      if (!commandOut) {
        try {
          commandOut = childProcess.execSync(command, { encoding: "utf8" });
        } catch (_err) {
          commandOut = " ";
        }
      }
      return commandOut;
    };
    var GLIBC = "glibc";
    var RE_GLIBC_VERSION = /GLIBC\s(\d+\.\d+)/;
    var MUSL = "musl";
    var GLIBC_ON_LDD = GLIBC.toUpperCase();
    var MUSL_ON_LDD = MUSL.toLowerCase();
    var isFileMusl = (f) => f.includes("libc.musl-") || f.includes("ld-musl-");
    var familyFromReport = () => {
      const report = getReport();
      if (report.header && report.header.glibcVersionRuntime) {
        return GLIBC;
      }
      if (Array.isArray(report.sharedObjects)) {
        if (report.sharedObjects.some(isFileMusl)) {
          return MUSL;
        }
      }
      return null;
    };
    var familyFromCommand = (out) => {
      const [getconf, ldd1] = out.split(/[\r\n]+/);
      if (getconf && getconf.includes(GLIBC)) {
        return GLIBC;
      }
      if (ldd1 && ldd1.includes(MUSL)) {
        return MUSL;
      }
      return null;
    };
    var getFamilyFromLddContent = (content) => {
      if (content.includes(MUSL_ON_LDD)) {
        return MUSL;
      }
      if (content.includes(GLIBC_ON_LDD)) {
        return GLIBC;
      }
      return null;
    };
    var familyFromFilesystem = async () => {
      if (cachedFamilyFilesystem !== void 0) {
        return cachedFamilyFilesystem;
      }
      cachedFamilyFilesystem = null;
      try {
        const lddContent = await readFile(LDD_PATH);
        cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
      } catch (e) {
      }
      return cachedFamilyFilesystem;
    };
    var familyFromFilesystemSync = () => {
      if (cachedFamilyFilesystem !== void 0) {
        return cachedFamilyFilesystem;
      }
      cachedFamilyFilesystem = null;
      try {
        const lddContent = readFileSync(LDD_PATH);
        cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
      } catch (e) {
      }
      return cachedFamilyFilesystem;
    };
    var family = async () => {
      let family2 = null;
      if (isLinux()) {
        family2 = await familyFromFilesystem();
        if (!family2) {
          family2 = familyFromReport();
        }
        if (!family2) {
          const out = await safeCommand();
          family2 = familyFromCommand(out);
        }
      }
      return family2;
    };
    var familySync = () => {
      let family2 = null;
      if (isLinux()) {
        family2 = familyFromFilesystemSync();
        if (!family2) {
          family2 = familyFromReport();
        }
        if (!family2) {
          const out = safeCommandSync();
          family2 = familyFromCommand(out);
        }
      }
      return family2;
    };
    var isNonGlibcLinux = async () => isLinux() && await family() !== GLIBC;
    var isNonGlibcLinuxSync = () => isLinux() && familySync() !== GLIBC;
    var versionFromFilesystem = async () => {
      if (cachedVersionFilesystem !== void 0) {
        return cachedVersionFilesystem;
      }
      cachedVersionFilesystem = null;
      try {
        const lddContent = await readFile(LDD_PATH);
        const versionMatch = lddContent.match(RE_GLIBC_VERSION);
        if (versionMatch) {
          cachedVersionFilesystem = versionMatch[1];
        }
      } catch (e) {
      }
      return cachedVersionFilesystem;
    };
    var versionFromFilesystemSync = () => {
      if (cachedVersionFilesystem !== void 0) {
        return cachedVersionFilesystem;
      }
      cachedVersionFilesystem = null;
      try {
        const lddContent = readFileSync(LDD_PATH);
        const versionMatch = lddContent.match(RE_GLIBC_VERSION);
        if (versionMatch) {
          cachedVersionFilesystem = versionMatch[1];
        }
      } catch (e) {
      }
      return cachedVersionFilesystem;
    };
    var versionFromReport = () => {
      const report = getReport();
      if (report.header && report.header.glibcVersionRuntime) {
        return report.header.glibcVersionRuntime;
      }
      return null;
    };
    var versionSuffix = (s) => s.trim().split(/\s+/)[1];
    var versionFromCommand = (out) => {
      const [getconf, ldd1, ldd2] = out.split(/[\r\n]+/);
      if (getconf && getconf.includes(GLIBC)) {
        return versionSuffix(getconf);
      }
      if (ldd1 && ldd2 && ldd1.includes(MUSL)) {
        return versionSuffix(ldd2);
      }
      return null;
    };
    var version2 = async () => {
      let version3 = null;
      if (isLinux()) {
        version3 = await versionFromFilesystem();
        if (!version3) {
          version3 = versionFromReport();
        }
        if (!version3) {
          const out = await safeCommand();
          version3 = versionFromCommand(out);
        }
      }
      return version3;
    };
    var versionSync = () => {
      let version3 = null;
      if (isLinux()) {
        version3 = versionFromFilesystemSync();
        if (!version3) {
          version3 = versionFromReport();
        }
        if (!version3) {
          const out = safeCommandSync();
          version3 = versionFromCommand(out);
        }
      }
      return version3;
    };
    module2.exports = {
      GLIBC,
      MUSL,
      family,
      familySync,
      isNonGlibcLinux,
      isNonGlibcLinuxSync,
      version: version2,
      versionSync
    };
  }
});

// ../../node_modules/.pnpm/node-gyp-build-optional-packages@5.1.1/node_modules/node-gyp-build-optional-packages/index.js
var require_node_gyp_build_optional_packages = __commonJS({
  "../../node_modules/.pnpm/node-gyp-build-optional-packages@5.1.1/node_modules/node-gyp-build-optional-packages/index.js"(exports, module2) {
    var fs3 = require("fs");
    var path = require("path");
    var url = require("url");
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var versions = process.versions;
    var abi = versions.modules;
    if (versions.deno || process.isBun) {
      abi = "unsupported";
    }
    var runtime = isElectron() ? "electron" : "node";
    var arch = process.arch;
    var platform = process.platform;
    var libc = process.env.LIBC || (isMusl(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
    var uv = (versions.uv || "").split(".")[0];
    module2.exports = load;
    function load(dir) {
      if (typeof __webpack_require__ === "function")
        return __non_webpack_require__(load.path(dir));
      else
        return require(load.path(dir));
    }
    load.path = function(dir) {
      dir = path.resolve(dir || ".");
      var packageName = "";
      try {
        if (typeof __webpack_require__ === "function")
          packageName = __non_webpack_require__(path.join(dir, "package.json")).name;
        else
          packageName = require(path.join(dir, "package.json")).name;
        var varName = packageName.toUpperCase().replace(/-/g, "_") + "_PREBUILD";
        if (process.env[varName])
          dir = process.env[varName];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path.join(dir, "build/Release"), matchBuild);
        if (release)
          return release;
        var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
        if (debug)
          return debug;
      }
      var prebuild = resolve(dir);
      if (prebuild)
        return prebuild;
      var nearby = resolve(path.dirname(process.execPath));
      if (nearby)
        return nearby;
      var platformPackage = (packageName[0] == "@" ? "" : "@" + packageName + "/") + packageName + "-" + platform + "-" + arch;
      try {
        var prebuildPackage = path.dirname(require("module").createRequire(url.pathToFileURL(path.join(dir, "package.json"))).resolve(platformPackage));
        return resolveFile(prebuildPackage);
      } catch (error) {
      }
      var target2 = [
        "platform=" + platform,
        "arch=" + arch,
        "runtime=" + runtime,
        "abi=" + abi,
        "uv=" + uv,
        armv ? "armv=" + armv : "",
        "libc=" + libc,
        "node=" + process.versions.node,
        process.versions.electron ? "electron=" + process.versions.electron : "",
        typeof __webpack_require__ === "function" ? "webpack=true" : ""
      ].filter(Boolean).join(" ");
      throw new Error("No native build was found for " + target2 + "\n    attempted loading from: " + dir + " and package: " + platformPackage + "\n");
      function resolve(dir2) {
        var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
        var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple)
          return;
        return resolveFile(path.join(dir2, "prebuilds", tuple.name));
      }
      function resolveFile(prebuilds) {
        var parsed = readdirSync(prebuilds).map(parseTags);
        var candidates = parsed.filter(matchTags(runtime, abi));
        var winner = candidates.sort(compareTags(runtime))[0];
        if (winner)
          return path.join(prebuilds, winner.file);
      }
    };
    function readdirSync(dir) {
      try {
        return fs3.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }
    function getFirst(dir, filter) {
      var files = readdirSync(dir).filter(filter);
      return files[0] && path.join(dir, files[0]);
    }
    function matchBuild(name3) {
      return /\.node$/.test(name3);
    }
    function parseTuple(name3) {
      var arr = name3.split("-");
      if (arr.length !== 2)
        return;
      var platform2 = arr[0];
      var architectures = arr[1].split("+");
      if (!platform2)
        return;
      if (!architectures.length)
        return;
      if (!architectures.every(Boolean))
        return;
      return { name: name3, platform: platform2, architectures };
    }
    function matchTuple(platform2, arch2) {
      return function(tuple) {
        if (tuple == null)
          return false;
        if (tuple.platform !== platform2)
          return false;
        return tuple.architectures.includes(arch2);
      };
    }
    function compareTuples(a, b) {
      return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
      var arr = file.split(".");
      var extension = arr.pop();
      var tags = { file, specificity: 0 };
      if (extension !== "node")
        return;
      for (var i = 0; i < arr.length; i++) {
        var tag = arr[i];
        if (tag === "node" || tag === "electron" || tag === "node-webkit") {
          tags.runtime = tag;
        } else if (tag === "napi") {
          tags.napi = true;
        } else if (tag.slice(0, 3) === "abi") {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === "uv") {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === "armv") {
          tags.armv = tag.slice(4);
        } else if (tag === "glibc" || tag === "musl") {
          tags.libc = tag;
        } else {
          continue;
        }
        tags.specificity++;
      }
      return tags;
    }
    function matchTags(runtime2, abi2) {
      return function(tags) {
        if (tags == null)
          return false;
        if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
          return false;
        if (tags.abi !== abi2 && !tags.napi)
          return false;
        if (tags.uv && tags.uv !== uv)
          return false;
        if (tags.armv && tags.armv !== armv)
          return false;
        if (tags.libc && tags.libc !== libc)
          return false;
        return true;
      };
    }
    function runtimeAgnostic(tags) {
      return tags.runtime === "node" && tags.napi;
    }
    function compareTags(runtime2) {
      return function(a, b) {
        if (a.runtime !== b.runtime) {
          return a.runtime === runtime2 ? -1 : 1;
        } else if (a.abi !== b.abi) {
          return a.abi ? -1 : 1;
        } else if (a.specificity !== b.specificity) {
          return a.specificity > b.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }
    function isElectron() {
      if (process.versions && process.versions.electron)
        return true;
      if (process.env.ELECTRON_RUN_AS_NODE)
        return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    function isMusl(platform2) {
      if (platform2 !== "linux")
        return false;
      const { familySync, MUSL } = require_detect_libc();
      return familySync() === MUSL;
    }
    load.parseTags = parseTags;
    load.matchTags = matchTags;
    load.compareTags = compareTags;
    load.parseTuple = parseTuple;
    load.matchTuple = matchTuple;
    load.compareTuples = compareTuples;
  }
});

// ../../node_modules/.pnpm/cbor-extract@2.2.0/node_modules/cbor-extract/index.js
var require_cbor_extract = __commonJS({
  "../../node_modules/.pnpm/cbor-extract@2.2.0/node_modules/cbor-extract/index.js"(exports, module2) {
    module2.exports = require_node_gyp_build_optional_packages()(__dirname);
  }
});

// ../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-helpers.js
var require_err_helpers = __commonJS({
  "../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-helpers.js"(exports, module2) {
    "use strict";
    var isErrorLike = (err) => {
      return err && typeof err.message === "string";
    };
    var getErrorCause = (err) => {
      if (!err)
        return;
      const cause = err.cause;
      if (typeof cause === "function") {
        const causeResult = err.cause();
        return isErrorLike(causeResult) ? causeResult : void 0;
      } else {
        return isErrorLike(cause) ? cause : void 0;
      }
    };
    var _stackWithCauses = (err, seen) => {
      if (!isErrorLike(err))
        return "";
      const stack = err.stack || "";
      if (seen.has(err)) {
        return stack + "\ncauses have become circular...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
      } else {
        return stack;
      }
    };
    var stackWithCauses = (err) => _stackWithCauses(err, /* @__PURE__ */ new Set());
    var _messageWithCauses = (err, seen, skip) => {
      if (!isErrorLike(err))
        return "";
      const message = skip ? "" : err.message || "";
      if (seen.has(err)) {
        return message + ": ...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        const skipIfVErrorStyleCause = typeof err.cause === "function";
        return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
      } else {
        return message;
      }
    };
    var messageWithCauses = (err) => _messageWithCauses(err, /* @__PURE__ */ new Set());
    module2.exports = {
      isErrorLike,
      getErrorCause,
      stackWithCauses,
      messageWithCauses
    };
  }
});

// ../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-proto.js
var require_err_proto = __commonJS({
  "../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-proto.js"(exports, module2) {
    "use strict";
    var seen = Symbol("circular-ref-tag");
    var rawSymbol = Symbol("pino-raw-err-ref");
    var pinoErrProto = Object.create({}, {
      type: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      message: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      stack: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      aggregateErrors: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoErrProto, rawSymbol, {
      writable: true,
      value: {}
    });
    module2.exports = {
      pinoErrProto,
      pinoErrorSymbols: {
        seen,
        rawSymbol
      }
    };
  }
});

// ../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err.js
var require_err = __commonJS({
  "../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err.js"(exports, module2) {
    "use strict";
    module2.exports = errSerializer;
    var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString: toString4 } = Object.prototype;
    function errSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString4.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = messageWithCauses(err);
      _err.stack = stackWithCauses(err);
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// ../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-with-cause.js
var require_err_with_cause = __commonJS({
  "../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/err-with-cause.js"(exports, module2) {
    "use strict";
    module2.exports = errWithCauseSerializer;
    var { isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString: toString4 } = Object.prototype;
    function errWithCauseSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString4.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = err.message;
      _err.stack = err.stack;
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
      }
      if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
        _err.cause = errWithCauseSerializer(err.cause);
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (!Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errWithCauseSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// ../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/req.js
var require_req = __commonJS({
  "../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/req.js"(exports, module2) {
    "use strict";
    module2.exports = {
      mapHttpRequest,
      reqSerializer
    };
    var rawSymbol = Symbol("pino-raw-req-ref");
    var pinoReqProto = Object.create({}, {
      id: {
        enumerable: true,
        writable: true,
        value: ""
      },
      method: {
        enumerable: true,
        writable: true,
        value: ""
      },
      url: {
        enumerable: true,
        writable: true,
        value: ""
      },
      query: {
        enumerable: true,
        writable: true,
        value: ""
      },
      params: {
        enumerable: true,
        writable: true,
        value: ""
      },
      headers: {
        enumerable: true,
        writable: true,
        value: {}
      },
      remoteAddress: {
        enumerable: true,
        writable: true,
        value: ""
      },
      remotePort: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoReqProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function reqSerializer(req) {
      const connection = req.info || req.socket;
      const _req = Object.create(pinoReqProto);
      _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : void 0);
      _req.method = req.method;
      if (req.originalUrl) {
        _req.url = req.originalUrl;
      } else {
        const path = req.path;
        _req.url = typeof path === "string" ? path : req.url ? req.url.path || req.url : void 0;
      }
      if (req.query) {
        _req.query = req.query;
      }
      if (req.params) {
        _req.params = req.params;
      }
      _req.headers = req.headers;
      _req.remoteAddress = connection && connection.remoteAddress;
      _req.remotePort = connection && connection.remotePort;
      _req.raw = req.raw || req;
      return _req;
    }
    function mapHttpRequest(req) {
      return {
        req: reqSerializer(req)
      };
    }
  }
});

// ../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/res.js
var require_res = __commonJS({
  "../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/lib/res.js"(exports, module2) {
    "use strict";
    module2.exports = {
      mapHttpResponse,
      resSerializer
    };
    var rawSymbol = Symbol("pino-raw-res-ref");
    var pinoResProto = Object.create({}, {
      statusCode: {
        enumerable: true,
        writable: true,
        value: 0
      },
      headers: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoResProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function resSerializer(res) {
      const _res = Object.create(pinoResProto);
      _res.statusCode = res.headersSent ? res.statusCode : null;
      _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
      _res.raw = res;
      return _res;
    }
    function mapHttpResponse(res) {
      return {
        res: resSerializer(res)
      };
    }
  }
});

// ../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/index.js
var require_pino_std_serializers = __commonJS({
  "../../node_modules/.pnpm/pino-std-serializers@6.2.2/node_modules/pino-std-serializers/index.js"(exports, module2) {
    "use strict";
    var errSerializer = require_err();
    var errWithCauseSerializer = require_err_with_cause();
    var reqSerializers = require_req();
    var resSerializers = require_res();
    module2.exports = {
      err: errSerializer,
      errWithCause: errWithCauseSerializer,
      mapHttpRequest: reqSerializers.mapHttpRequest,
      mapHttpResponse: resSerializers.mapHttpResponse,
      req: reqSerializers.reqSerializer,
      res: resSerializers.resSerializer,
      wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
        if (customSerializer === errSerializer)
          return customSerializer;
        return function wrapErrSerializer(err) {
          return customSerializer(errSerializer(err));
        };
      },
      wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
        if (customSerializer === reqSerializers.reqSerializer)
          return customSerializer;
        return function wrappedReqSerializer(req) {
          return customSerializer(reqSerializers.reqSerializer(req));
        };
      },
      wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
        if (customSerializer === resSerializers.resSerializer)
          return customSerializer;
        return function wrappedResSerializer(res) {
          return customSerializer(resSerializers.resSerializer(res));
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/caller.js
var require_caller = __commonJS({
  "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/caller.js"(exports, module2) {
    "use strict";
    function noOpPrepareStackTrace(_, stack) {
      return stack;
    }
    module2.exports = function getCallers() {
      const originalPrepare = Error.prepareStackTrace;
      Error.prepareStackTrace = noOpPrepareStackTrace;
      const stack = new Error().stack;
      Error.prepareStackTrace = originalPrepare;
      if (!Array.isArray(stack)) {
        return void 0;
      }
      const entries = stack.slice(2);
      const fileNames = [];
      for (const entry of entries) {
        if (!entry) {
          continue;
        }
        fileNames.push(entry.getFileName());
      }
      return fileNames;
    };
  }
});

// ../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/validator.js
var require_validator = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/validator.js"(exports, module2) {
    "use strict";
    module2.exports = validator;
    function validator(opts = {}) {
      const {
        ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
        ERR_INVALID_PATH = (s) => `fast-redact \u2013 Invalid path (${s})`
      } = opts;
      return function validate3({ paths }) {
        paths.forEach((s) => {
          if (typeof s !== "string") {
            throw Error(ERR_PATHS_MUST_BE_STRINGS());
          }
          try {
            if (/〇/.test(s))
              throw Error();
            const expr = (s[0] === "[" ? "" : ".") + s.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
            if (/\n|\r|;/.test(expr))
              throw Error();
            if (/\/\*/.test(expr))
              throw Error();
            Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const \u3007 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
          } catch (e) {
            throw Error(ERR_INVALID_PATH(s));
          }
        });
      };
    }
  }
});

// ../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/rx.js
var require_rx = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/rx.js"(exports, module2) {
    "use strict";
    module2.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
  }
});

// ../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/parse.js"(exports, module2) {
    "use strict";
    var rx = require_rx();
    module2.exports = parse;
    function parse({ paths }) {
      const wildcards = [];
      var wcLen = 0;
      const secret = paths.reduce(function(o, strPath, ix) {
        var path = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
        const leadingBracket = strPath[0] === "[";
        path = path.map((p) => {
          if (p[0] === "[")
            return p.substr(1, p.length - 2);
          else
            return p;
        });
        const star = path.indexOf("*");
        if (star > -1) {
          const before = path.slice(0, star);
          const beforeStr = before.join(".");
          const after = path.slice(star + 1, path.length);
          const nested = after.length > 0;
          wcLen++;
          wildcards.push({
            before,
            beforeStr,
            after,
            nested
          });
        } else {
          o[strPath] = {
            path,
            val: void 0,
            precensored: false,
            circle: "",
            escPath: JSON.stringify(strPath),
            leadingBracket
          };
        }
        return o;
      }, {});
      return { wildcards, wcLen, secret };
    }
  }
});

// ../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/redactor.js
var require_redactor = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/redactor.js"(exports, module2) {
    "use strict";
    var rx = require_rx();
    module2.exports = redactor;
    function redactor({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
      const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    ${resultTmpl(serialize)}
  `).bind(state);
      if (serialize === false) {
        redact.restore = (o) => state.restore(o);
      }
      return redact;
    }
    function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
      return Object.keys(secret).map((path) => {
        const { escPath, leadingBracket, path: arrPath } = secret[path];
        const skip = leadingBracket ? 1 : 0;
        const delim = leadingBracket ? "" : ".";
        const hops = [];
        var match;
        while ((match = rx.exec(path)) !== null) {
          const [, ix] = match;
          const { index, input } = match;
          if (index > skip)
            hops.push(input.substring(0, index - (ix ? 0 : 1)));
        }
        var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
        if (existence.length === 0)
          existence += `o${delim}${path} != null`;
        else
          existence += ` && o${delim}${path} != null`;
        const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
        const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
        return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
      }).join("\n");
    }
    function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
      return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
    }
    function resultTmpl(serialize) {
      return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
    }
    function strictImpl(strict, serialize) {
      return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize === false ? `return o` : `return this.serialize(o)`;
    }
  }
});

// ../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/modifiers.js
var require_modifiers = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/modifiers.js"(exports, module2) {
    "use strict";
    module2.exports = {
      groupRedact,
      groupRestore,
      nestedRedact,
      nestedRestore
    };
    function groupRestore({ keys, values, target: target2 }) {
      if (target2 == null)
        return;
      const length2 = keys.length;
      for (var i = 0; i < length2; i++) {
        const k = keys[i];
        target2[k] = values[i];
      }
    }
    function groupRedact(o, path, censor, isCensorFct, censorFctTakesPath) {
      const target2 = get2(o, path);
      if (target2 == null)
        return { keys: null, values: null, target: null, flat: true };
      const keys = Object.keys(target2);
      const keysLength = keys.length;
      const pathLength = path.length;
      const pathWithKey = censorFctTakesPath ? [...path] : void 0;
      const values = new Array(keysLength);
      for (var i = 0; i < keysLength; i++) {
        const key = keys[i];
        values[i] = target2[key];
        if (censorFctTakesPath) {
          pathWithKey[pathLength] = key;
          target2[key] = censor(target2[key], pathWithKey);
        } else if (isCensorFct) {
          target2[key] = censor(target2[key]);
        } else {
          target2[key] = censor;
        }
      }
      return { keys, values, target: target2, flat: true };
    }
    function nestedRestore(instructions) {
      for (let i = 0; i < instructions.length; i++) {
        const { target: target2, path, value } = instructions[i];
        let current = target2;
        for (let i2 = path.length - 1; i2 > 0; i2--) {
          current = current[path[i2]];
        }
        current[path[0]] = value;
      }
    }
    function nestedRedact(store, o, path, ns, censor, isCensorFct, censorFctTakesPath) {
      const target2 = get2(o, path);
      if (target2 == null)
        return;
      const keys = Object.keys(target2);
      const keysLength = keys.length;
      for (var i = 0; i < keysLength; i++) {
        const key = keys[i];
        specialSet(store, target2, key, path, ns, censor, isCensorFct, censorFctTakesPath);
      }
      return store;
    }
    function has(obj, prop) {
      return obj !== void 0 && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
    }
    function specialSet(store, o, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
      const afterPathLen = afterPath.length;
      const lastPathIndex = afterPathLen - 1;
      const originalKey = k;
      var i = -1;
      var n;
      var nv;
      var ov;
      var oov = null;
      var wc = null;
      var kIsWc;
      var wcov;
      var consecutive = false;
      var level2 = 0;
      var depth = 0;
      var redactPathCurrent = tree2();
      ov = n = o[k];
      if (typeof n !== "object")
        return;
      while (n != null && ++i < afterPathLen) {
        depth += 1;
        k = afterPath[i];
        oov = ov;
        if (k !== "*" && !wc && !(typeof n === "object" && k in n)) {
          break;
        }
        if (k === "*") {
          if (wc === "*") {
            consecutive = true;
          }
          wc = k;
          if (i !== lastPathIndex) {
            continue;
          }
        }
        if (wc) {
          const wcKeys = Object.keys(n);
          for (var j = 0; j < wcKeys.length; j++) {
            const wck = wcKeys[j];
            wcov = n[wck];
            kIsWc = k === "*";
            if (consecutive) {
              redactPathCurrent = node(redactPathCurrent, wck, depth);
              level2 = i;
              ov = iterateNthLevel(wcov, level2 - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, o[originalKey], depth + 1);
            } else {
              if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
                if (kIsWc) {
                  ov = wcov;
                } else {
                  ov = wcov[k];
                }
                nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
                if (kIsWc) {
                  const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o[originalKey]);
                  store.push(rv);
                  n[wck] = nv;
                } else {
                  if (wcov[k] === nv) {
                  } else if (nv === void 0 && censor !== void 0 || has(wcov, k) && nv === ov) {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                  } else {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                    const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o[originalKey]);
                    store.push(rv);
                    wcov[k] = nv;
                  }
                }
              }
            }
          }
          wc = null;
        } else {
          ov = n[k];
          redactPathCurrent = node(redactPathCurrent, k, depth);
          nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
          if (has(n, k) && nv === ov || nv === void 0 && censor !== void 0) {
          } else {
            const rv = restoreInstr(redactPathCurrent, ov, o[originalKey]);
            store.push(rv);
            n[k] = nv;
          }
          n = n[k];
        }
        if (typeof n !== "object")
          break;
        if (ov === oov || typeof ov === "undefined") {
        }
      }
    }
    function get2(o, p) {
      var i = -1;
      var l = p.length;
      var n = o;
      while (n != null && ++i < l) {
        n = n[p[i]];
      }
      return n;
    }
    function iterateNthLevel(wcov, level2, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth) {
      if (level2 === 0) {
        if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
          if (kIsWc) {
            ov = wcov;
          } else {
            ov = wcov[k];
          }
          nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
          if (kIsWc) {
            const rv = restoreInstr(redactPathCurrent, ov, parent);
            store.push(rv);
            n[wck] = nv;
          } else {
            if (wcov[k] === nv) {
            } else if (nv === void 0 && censor !== void 0 || has(wcov, k) && nv === ov) {
            } else {
              const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent);
              store.push(rv);
              wcov[k] = nv;
            }
          }
        }
      }
      for (const key in wcov) {
        if (typeof wcov[key] === "object") {
          redactPathCurrent = node(redactPathCurrent, key, depth);
          iterateNthLevel(wcov[key], level2 - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
        }
      }
    }
    function tree2() {
      return { parent: null, key: null, children: [], depth: 0 };
    }
    function node(parent, key, depth) {
      if (parent.depth === depth) {
        return node(parent.parent, key, depth);
      }
      var child = {
        parent,
        key,
        depth,
        children: []
      };
      parent.children.push(child);
      return child;
    }
    function restoreInstr(node2, value, target2) {
      let current = node2;
      const path = [];
      do {
        path.push(current.key);
        current = current.parent;
      } while (current.parent != null);
      return { path, value, target: target2 };
    }
  }
});

// ../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/restorer.js
var require_restorer = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/restorer.js"(exports, module2) {
    "use strict";
    var { groupRestore, nestedRestore } = require_modifiers();
    module2.exports = restorer;
    function restorer({ secret, wcLen }) {
      return function compileRestore() {
        if (this.restore)
          return;
        const paths = Object.keys(secret);
        const resetters = resetTmpl(secret, paths);
        const hasWildcards = wcLen > 0;
        const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
        this.restore = Function("o", restoreTmpl(resetters, paths, hasWildcards)).bind(state);
      };
    }
    function resetTmpl(secret, paths) {
      return paths.map((path) => {
        const { circle, escPath, leadingBracket } = secret[path];
        const delim = leadingBracket ? "" : ".";
        const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path} = secret[${escPath}].val`;
        const clear = `secret[${escPath}].val = undefined`;
        return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
      }).join("");
    }
    function restoreTmpl(resetters, paths, hasWildcards) {
      const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o.flat === true) this.groupRestore(o)
      else this.nestedRestore(o)
      secret[k] = null
    }
  ` : "";
      return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
    }
  }
});

// ../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/state.js
var require_state = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/lib/state.js"(exports, module2) {
    "use strict";
    module2.exports = state;
    function state(o) {
      const {
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      } = o;
      const builder = [{ secret, censor, compileRestore }];
      if (serialize !== false)
        builder.push({ serialize });
      if (wcLen > 0)
        builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
      return Object.assign(...builder);
    }
  }
});

// ../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/index.js
var require_fast_redact = __commonJS({
  "../../node_modules/.pnpm/fast-redact@3.3.0/node_modules/fast-redact/index.js"(exports, module2) {
    "use strict";
    var validator = require_validator();
    var parse = require_parse();
    var redactor = require_redactor();
    var restorer = require_restorer();
    var { groupRedact, nestedRedact } = require_modifiers();
    var state = require_state();
    var rx = require_rx();
    var validate3 = validator();
    var noop2 = (o) => o;
    noop2.restore = noop2;
    var DEFAULT_CENSOR = "[REDACTED]";
    fastRedact.rx = rx;
    fastRedact.validator = validator;
    module2.exports = fastRedact;
    function fastRedact(opts = {}) {
      const paths = Array.from(new Set(opts.paths || []));
      const serialize = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
      const remove = opts.remove;
      if (remove === true && serialize !== JSON.stringify) {
        throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
      }
      const censor = remove === true ? void 0 : "censor" in opts ? opts.censor : DEFAULT_CENSOR;
      const isCensorFct = typeof censor === "function";
      const censorFctTakesPath = isCensorFct && censor.length > 1;
      if (paths.length === 0)
        return serialize || noop2;
      validate3({ paths, serialize, censor });
      const { wildcards, wcLen, secret } = parse({ paths, censor });
      const compileRestore = restorer({ secret, wcLen });
      const strict = "strict" in opts ? opts.strict : true;
      return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      }));
    }
  }
});

// ../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/symbols.js
var require_symbols = __commonJS({
  "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/symbols.js"(exports, module2) {
    "use strict";
    var setLevelSym = Symbol("pino.setLevel");
    var getLevelSym = Symbol("pino.getLevel");
    var levelValSym = Symbol("pino.levelVal");
    var useLevelLabelsSym = Symbol("pino.useLevelLabels");
    var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
    var mixinSym = Symbol("pino.mixin");
    var lsCacheSym = Symbol("pino.lsCache");
    var chindingsSym = Symbol("pino.chindings");
    var asJsonSym = Symbol("pino.asJson");
    var writeSym = Symbol("pino.write");
    var redactFmtSym = Symbol("pino.redactFmt");
    var timeSym = Symbol("pino.time");
    var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
    var streamSym = Symbol("pino.stream");
    var stringifySym = Symbol("pino.stringify");
    var stringifySafeSym = Symbol("pino.stringifySafe");
    var stringifiersSym = Symbol("pino.stringifiers");
    var endSym = Symbol("pino.end");
    var formatOptsSym = Symbol("pino.formatOpts");
    var messageKeySym = Symbol("pino.messageKey");
    var errorKeySym = Symbol("pino.errorKey");
    var nestedKeySym = Symbol("pino.nestedKey");
    var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
    var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
    var msgPrefixSym = Symbol("pino.msgPrefix");
    var wildcardFirstSym = Symbol("pino.wildcardFirst");
    var serializersSym = Symbol.for("pino.serializers");
    var formattersSym = Symbol.for("pino.formatters");
    var hooksSym = Symbol.for("pino.hooks");
    var needsMetadataGsym = Symbol.for("pino.metadata");
    module2.exports = {
      setLevelSym,
      getLevelSym,
      levelValSym,
      useLevelLabelsSym,
      mixinSym,
      lsCacheSym,
      chindingsSym,
      asJsonSym,
      writeSym,
      serializersSym,
      redactFmtSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      wildcardFirstSym,
      needsMetadataGsym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    };
  }
});

// ../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/redaction.js
var require_redaction = __commonJS({
  "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/redaction.js"(exports, module2) {
    "use strict";
    var fastRedact = require_fast_redact();
    var { redactFmtSym, wildcardFirstSym } = require_symbols();
    var { rx, validator } = fastRedact;
    var validate3 = validator({
      ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
      ERR_INVALID_PATH: (s) => `pino \u2013 redact paths array contains an invalid path (${s})`
    });
    var CENSOR = "[Redacted]";
    var strict = false;
    function redaction(opts, serialize) {
      const { paths, censor } = handle2(opts);
      const shape = paths.reduce((o, str) => {
        rx.lastIndex = 0;
        const first = rx.exec(str);
        const next = rx.exec(str);
        let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
        if (ns === "*") {
          ns = wildcardFirstSym;
        }
        if (next === null) {
          o[ns] = null;
          return o;
        }
        if (o[ns] === null) {
          return o;
        }
        const { index } = next;
        const nextPath = `${str.substr(index, str.length - 1)}`;
        o[ns] = o[ns] || [];
        if (ns !== wildcardFirstSym && o[ns].length === 0) {
          o[ns].push(...o[wildcardFirstSym] || []);
        }
        if (ns === wildcardFirstSym) {
          Object.keys(o).forEach(function(k) {
            if (o[k]) {
              o[k].push(nextPath);
            }
          });
        }
        o[ns].push(nextPath);
        return o;
      }, {});
      const result = {
        [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
      };
      const topCensor = (...args) => {
        return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
      };
      return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
        if (shape[k] === null) {
          o[k] = (value) => topCensor(value, [k]);
        } else {
          const wrappedCensor = typeof censor === "function" ? (value, path) => {
            return censor(value, [k, ...path]);
          } : censor;
          o[k] = fastRedact({
            paths: shape[k],
            censor: wrappedCensor,
            serialize,
            strict
          });
        }
        return o;
      }, result);
    }
    function handle2(opts) {
      if (Array.isArray(opts)) {
        opts = { paths: opts, censor: CENSOR };
        validate3(opts);
        return opts;
      }
      let { paths, censor = CENSOR, remove } = opts;
      if (Array.isArray(paths) === false) {
        throw Error("pino \u2013 redact must contain an array of strings");
      }
      if (remove === true)
        censor = void 0;
      validate3({ paths, censor });
      return { paths, censor };
    }
    module2.exports = redaction;
  }
});

// ../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/time.js
var require_time = __commonJS({
  "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/time.js"(exports, module2) {
    "use strict";
    var nullTime = () => "";
    var epochTime = () => `,"time":${Date.now()}`;
    var unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
    var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
    module2.exports = { nullTime, epochTime, unixTime, isoTime };
  }
});

// ../../node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "../../node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js"(exports, module2) {
    "use strict";
    function tryStringify(o) {
      try {
        return JSON.stringify(o);
      } catch (e) {
        return '"[Circular]"';
      }
    }
    module2.exports = format;
    function format(f, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f === "object" && f !== null) {
        var len = args.length + offset;
        if (len === 1)
          return f;
        var objects = new Array(len);
        objects[0] = ss(f);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f !== "string") {
        return f;
      }
      var argLen = args.length;
      if (argLen === 0)
        return f;
      var str = "";
      var a = 1 - offset;
      var lastPos = -1;
      var flen = f && f.length || 0;
      for (var i = 0; i < flen; ) {
        if (f.charCodeAt(i) === 37 && i + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f.charCodeAt(i + 1)) {
            case 100:
            case 102:
              if (a >= argLen)
                break;
              if (args[a] == null)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Number(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 105:
              if (a >= argLen)
                break;
              if (args[a] == null)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Math.floor(Number(args[a]));
              lastPos = i + 2;
              i++;
              break;
            case 79:
            case 111:
            case 106:
              if (a >= argLen)
                break;
              if (args[a] === void 0)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              var type = typeof args[a];
              if (type === "string") {
                str += "'" + args[a] + "'";
                lastPos = i + 2;
                i++;
                break;
              }
              if (type === "function") {
                str += args[a].name || "<anonymous>";
                lastPos = i + 2;
                i++;
                break;
              }
              str += ss(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 115:
              if (a >= argLen)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += String(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 37:
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += "%";
              lastPos = i + 2;
              i++;
              a--;
              break;
          }
          ++a;
        }
        ++i;
      }
      if (lastPos === -1)
        return f;
      else if (lastPos < flen) {
        str += f.slice(lastPos);
      }
      return str;
    }
  }
});

// ../../node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js
var require_atomic_sleep = __commonJS({
  "../../node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js"(exports, module2) {
    "use strict";
    if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        Atomics.wait(nil, 0, 0, Number(ms));
      };
      const nil = new Int32Array(new SharedArrayBuffer(4));
      module2.exports = sleep;
    } else {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        const target2 = Date.now() + Number(ms);
        while (target2 > Date.now()) {
        }
      };
      module2.exports = sleep;
    }
  }
});

// ../../node_modules/.pnpm/sonic-boom@3.3.0/node_modules/sonic-boom/index.js
var require_sonic_boom = __commonJS({
  "../../node_modules/.pnpm/sonic-boom@3.3.0/node_modules/sonic-boom/index.js"(exports, module2) {
    "use strict";
    var fs3 = require("fs");
    var EventEmitter = require("events");
    var inherits = require("util").inherits;
    var path = require("path");
    var sleep = require_atomic_sleep();
    var BUSY_WRITE_TIMEOUT = 100;
    var MAX_WRITE = 16 * 1024;
    function openFile(file, sonic) {
      sonic._opening = true;
      sonic._writing = true;
      sonic._asyncDrainScheduled = false;
      function fileOpened(err, fd) {
        if (err) {
          sonic._reopening = false;
          sonic._writing = false;
          sonic._opening = false;
          if (sonic.sync) {
            process.nextTick(() => {
              if (sonic.listenerCount("error") > 0) {
                sonic.emit("error", err);
              }
            });
          } else {
            sonic.emit("error", err);
          }
          return;
        }
        sonic.fd = fd;
        sonic.file = file;
        sonic._reopening = false;
        sonic._opening = false;
        sonic._writing = false;
        if (sonic.sync) {
          process.nextTick(() => sonic.emit("ready"));
        } else {
          sonic.emit("ready");
        }
        if (sonic._reopening) {
          return;
        }
        if (!sonic._writing && sonic._len > sonic.minLength && !sonic.destroyed) {
          actualWrite(sonic);
        }
      }
      const flags = sonic.append ? "a" : "w";
      const mode = sonic.mode;
      if (sonic.sync) {
        try {
          if (sonic.mkdir)
            fs3.mkdirSync(path.dirname(file), { recursive: true });
          const fd = fs3.openSync(file, flags, mode);
          fileOpened(null, fd);
        } catch (err) {
          fileOpened(err);
          throw err;
        }
      } else if (sonic.mkdir) {
        fs3.mkdir(path.dirname(file), { recursive: true }, (err) => {
          if (err)
            return fileOpened(err);
          fs3.open(file, flags, mode, fileOpened);
        });
      } else {
        fs3.open(file, flags, mode, fileOpened);
      }
    }
    function SonicBoom(opts) {
      if (!(this instanceof SonicBoom)) {
        return new SonicBoom(opts);
      }
      let { fd, dest, minLength, maxLength, maxWrite, sync, append = true, mode, mkdir, retryEAGAIN, fsync } = opts || {};
      fd = fd || dest;
      this._bufs = [];
      this._len = 0;
      this.fd = -1;
      this._writing = false;
      this._writingBuf = "";
      this._ending = false;
      this._reopening = false;
      this._asyncDrainScheduled = false;
      this._hwm = Math.max(minLength || 0, 16387);
      this.file = null;
      this.destroyed = false;
      this.minLength = minLength || 0;
      this.maxLength = maxLength || 0;
      this.maxWrite = maxWrite || MAX_WRITE;
      this.sync = sync || false;
      this._fsync = fsync || false;
      this.append = append || false;
      this.mode = mode;
      this.retryEAGAIN = retryEAGAIN || (() => true);
      this.mkdir = mkdir || false;
      if (typeof fd === "number") {
        this.fd = fd;
        process.nextTick(() => this.emit("ready"));
      } else if (typeof fd === "string") {
        openFile(fd, this);
      } else {
        throw new Error("SonicBoom supports only file descriptors and files");
      }
      if (this.minLength >= this.maxWrite) {
        throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
      }
      this.release = (err, n) => {
        if (err) {
          if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
            if (this.sync) {
              try {
                sleep(BUSY_WRITE_TIMEOUT);
                this.release(void 0, 0);
              } catch (err2) {
                this.release(err2);
              }
            } else {
              setTimeout(() => {
                fs3.write(this.fd, this._writingBuf, "utf8", this.release);
              }, BUSY_WRITE_TIMEOUT);
            }
          } else {
            this._writing = false;
            this.emit("error", err);
          }
          return;
        }
        this.emit("write", n);
        this._len -= n;
        if (this._len < 0) {
          this._len = 0;
        }
        this._writingBuf = this._writingBuf.slice(n);
        if (this._writingBuf.length) {
          if (!this.sync) {
            fs3.write(this.fd, this._writingBuf, "utf8", this.release);
            return;
          }
          try {
            do {
              const n2 = fs3.writeSync(this.fd, this._writingBuf, "utf8");
              this._len -= n2;
              this._writingBuf = this._writingBuf.slice(n2);
            } while (this._writingBuf);
          } catch (err2) {
            this.release(err2);
            return;
          }
        }
        if (this._fsync) {
          fs3.fsyncSync(this.fd);
        }
        const len = this._len;
        if (this._reopening) {
          this._writing = false;
          this._reopening = false;
          this.reopen();
        } else if (len > this.minLength) {
          actualWrite(this);
        } else if (this._ending) {
          if (len > 0) {
            actualWrite(this);
          } else {
            this._writing = false;
            actualClose(this);
          }
        } else {
          this._writing = false;
          if (this.sync) {
            if (!this._asyncDrainScheduled) {
              this._asyncDrainScheduled = true;
              process.nextTick(emitDrain, this);
            }
          } else {
            this.emit("drain");
          }
        }
      };
      this.on("newListener", function(name3) {
        if (name3 === "drain") {
          this._asyncDrainScheduled = false;
        }
      });
    }
    function emitDrain(sonic) {
      const hasListeners = sonic.listenerCount("drain") > 0;
      if (!hasListeners)
        return;
      sonic._asyncDrainScheduled = false;
      sonic.emit("drain");
    }
    inherits(SonicBoom, EventEmitter);
    SonicBoom.prototype.write = function(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
        bufs.push("" + data);
      } else {
        bufs[bufs.length - 1] += data;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        actualWrite(this);
      }
      return this._len < this._hwm;
    };
    SonicBoom.prototype.flush = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._writing || this.minLength <= 0) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push("");
      }
      actualWrite(this);
    };
    SonicBoom.prototype.reopen = function(file) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.reopen(file);
        });
        return;
      }
      if (this._ending) {
        return;
      }
      if (!this.file) {
        throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
      }
      this._reopening = true;
      if (this._writing) {
        return;
      }
      const fd = this.fd;
      this.once("ready", () => {
        if (fd !== this.fd) {
          fs3.close(fd, (err) => {
            if (err) {
              return this.emit("error", err);
            }
          });
        }
      });
      openFile(file || this.file, this);
    };
    SonicBoom.prototype.end = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.end();
        });
        return;
      }
      if (this._ending) {
        return;
      }
      this._ending = true;
      if (this._writing) {
        return;
      }
      if (this._len > 0 && this.fd >= 0) {
        actualWrite(this);
      } else {
        actualClose(this);
      }
    };
    SonicBoom.prototype.flushSync = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift(this._writingBuf);
        this._writingBuf = "";
      }
      let buf2 = "";
      while (this._bufs.length || buf2.length) {
        if (buf2.length <= 0) {
          buf2 = this._bufs[0];
        }
        try {
          const n = fs3.writeSync(this.fd, buf2, "utf8");
          buf2 = buf2.slice(n);
          this._len = Math.max(this._len - n, 0);
          if (buf2.length <= 0) {
            this._bufs.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf2.length, this._len - buf2.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
    };
    SonicBoom.prototype.destroy = function() {
      if (this.destroyed) {
        return;
      }
      actualClose(this);
    };
    function actualWrite(sonic) {
      const release = sonic.release;
      sonic._writing = true;
      sonic._writingBuf = sonic._writingBuf || sonic._bufs.shift() || "";
      if (sonic.sync) {
        try {
          const written = fs3.writeSync(sonic.fd, sonic._writingBuf, "utf8");
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs3.write(sonic.fd, sonic._writingBuf, "utf8", release);
      }
    }
    function actualClose(sonic) {
      if (sonic.fd === -1) {
        sonic.once("ready", actualClose.bind(null, sonic));
        return;
      }
      sonic.destroyed = true;
      sonic._bufs = [];
      if (sonic.fd !== 1 && sonic.fd !== 2) {
        fs3.close(sonic.fd, done);
      } else {
        setImmediate(done);
      }
      function done(err) {
        if (err) {
          sonic.emit("error", err);
          return;
        }
        if (sonic._ending && !sonic._writing) {
          sonic.emit("finish");
        }
        sonic.emit("close");
      }
    }
    SonicBoom.SonicBoom = SonicBoom;
    SonicBoom.default = SonicBoom;
    module2.exports = SonicBoom;
  }
});

// ../../node_modules/.pnpm/on-exit-leak-free@2.1.0/node_modules/on-exit-leak-free/index.js
var require_on_exit_leak_free = __commonJS({
  "../../node_modules/.pnpm/on-exit-leak-free@2.1.0/node_modules/on-exit-leak-free/index.js"(exports, module2) {
    "use strict";
    var refs = {
      exit: [],
      beforeExit: []
    };
    var functions = {
      exit: onExit,
      beforeExit: onBeforeExit
    };
    var registry = new FinalizationRegistry(clear);
    function install(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.on(event, functions[event]);
    }
    function uninstall(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.removeListener(event, functions[event]);
    }
    function onExit() {
      callRefs("exit");
    }
    function onBeforeExit() {
      callRefs("beforeExit");
    }
    function callRefs(event) {
      for (const ref of refs[event]) {
        const obj = ref.deref();
        const fn = ref.fn;
        if (obj !== void 0) {
          fn(obj, event);
        }
      }
    }
    function clear(ref) {
      for (const event of ["exit", "beforeExit"]) {
        const index = refs[event].indexOf(ref);
        refs[event].splice(index, index + 1);
        uninstall(event);
      }
    }
    function _register(event, obj, fn) {
      if (obj === void 0) {
        throw new Error("the object can't be undefined");
      }
      install(event);
      const ref = new WeakRef(obj);
      ref.fn = fn;
      registry.register(obj, ref);
      refs[event].push(ref);
    }
    function register(obj, fn) {
      _register("exit", obj, fn);
    }
    function registerBeforeExit(obj, fn) {
      _register("beforeExit", obj, fn);
    }
    function unregister(obj) {
      registry.unregister(obj);
      for (const event of ["exit", "beforeExit"]) {
        refs[event] = refs[event].filter((ref) => {
          const _obj = ref.deref();
          return _obj && _obj !== obj;
        });
        uninstall(event);
      }
    }
    module2.exports = {
      register,
      registerBeforeExit,
      unregister
    };
  }
});

// ../../node_modules/.pnpm/thread-stream@2.4.0/node_modules/thread-stream/package.json
var require_package = __commonJS({
  "../../node_modules/.pnpm/thread-stream@2.4.0/node_modules/thread-stream/package.json"(exports, module2) {
    module2.exports = {
      name: "thread-stream",
      version: "2.4.0",
      description: "A streaming way to send data to a Node.js Worker Thread",
      main: "index.js",
      types: "index.d.ts",
      dependencies: {
        "real-require": "^0.2.0"
      },
      devDependencies: {
        "@types/node": "^20.1.0",
        "@types/tap": "^15.0.0",
        desm: "^1.3.0",
        fastbench: "^1.0.1",
        husky: "^8.0.1",
        "pino-elasticsearch": "^6.0.0",
        "sonic-boom": "^3.0.0",
        standard: "^17.0.0",
        tap: "^16.2.0",
        "ts-node": "^10.8.0",
        typescript: "^4.7.2",
        "why-is-node-running": "^2.2.2"
      },
      scripts: {
        test: "standard && npm run transpile && tap test/*.test.*js && tap --ts test/*.test.*ts",
        "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
        "test:ci:js": 'tap --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*js"',
        "test:ci:ts": 'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
        "test:yarn": 'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
        transpile: "sh ./test/ts/transpile.sh",
        prepare: "husky install"
      },
      standard: {
        ignore: [
          "test/ts/**/*"
        ]
      },
      repository: {
        type: "git",
        url: "git+https://github.com/mcollina/thread-stream.git"
      },
      keywords: [
        "worker",
        "thread",
        "threads",
        "stream"
      ],
      author: "Matteo Collina <hello@matteocollina.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/mcollina/thread-stream/issues"
      },
      homepage: "https://github.com/mcollina/thread-stream#readme"
    };
  }
});

// ../../node_modules/.pnpm/thread-stream@2.4.0/node_modules/thread-stream/lib/wait.js
var require_wait = __commonJS({
  "../../node_modules/.pnpm/thread-stream@2.4.0/node_modules/thread-stream/lib/wait.js"(exports, module2) {
    "use strict";
    var MAX_TIMEOUT = 1e3;
    function wait2(state, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index);
      if (current === expected) {
        done(null, "ok");
        return;
      }
      let prior = current;
      const check2 = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            prior = current;
            current = Atomics.load(state, index);
            if (current === prior) {
              check2(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            } else {
              if (current === expected)
                done(null, "ok");
              else
                done(null, "not-equal");
            }
          }, backoff);
        }
      };
      check2(1);
    }
    function waitDiff(state, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index);
      if (current !== expected) {
        done(null, "ok");
        return;
      }
      const check2 = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            current = Atomics.load(state, index);
            if (current !== expected) {
              done(null, "ok");
            } else {
              check2(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            }
          }, backoff);
        }
      };
      check2(1);
    }
    module2.exports = { wait: wait2, waitDiff };
  }
});

// ../../node_modules/.pnpm/thread-stream@2.4.0/node_modules/thread-stream/lib/indexes.js
var require_indexes = __commonJS({
  "../../node_modules/.pnpm/thread-stream@2.4.0/node_modules/thread-stream/lib/indexes.js"(exports, module2) {
    "use strict";
    var WRITE_INDEX = 4;
    var READ_INDEX = 8;
    module2.exports = {
      WRITE_INDEX,
      READ_INDEX
    };
  }
});

// ../../node_modules/.pnpm/thread-stream@2.4.0/node_modules/thread-stream/index.js
var require_thread_stream = __commonJS({
  "../../node_modules/.pnpm/thread-stream@2.4.0/node_modules/thread-stream/index.js"(exports, module2) {
    "use strict";
    var { version: version2 } = require_package();
    var { EventEmitter } = require("events");
    var { Worker } = require("worker_threads");
    var { join } = require("path");
    var { pathToFileURL } = require("url");
    var { wait: wait2 } = require_wait();
    var {
      WRITE_INDEX,
      READ_INDEX
    } = require_indexes();
    var buffer2 = require("buffer");
    var assert2 = require("assert");
    var kImpl = Symbol("kImpl");
    var MAX_STRING = buffer2.constants.MAX_STRING_LENGTH;
    var FakeWeakRef = class {
      constructor(value) {
        this._value = value;
      }
      deref() {
        return this._value;
      }
    };
    var FinalizationRegistry2 = global.FinalizationRegistry || class FakeFinalizationRegistry {
      register() {
      }
      unregister() {
      }
    };
    var WeakRef2 = global.WeakRef || FakeWeakRef;
    var registry = new FinalizationRegistry2((worker) => {
      if (worker.exited) {
        return;
      }
      worker.terminate();
    });
    function createWorker(stream, opts) {
      const { filename, workerData } = opts;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      const toExecute = bundlerOverrides["thread-stream-worker"] || join(__dirname, "lib", "worker.js");
      const worker = new Worker(toExecute, {
        ...opts.workerOpts,
        trackUnmanagedFds: false,
        workerData: {
          filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
          dataBuf: stream[kImpl].dataBuf,
          stateBuf: stream[kImpl].stateBuf,
          workerData: {
            $context: {
              threadStreamVersion: version2
            },
            ...workerData
          }
        }
      });
      worker.stream = new FakeWeakRef(stream);
      worker.on("message", onWorkerMessage);
      worker.on("exit", onWorkerExit);
      registry.register(stream, worker);
      return worker;
    }
    function drain(stream) {
      assert2(!stream[kImpl].sync);
      if (stream[kImpl].needDrain) {
        stream[kImpl].needDrain = false;
        stream.emit("drain");
      }
    }
    function nextFlush(stream) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover > 0) {
        if (stream[kImpl].buf.length === 0) {
          stream[kImpl].flushing = false;
          if (stream[kImpl].ending) {
            end(stream);
          } else if (stream[kImpl].needDrain) {
            process.nextTick(drain, stream);
          }
          return;
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, nextFlush.bind(null, stream));
        } else {
          stream.flush(() => {
            if (stream.destroyed) {
              return;
            }
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            while (toWriteBytes > stream[kImpl].data.length) {
              leftover = leftover / 2;
              toWrite = stream[kImpl].buf.slice(0, leftover);
              toWriteBytes = Buffer.byteLength(toWrite);
            }
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            write(stream, toWrite, nextFlush.bind(null, stream));
          });
        }
      } else if (leftover === 0) {
        if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
          return;
        }
        stream.flush(() => {
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          nextFlush(stream);
        });
      } else {
        destroy(stream, new Error("overwritten"));
      }
    }
    function onWorkerMessage(msg) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        this.exited = true;
        this.terminate();
        return;
      }
      switch (msg.code) {
        case "READY":
          this.stream = new WeakRef2(stream);
          stream.flush(() => {
            stream[kImpl].ready = true;
            stream.emit("ready");
          });
          break;
        case "ERROR":
          destroy(stream, msg.err);
          break;
        case "EVENT":
          if (Array.isArray(msg.args)) {
            stream.emit(msg.name, ...msg.args);
          } else {
            stream.emit(msg.name, msg.args);
          }
          break;
        case "WARNING":
          process.emitWarning(msg.err);
          break;
        default:
          destroy(stream, new Error("this should not happen: " + msg.code));
      }
    }
    function onWorkerExit(code4) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        return;
      }
      registry.unregister(stream);
      stream.worker.exited = true;
      stream.worker.off("exit", onWorkerExit);
      destroy(stream, code4 !== 0 ? new Error("the worker thread exited") : null);
    }
    var ThreadStream = class extends EventEmitter {
      constructor(opts = {}) {
        super();
        if (opts.bufferSize < 4) {
          throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
        }
        this[kImpl] = {};
        this[kImpl].stateBuf = new SharedArrayBuffer(128);
        this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
        this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
        this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
        this[kImpl].sync = opts.sync || false;
        this[kImpl].ending = false;
        this[kImpl].ended = false;
        this[kImpl].needDrain = false;
        this[kImpl].destroyed = false;
        this[kImpl].flushing = false;
        this[kImpl].ready = false;
        this[kImpl].finished = false;
        this[kImpl].errored = null;
        this[kImpl].closed = false;
        this[kImpl].buf = "";
        this.worker = createWorker(this, opts);
      }
      write(data) {
        if (this[kImpl].destroyed) {
          error(this, new Error("the worker has exited"));
          return false;
        }
        if (this[kImpl].ending) {
          error(this, new Error("the worker is ending"));
          return false;
        }
        if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
          try {
            writeSync(this);
            this[kImpl].flushing = true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        this[kImpl].buf += data;
        if (this[kImpl].sync) {
          try {
            writeSync(this);
            return true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        if (!this[kImpl].flushing) {
          this[kImpl].flushing = true;
          setImmediate(nextFlush, this);
        }
        this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
        return !this[kImpl].needDrain;
      }
      end() {
        if (this[kImpl].destroyed) {
          return;
        }
        this[kImpl].ending = true;
        end(this);
      }
      flush(cb) {
        if (this[kImpl].destroyed) {
          if (typeof cb === "function") {
            process.nextTick(cb, new Error("the worker has exited"));
          }
          return;
        }
        const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
        wait2(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
          if (err) {
            destroy(this, err);
            process.nextTick(cb, err);
            return;
          }
          if (res === "not-equal") {
            this.flush(cb);
            return;
          }
          process.nextTick(cb);
        });
      }
      flushSync() {
        if (this[kImpl].destroyed) {
          return;
        }
        writeSync(this);
        flushSync(this);
      }
      unref() {
        this.worker.unref();
      }
      ref() {
        this.worker.ref();
      }
      get ready() {
        return this[kImpl].ready;
      }
      get destroyed() {
        return this[kImpl].destroyed;
      }
      get closed() {
        return this[kImpl].closed;
      }
      get writable() {
        return !this[kImpl].destroyed && !this[kImpl].ending;
      }
      get writableEnded() {
        return this[kImpl].ending;
      }
      get writableFinished() {
        return this[kImpl].finished;
      }
      get writableNeedDrain() {
        return this[kImpl].needDrain;
      }
      get writableObjectMode() {
        return false;
      }
      get writableErrored() {
        return this[kImpl].errored;
      }
    };
    function error(stream, err) {
      setImmediate(() => {
        stream.emit("error", err);
      });
    }
    function destroy(stream, err) {
      if (stream[kImpl].destroyed) {
        return;
      }
      stream[kImpl].destroyed = true;
      if (err) {
        stream[kImpl].errored = err;
        error(stream, err);
      }
      if (!stream.worker.exited) {
        stream.worker.terminate().catch(() => {
        }).then(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      } else {
        setImmediate(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      }
    }
    function write(stream, data, cb) {
      const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      const length2 = Buffer.byteLength(data);
      stream[kImpl].data.write(data, current);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length2);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      cb();
      return true;
    }
    function end(stream) {
      if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
        return;
      }
      stream[kImpl].ended = true;
      try {
        stream.flushSync();
        let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
        Atomics.notify(stream[kImpl].state, WRITE_INDEX);
        let spins = 0;
        while (readIndex !== -1) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
          readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
          if (readIndex === -2) {
            destroy(stream, new Error("end() failed"));
            return;
          }
          if (++spins === 10) {
            destroy(stream, new Error("end() took too long (10s)"));
            return;
          }
        }
        process.nextTick(() => {
          stream[kImpl].finished = true;
          stream.emit("finish");
        });
      } catch (err) {
        destroy(stream, err);
      }
    }
    function writeSync(stream) {
      const cb = () => {
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
      };
      stream[kImpl].flushing = false;
      while (stream[kImpl].buf.length !== 0) {
        const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
        let leftover = stream[kImpl].data.length - writeIndex;
        if (leftover === 0) {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          continue;
        } else if (leftover < 0) {
          throw new Error("overwritten");
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        } else {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream[kImpl].buf.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        }
      }
    }
    function flushSync(stream) {
      if (stream[kImpl].flushing) {
        throw new Error("unable to flush while flushing");
      }
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (true) {
        const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          throw Error("_flushSync failed");
        }
        if (readIndex !== writeIndex) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
        } else {
          break;
        }
        if (++spins === 10) {
          throw new Error("_flushSync took too long (10s)");
        }
      }
    }
    module2.exports = ThreadStream;
  }
});

// ../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/transport.js
var require_transport = __commonJS({
  "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/transport.js"(exports, module2) {
    "use strict";
    var { createRequire: createRequire2 } = require("module");
    var getCallers = require_caller();
    var { join, isAbsolute, sep } = require("path");
    var sleep = require_atomic_sleep();
    var onExit = require_on_exit_leak_free();
    var ThreadStream = require_thread_stream();
    function setupOnExit(stream) {
      onExit.register(stream, autoEnd);
      onExit.registerBeforeExit(stream, flush);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    function buildStream(filename, workerData, workerOpts) {
      const stream = new ThreadStream({
        filename,
        workerData,
        workerOpts
      });
      stream.on("ready", onReady);
      stream.on("close", function() {
        process.removeListener("exit", onExit2);
      });
      process.on("exit", onExit2);
      function onReady() {
        process.removeListener("exit", onExit2);
        stream.unref();
        if (workerOpts.autoEnd !== false) {
          setupOnExit(stream);
        }
      }
      function onExit2() {
        if (stream.closed) {
          return;
        }
        stream.flushSync();
        sleep(100);
        stream.end();
      }
      return stream;
    }
    function autoEnd(stream) {
      stream.ref();
      stream.flushSync();
      stream.end();
      stream.once("close", function() {
        stream.unref();
      });
    }
    function flush(stream) {
      stream.flushSync();
    }
    function transport(fullOptions) {
      const { pipeline, targets, levels, dedupe, options = {}, worker = {}, caller = getCallers() } = fullOptions;
      const callers = typeof caller === "string" ? [caller] : caller;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      let target2 = fullOptions.target;
      if (target2 && targets) {
        throw new Error("only one of target or targets can be specified");
      }
      if (targets) {
        target2 = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
        options.targets = targets.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
      } else if (pipeline) {
        target2 = bundlerOverrides["pino-pipeline-worker"] || join(__dirname, "worker-pipeline.js");
        options.targets = pipeline.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
      }
      if (levels) {
        options.levels = levels;
      }
      if (dedupe) {
        options.dedupe = dedupe;
      }
      return buildStream(fixTarget(target2), options, worker);
      function fixTarget(origin) {
        origin = bundlerOverrides[origin] || origin;
        if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
          return origin;
        }
        if (origin === "pino/file") {
          return join(__dirname, "..", "file.js");
        }
        let fixTarget2;
        for (const filePath of callers) {
          try {
            const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
            fixTarget2 = createRequire2(context).resolve(origin);
            break;
          } catch (err) {
            continue;
          }
        }
        if (!fixTarget2) {
          throw new Error(`unable to determine transport target for "${origin}"`);
        }
        return fixTarget2;
      }
    }
    module2.exports = transport;
  }
});

// ../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/tools.js
var require_tools = __commonJS({
  "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/tools.js"(exports, module2) {
    "use strict";
    var format = require_quick_format_unescaped();
    var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
    var SonicBoom = require_sonic_boom();
    var onExit = require_on_exit_leak_free();
    var {
      lsCacheSym,
      chindingsSym,
      writeSym,
      serializersSym,
      formatOptsSym,
      endSym,
      stringifiersSym,
      stringifySym,
      stringifySafeSym,
      wildcardFirstSym,
      nestedKeySym,
      formattersSym,
      messageKeySym,
      errorKeySym,
      nestedKeyStrSym,
      msgPrefixSym
    } = require_symbols();
    var { isMainThread } = require("worker_threads");
    var transport = require_transport();
    function noop2() {
    }
    function genLog(level2, hook) {
      if (!hook)
        return LOG;
      return function hookWrappedLog(...args) {
        hook.call(this, args, LOG, level2);
      };
      function LOG(o, ...n) {
        if (typeof o === "object") {
          let msg = o;
          if (o !== null) {
            if (o.method && o.headers && o.socket) {
              o = mapHttpRequest(o);
            } else if (typeof o.setHeader === "function") {
              o = mapHttpResponse(o);
            }
          }
          let formatParams;
          if (msg === null && n.length === 0) {
            formatParams = [null];
          } else {
            msg = n.shift();
            formatParams = n;
          }
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level2);
        } else {
          let msg = o === void 0 ? n.shift() : o;
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](null, format(msg, n, this[formatOptsSym]), level2);
        }
      }
    }
    function asString(str) {
      let result = "";
      let last = 0;
      let found = false;
      let point = 255;
      const l = str.length;
      if (l > 100) {
        return JSON.stringify(str);
      }
      for (var i = 0; i < l && point >= 32; i++) {
        point = str.charCodeAt(i);
        if (point === 34 || point === 92) {
          result += str.slice(last, i) + "\\";
          last = i;
          found = true;
        }
      }
      if (!found) {
        result = str;
      } else {
        result += str.slice(last);
      }
      return point < 32 ? JSON.stringify(str) : '"' + result + '"';
    }
    function asJson(obj, msg, num, time) {
      const stringify2 = this[stringifySym];
      const stringifySafe = this[stringifySafeSym];
      const stringifiers = this[stringifiersSym];
      const end = this[endSym];
      const chindings = this[chindingsSym];
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const messageKey = this[messageKeySym];
      const errorKey = this[errorKeySym];
      let data = this[lsCacheSym][num] + time;
      data = data + chindings;
      let value;
      if (formatters.log) {
        obj = formatters.log(obj);
      }
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      let propStr = "";
      for (const key in obj) {
        value = obj[key];
        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
          if (serializers[key]) {
            value = serializers[key](value);
          } else if (key === errorKey && serializers.err) {
            value = serializers.err(value);
          }
          const stringifier = stringifiers[key] || wildcardStringifier;
          switch (typeof value) {
            case "undefined":
            case "function":
              continue;
            case "number":
              if (Number.isFinite(value) === false) {
                value = null;
              }
            case "boolean":
              if (stringifier)
                value = stringifier(value);
              break;
            case "string":
              value = (stringifier || asString)(value);
              break;
            default:
              value = (stringifier || stringify2)(value, stringifySafe);
          }
          if (value === void 0)
            continue;
          propStr += ',"' + key + '":' + value;
        }
      }
      let msgStr = "";
      if (msg !== void 0) {
        value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
        const stringifier = stringifiers[messageKey] || wildcardStringifier;
        switch (typeof value) {
          case "function":
            break;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          case "boolean":
            if (stringifier)
              value = stringifier(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          case "string":
            value = (stringifier || asString)(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          default:
            value = (stringifier || stringify2)(value, stringifySafe);
            msgStr = ',"' + messageKey + '":' + value;
        }
      }
      if (this[nestedKeySym] && propStr) {
        return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
      } else {
        return data + propStr + msgStr + end;
      }
    }
    function asChindings(instance, bindings) {
      let value;
      let data = instance[chindingsSym];
      const stringify2 = instance[stringifySym];
      const stringifySafe = instance[stringifySafeSym];
      const stringifiers = instance[stringifiersSym];
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      const serializers = instance[serializersSym];
      const formatter = instance[formattersSym].bindings;
      bindings = formatter(bindings);
      for (const key in bindings) {
        value = bindings[key];
        const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== void 0;
        if (valid === true) {
          value = serializers[key] ? serializers[key](value) : value;
          value = (stringifiers[key] || wildcardStringifier || stringify2)(value, stringifySafe);
          if (value === void 0)
            continue;
          data += ',"' + key + '":' + value;
        }
      }
      return data;
    }
    function hasBeenTampered(stream) {
      return stream.write !== stream.constructor.prototype.write;
    }
    function buildSafeSonicBoom(opts) {
      const stream = new SonicBoom(opts);
      stream.on("error", filterBrokenPipe);
      if (!opts.sync && isMainThread) {
        onExit.register(stream, autoEnd);
        stream.on("close", function() {
          onExit.unregister(stream);
        });
      }
      return stream;
      function filterBrokenPipe(err) {
        if (err.code === "EPIPE") {
          stream.write = noop2;
          stream.end = noop2;
          stream.flushSync = noop2;
          stream.destroy = noop2;
          return;
        }
        stream.removeListener("error", filterBrokenPipe);
        stream.emit("error", err);
      }
    }
    function autoEnd(stream, eventName) {
      if (stream.destroyed) {
        return;
      }
      if (eventName === "beforeExit") {
        stream.flush();
        stream.on("drain", function() {
          stream.end();
        });
      } else {
        stream.flushSync();
      }
    }
    function createArgsNormalizer(defaultOptions2) {
      return function normalizeArgs(instance, caller, opts = {}, stream) {
        if (typeof opts === "string") {
          stream = buildSafeSonicBoom({ dest: opts });
          opts = {};
        } else if (typeof stream === "string") {
          if (opts && opts.transport) {
            throw Error("only one of option.transport or stream can be specified");
          }
          stream = buildSafeSonicBoom({ dest: stream });
        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
          stream = opts;
          opts = {};
        } else if (opts.transport) {
          if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
            throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
          }
          if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
            throw Error("option.transport.targets do not allow custom level formatters");
          }
          let customLevels;
          if (opts.customLevels) {
            customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
          }
          stream = transport({ caller, ...opts.transport, levels: customLevels });
        }
        opts = Object.assign({}, defaultOptions2, opts);
        opts.serializers = Object.assign({}, defaultOptions2.serializers, opts.serializers);
        opts.formatters = Object.assign({}, defaultOptions2.formatters, opts.formatters);
        if (opts.prettyPrint) {
          throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
        }
        const { enabled: enabled2, onChild } = opts;
        if (enabled2 === false)
          opts.level = "silent";
        if (!onChild)
          opts.onChild = noop2;
        if (!stream) {
          if (!hasBeenTampered(process.stdout)) {
            stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
          } else {
            stream = process.stdout;
          }
        }
        return { opts, stream };
      };
    }
    function stringify(obj, stringifySafeFn) {
      try {
        return JSON.stringify(obj);
      } catch (_) {
        try {
          const stringify2 = stringifySafeFn || this[stringifySafeSym];
          return stringify2(obj);
        } catch (_2) {
          return '"[unable to serialize, circular reference is too complex to analyze]"';
        }
      }
    }
    function buildFormatters(level2, bindings, log) {
      return {
        level: level2,
        bindings,
        log
      };
    }
    function normalizeDestFileDescriptor(destination) {
      const fd = Number(destination);
      if (typeof destination === "string" && Number.isFinite(fd)) {
        return fd;
      }
      if (destination === void 0) {
        return 1;
      }
      return destination;
    }
    module2.exports = {
      noop: noop2,
      buildSafeSonicBoom,
      asChindings,
      asJson,
      genLog,
      createArgsNormalizer,
      stringify,
      buildFormatters,
      normalizeDestFileDescriptor
    };
  }
});

// ../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/levels.js
var require_levels = __commonJS({
  "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/levels.js"(exports, module2) {
    "use strict";
    var {
      lsCacheSym,
      levelValSym,
      useOnlyCustomLevelsSym,
      streamSym,
      formattersSym,
      hooksSym
    } = require_symbols();
    var { noop: noop2, genLog } = require_tools();
    var levels = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    };
    var levelMethods = {
      fatal: (hook) => {
        const logFatal = genLog(levels.fatal, hook);
        return function(...args) {
          const stream = this[streamSym];
          logFatal.call(this, ...args);
          if (typeof stream.flushSync === "function") {
            try {
              stream.flushSync();
            } catch (e) {
            }
          }
        };
      },
      error: (hook) => genLog(levels.error, hook),
      warn: (hook) => genLog(levels.warn, hook),
      info: (hook) => genLog(levels.info, hook),
      debug: (hook) => genLog(levels.debug, hook),
      trace: (hook) => genLog(levels.trace, hook)
    };
    var nums = Object.keys(levels).reduce((o, k) => {
      o[levels[k]] = k;
      return o;
    }, {});
    var initialLsCache = Object.keys(nums).reduce((o, k) => {
      o[k] = '{"level":' + Number(k);
      return o;
    }, {});
    function genLsCache(instance) {
      const formatter = instance[formattersSym].level;
      const { labels } = instance.levels;
      const cache = {};
      for (const label in labels) {
        const level2 = formatter(labels[label], Number(label));
        cache[label] = JSON.stringify(level2).slice(0, -1);
      }
      instance[lsCacheSym] = cache;
      return instance;
    }
    function isStandardLevel(level2, useOnlyCustomLevels) {
      if (useOnlyCustomLevels) {
        return false;
      }
      switch (level2) {
        case "fatal":
        case "error":
        case "warn":
        case "info":
        case "debug":
        case "trace":
          return true;
        default:
          return false;
      }
    }
    function setLevel(level2) {
      const { labels, values } = this.levels;
      if (typeof level2 === "number") {
        if (labels[level2] === void 0)
          throw Error("unknown level value" + level2);
        level2 = labels[level2];
      }
      if (values[level2] === void 0)
        throw Error("unknown level " + level2);
      const preLevelVal = this[levelValSym];
      const levelVal = this[levelValSym] = values[level2];
      const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
      const hook = this[hooksSym].logMethod;
      for (const key in values) {
        if (levelVal > values[key]) {
          this[key] = noop2;
          continue;
        }
        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
      }
      this.emit("level-change", level2, levelVal, labels[preLevelVal], preLevelVal, this);
    }
    function getLevel(level2) {
      const { levels: levels2, levelVal } = this;
      return levels2 && levels2.labels ? levels2.labels[levelVal] : "";
    }
    function isLevelEnabled(logLevel) {
      const { values } = this.levels;
      const logLevelVal = values[logLevel];
      return logLevelVal !== void 0 && logLevelVal >= this[levelValSym];
    }
    function mappings(customLevels = null, useOnlyCustomLevels = false) {
      const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
        o[customLevels[k]] = k;
        return o;
      }, {}) : null;
      const labels = Object.assign(Object.create(Object.prototype, { Infinity: { value: "silent" } }), useOnlyCustomLevels ? null : nums, customNums);
      const values = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : levels, customLevels);
      return { labels, values };
    }
    function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
      if (typeof defaultLevel === "number") {
        const values = [].concat(Object.keys(customLevels || {}).map((key) => customLevels[key]), useOnlyCustomLevels ? [] : Object.keys(nums).map((level2) => +level2), Infinity);
        if (!values.includes(defaultLevel)) {
          throw Error(`default level:${defaultLevel} must be included in custom levels`);
        }
        return;
      }
      const labels = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : levels, customLevels);
      if (!(defaultLevel in labels)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
    }
    function assertNoLevelCollisions(levels2, customLevels) {
      const { labels, values } = levels2;
      for (const k in customLevels) {
        if (k in values) {
          throw Error("levels cannot be overridden");
        }
        if (customLevels[k] in labels) {
          throw Error("pre-existing level values cannot be used for new levels");
        }
      }
    }
    module2.exports = {
      initialLsCache,
      genLsCache,
      levelMethods,
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      levels,
      assertNoLevelCollisions,
      assertDefaultLevelFound
    };
  }
});

// ../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/meta.js
var require_meta = __commonJS({
  "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/meta.js"(exports, module2) {
    "use strict";
    module2.exports = { version: "8.15.0" };
  }
});

// ../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/proto.js
var require_proto = __commonJS({
  "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/proto.js"(exports, module2) {
    "use strict";
    var { EventEmitter } = require("events");
    var {
      lsCacheSym,
      levelValSym,
      setLevelSym,
      getLevelSym,
      chindingsSym,
      parsedChindingsSym,
      mixinSym,
      asJsonSym,
      writeSym,
      mixinMergeStrategySym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      serializersSym,
      formattersSym,
      errorKeySym,
      messageKeySym,
      useOnlyCustomLevelsSym,
      needsMetadataGsym,
      redactFmtSym,
      stringifySym,
      formatOptsSym,
      stringifiersSym,
      msgPrefixSym
    } = require_symbols();
    var {
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      initialLsCache,
      genLsCache,
      assertNoLevelCollisions
    } = require_levels();
    var {
      asChindings,
      asJson,
      buildFormatters,
      stringify
    } = require_tools();
    var {
      version: version2
    } = require_meta();
    var redaction = require_redaction();
    var constructor = class Pino {
    };
    var prototype = {
      constructor,
      child,
      bindings,
      setBindings,
      flush,
      isLevelEnabled,
      version: version2,
      get level() {
        return this[getLevelSym]();
      },
      set level(lvl) {
        this[setLevelSym](lvl);
      },
      get levelVal() {
        return this[levelValSym];
      },
      set levelVal(n) {
        throw Error("levelVal is read-only");
      },
      [lsCacheSym]: initialLsCache,
      [writeSym]: write,
      [asJsonSym]: asJson,
      [getLevelSym]: getLevel,
      [setLevelSym]: setLevel
    };
    Object.setPrototypeOf(prototype, EventEmitter.prototype);
    module2.exports = function() {
      return Object.create(prototype);
    };
    var resetChildingsFormatter = (bindings2) => bindings2;
    function child(bindings2, options) {
      if (!bindings2) {
        throw Error("missing bindings for child Pino");
      }
      options = options || {};
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const instance = Object.create(this);
      if (options.hasOwnProperty("serializers") === true) {
        instance[serializersSym] = /* @__PURE__ */ Object.create(null);
        for (const k in serializers) {
          instance[serializersSym][k] = serializers[k];
        }
        const parentSymbols = Object.getOwnPropertySymbols(serializers);
        for (var i = 0; i < parentSymbols.length; i++) {
          const ks = parentSymbols[i];
          instance[serializersSym][ks] = serializers[ks];
        }
        for (const bk in options.serializers) {
          instance[serializersSym][bk] = options.serializers[bk];
        }
        const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
        for (var bi = 0; bi < bindingsSymbols.length; bi++) {
          const bks = bindingsSymbols[bi];
          instance[serializersSym][bks] = options.serializers[bks];
        }
      } else
        instance[serializersSym] = serializers;
      if (options.hasOwnProperty("formatters")) {
        const { level: level2, bindings: chindings, log } = options.formatters;
        instance[formattersSym] = buildFormatters(level2 || formatters.level, chindings || resetChildingsFormatter, log || formatters.log);
      } else {
        instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);
      }
      if (options.hasOwnProperty("customLevels") === true) {
        assertNoLevelCollisions(this.levels, options.customLevels);
        instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
        genLsCache(instance);
      }
      if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
        instance.redact = options.redact;
        const stringifiers = redaction(instance.redact, stringify);
        const formatOpts = { stringify: stringifiers[redactFmtSym] };
        instance[stringifySym] = stringify;
        instance[stringifiersSym] = stringifiers;
        instance[formatOptsSym] = formatOpts;
      }
      if (typeof options.msgPrefix === "string") {
        instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      const childLevel = options.level || this.level;
      instance[setLevelSym](childLevel);
      this.onChild(instance);
      return instance;
    }
    function bindings() {
      const chindings = this[chindingsSym];
      const chindingsJson = `{${chindings.substr(1)}}`;
      const bindingsFromJson = JSON.parse(chindingsJson);
      delete bindingsFromJson.pid;
      delete bindingsFromJson.hostname;
      return bindingsFromJson;
    }
    function setBindings(newBindings) {
      const chindings = asChindings(this, newBindings);
      this[chindingsSym] = chindings;
      delete this[parsedChindingsSym];
    }
    function defaultMixinMergeStrategy(mergeObject, mixinObject) {
      return Object.assign(mixinObject, mergeObject);
    }
    function write(_obj, msg, num) {
      const t = this[timeSym]();
      const mixin = this[mixinSym];
      const errorKey = this[errorKeySym];
      const messageKey = this[messageKeySym];
      const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
      let obj;
      if (_obj === void 0 || _obj === null) {
        obj = {};
      } else if (_obj instanceof Error) {
        obj = { [errorKey]: _obj };
        if (msg === void 0) {
          msg = _obj.message;
        }
      } else {
        obj = _obj;
        if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
          msg = _obj[errorKey].message;
        }
      }
      if (mixin) {
        obj = mixinMergeStrategy(obj, mixin(obj, num, this));
      }
      const s = this[asJsonSym](obj, msg, num, t);
      const stream = this[streamSym];
      if (stream[needsMetadataGsym] === true) {
        stream.lastLevel = num;
        stream.lastObj = obj;
        stream.lastMsg = msg;
        stream.lastTime = t.slice(this[timeSliceIndexSym]);
        stream.lastLogger = this;
      }
      stream.write(s);
    }
    function noop2() {
    }
    function flush() {
      const stream = this[streamSym];
      if ("flush" in stream)
        stream.flush(noop2);
    }
  }
});

// ../../node_modules/.pnpm/safe-stable-stringify@2.4.3/node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "../../node_modules/.pnpm/safe-stable-stringify@2.4.3/node_modules/safe-stable-stringify/index.js"(exports, module2) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports.stringify = stringify;
    exports.configure = configure;
    module2.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function insertSort(array2) {
      if (array2.length > 200) {
        return array2.sort();
      }
      for (let i = 1; i < array2.length; i++) {
        const currentValue = array2[i];
        let position3 = i;
        while (position3 !== 0 && array2[position3 - 1] > currentValue) {
          array2[position3] = array2[position3 - 1];
          position3--;
        }
        array2[position3] = currentValue;
      }
      return array2;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())), Symbol.toStringTag).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array2, separator, maximumBreadth) {
      if (array2.length < maximumBreadth) {
        maximumBreadth = array2.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array2[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array2[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number2) {
      if (number2 === 1) {
        return "1 item";
      }
      return `${number2} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function")
              message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getBooleanOption(options, "deterministic");
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});

// ../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/multistream.js
var require_multistream = __commonJS({
  "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/lib/multistream.js"(exports, module2) {
    "use strict";
    var metadata = Symbol.for("pino.metadata");
    var { levels } = require_levels();
    var DEFAULT_INFO_LEVEL = levels.info;
    function multistream(streamsArray, opts) {
      let counter = 0;
      streamsArray = streamsArray || [];
      opts = opts || { dedupe: false };
      const streamLevels = Object.create(levels);
      streamLevels.silent = Infinity;
      if (opts.levels && typeof opts.levels === "object") {
        Object.keys(opts.levels).forEach((i) => {
          streamLevels[i] = opts.levels[i];
        });
      }
      const res = {
        write,
        add,
        flushSync,
        end,
        minLevel: 0,
        streams: [],
        clone,
        [metadata]: true,
        streamLevels
      };
      if (Array.isArray(streamsArray)) {
        streamsArray.forEach(add, res);
      } else {
        add.call(res, streamsArray);
      }
      streamsArray = null;
      return res;
      function write(data) {
        let dest;
        const level2 = this.lastLevel;
        const { streams } = this;
        let recordedLevel = 0;
        let stream;
        for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
          dest = streams[i];
          if (dest.level <= level2) {
            if (recordedLevel !== 0 && recordedLevel !== dest.level) {
              break;
            }
            stream = dest.stream;
            if (stream[metadata]) {
              const { lastTime, lastMsg, lastObj, lastLogger } = this;
              stream.lastLevel = level2;
              stream.lastTime = lastTime;
              stream.lastMsg = lastMsg;
              stream.lastObj = lastObj;
              stream.lastLogger = lastLogger;
            }
            stream.write(data);
            if (opts.dedupe) {
              recordedLevel = dest.level;
            }
          } else if (!opts.dedupe) {
            break;
          }
        }
      }
      function flushSync() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
        }
      }
      function add(dest) {
        if (!dest) {
          return res;
        }
        const isStream = typeof dest.write === "function" || dest.stream;
        const stream_ = dest.write ? dest : dest.stream;
        if (!isStream) {
          throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
        }
        const { streams, streamLevels: streamLevels2 } = this;
        let level2;
        if (typeof dest.levelVal === "number") {
          level2 = dest.levelVal;
        } else if (typeof dest.level === "string") {
          level2 = streamLevels2[dest.level];
        } else if (typeof dest.level === "number") {
          level2 = dest.level;
        } else {
          level2 = DEFAULT_INFO_LEVEL;
        }
        const dest_ = {
          stream: stream_,
          level: level2,
          levelVal: void 0,
          id: counter++
        };
        streams.unshift(dest_);
        streams.sort(compareByLevel);
        this.minLevel = streams[0].level;
        return res;
      }
      function end() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
          stream.end();
        }
      }
      function clone(level2) {
        const streams = new Array(this.streams.length);
        for (let i = 0; i < streams.length; i++) {
          streams[i] = {
            level: level2,
            stream: this.streams[i].stream
          };
        }
        return {
          write,
          add,
          minLevel: level2,
          streams,
          clone,
          flushSync,
          [metadata]: true
        };
      }
    }
    function compareByLevel(a, b) {
      return a.level - b.level;
    }
    function initLoopVar(length2, dedupe) {
      return dedupe ? length2 - 1 : 0;
    }
    function adjustLoopVar(i, dedupe) {
      return dedupe ? i - 1 : i + 1;
    }
    function checkLoopVar(i, length2, dedupe) {
      return dedupe ? i >= 0 : i < length2;
    }
    module2.exports = multistream;
  }
});

// ../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/pino.js
var require_pino = __commonJS({
  "../../node_modules/.pnpm/pino@8.15.0/node_modules/pino/pino.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var stdSerializers = require_pino_std_serializers();
    var caller = require_caller();
    var redaction = require_redaction();
    var time = require_time();
    var proto = require_proto();
    var symbols = require_symbols();
    var { configure } = require_safe_stable_stringify();
    var { assertDefaultLevelFound, mappings, genLsCache, levels } = require_levels();
    var {
      createArgsNormalizer,
      asChindings,
      buildSafeSonicBoom,
      buildFormatters,
      stringify,
      normalizeDestFileDescriptor,
      noop: noop2
    } = require_tools();
    var { version: version2 } = require_meta();
    var {
      chindingsSym,
      redactFmtSym,
      serializersSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      setLevelSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      mixinSym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    } = symbols;
    var { epochTime, nullTime } = time;
    var { pid } = process;
    var hostname = os.hostname();
    var defaultErrorSerializer = stdSerializers.err;
    var defaultOptions2 = {
      level: "info",
      levels,
      messageKey: "msg",
      errorKey: "err",
      nestedKey: null,
      enabled: true,
      base: { pid, hostname },
      serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
        err: defaultErrorSerializer
      }),
      formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
        bindings(bindings) {
          return bindings;
        },
        level(label, number2) {
          return { level: number2 };
        }
      }),
      hooks: {
        logMethod: void 0
      },
      timestamp: epochTime,
      name: void 0,
      redact: null,
      customLevels: null,
      useOnlyCustomLevels: false,
      depthLimit: 5,
      edgeLimit: 100
    };
    var normalize = createArgsNormalizer(defaultOptions2);
    var serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
    function pino2(...args) {
      const instance = {};
      const { opts, stream } = normalize(instance, caller(), ...args);
      const {
        redact,
        crlf,
        serializers: serializers2,
        timestamp,
        messageKey,
        errorKey,
        nestedKey,
        base: base3,
        name: name3,
        level: level2,
        customLevels,
        mixin,
        mixinMergeStrategy,
        useOnlyCustomLevels,
        formatters,
        hooks,
        depthLimit,
        edgeLimit,
        onChild,
        msgPrefix
      } = opts;
      const stringifySafe = configure({
        maximumDepth: depthLimit,
        maximumBreadth: edgeLimit
      });
      const allFormatters = buildFormatters(formatters.level, formatters.bindings, formatters.log);
      const stringifyFn = stringify.bind({
        [stringifySafeSym]: stringifySafe
      });
      const stringifiers = redact ? redaction(redact, stringifyFn) : {};
      const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
      const end = "}" + (crlf ? "\r\n" : "\n");
      const coreChindings = asChindings.bind(null, {
        [chindingsSym]: "",
        [serializersSym]: serializers2,
        [stringifiersSym]: stringifiers,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [formattersSym]: allFormatters
      });
      let chindings = "";
      if (base3 !== null) {
        if (name3 === void 0) {
          chindings = coreChindings(base3);
        } else {
          chindings = coreChindings(Object.assign({}, base3, { name: name3 }));
        }
      }
      const time2 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
      const timeSliceIndex = time2().indexOf(":") + 1;
      if (useOnlyCustomLevels && !customLevels)
        throw Error("customLevels is required if useOnlyCustomLevels is set true");
      if (mixin && typeof mixin !== "function")
        throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
      if (msgPrefix && typeof msgPrefix !== "string")
        throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
      assertDefaultLevelFound(level2, customLevels, useOnlyCustomLevels);
      const levels2 = mappings(customLevels, useOnlyCustomLevels);
      Object.assign(instance, {
        levels: levels2,
        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
        [streamSym]: stream,
        [timeSym]: time2,
        [timeSliceIndexSym]: timeSliceIndex,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [stringifiersSym]: stringifiers,
        [endSym]: end,
        [formatOptsSym]: formatOpts,
        [messageKeySym]: messageKey,
        [errorKeySym]: errorKey,
        [nestedKeySym]: nestedKey,
        [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
        [serializersSym]: serializers2,
        [mixinSym]: mixin,
        [mixinMergeStrategySym]: mixinMergeStrategy,
        [chindingsSym]: chindings,
        [formattersSym]: allFormatters,
        [hooksSym]: hooks,
        silent: noop2,
        onChild,
        [msgPrefixSym]: msgPrefix
      });
      Object.setPrototypeOf(instance, proto());
      genLsCache(instance);
      instance[setLevelSym](level2);
      return instance;
    }
    module2.exports = pino2;
    module2.exports.destination = (dest = process.stdout.fd) => {
      if (typeof dest === "object") {
        dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
        return buildSafeSonicBoom(dest);
      } else {
        return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
      }
    };
    module2.exports.transport = require_transport();
    module2.exports.multistream = require_multistream();
    module2.exports.levels = mappings();
    module2.exports.stdSerializers = serializers;
    module2.exports.stdTimeFunctions = Object.assign({}, time);
    module2.exports.symbols = symbols;
    module2.exports.version = version2;
    module2.exports.default = pino2;
    module2.exports.pino = pino2;
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js
var require_encode = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js"(exports, module2) {
    module2.exports = encode9;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode9(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode9.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode9.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js
var require_decode = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js"(exports, module2) {
    module2.exports = read3;
    var MSB2 = 128;
    var REST2 = 127;
    function read3(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l || shift > 49) {
          read3.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read3.bytes = counter - offset;
      return res;
    }
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js
var require_length = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js"(exports, module2) {
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js
var require_varint = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js"(exports, module2) {
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// src/index.ts
var src_exports4 = {};
__export(src_exports4, {
  BlobNotFoundError: () => BlobNotFoundError,
  BlockMap: () => BlockMap,
  CidSet: () => CidSet,
  DataDiff: () => DataDiff,
  Leaf: () => Leaf,
  MST: () => MST,
  MemoryBlockstore: () => MemoryBlockstore,
  MstWalker: () => MstWalker,
  ReadableBlockstore: () => ReadableBlockstore,
  Repo: () => Repo,
  RepoVerificationError: () => RepoVerificationError,
  SyncStorage: () => SyncStorage,
  WriteOpAction: () => WriteOpAction,
  blocksToCarFile: () => blocksToCarFile,
  blocksToCarStream: () => blocksToCarStream,
  carToBlocks: () => carToBlocks,
  cborToLex: () => cborToLex,
  cborToLexRecord: () => cborToLexRecord,
  cidForRecord: () => cidForRecord,
  def: () => def2,
  diffToWriteDescripts: () => diffToWriteDescripts,
  ensureCreates: () => ensureCreates,
  ensureV3Commit: () => ensureV3Commit,
  formatDataKey: () => formatDataKey,
  getAndParseByDef: () => getAndParseByDef,
  getAndParseRecord: () => getAndParseRecord,
  getFullRepo: () => getFullRepo,
  getRecords: () => getRecords,
  metaEqual: () => metaEqual,
  mstDiff: () => mstDiff,
  mstUtil: () => util_exports2,
  nodeDataDef: () => nodeDataDef,
  nullDiff: () => nullDiff,
  parseDataKey: () => parseDataKey,
  parseObjByDef: () => parseObjByDef,
  readCar: () => readCar,
  readCarStream: () => readCarStream,
  readCarWithRoot: () => readCarWithRoot,
  schema: () => schema2,
  signCommit: () => signCommit,
  verifyCommitSig: () => verifyCommitSig,
  verifyDiff: () => verifyDiff,
  verifyDiffCar: () => verifyDiffCar,
  verifyIncomingCarBlocks: () => verifyIncomingCarBlocks,
  verifyProofs: () => verifyProofs,
  verifyRecords: () => verifyRecords,
  verifyRepo: () => verifyRepo,
  verifyRepoCar: () => verifyRepoCar,
  writeCar: () => writeCar,
  writeCarStream: () => writeCarStream
});
module.exports = __toCommonJS(src_exports4);

// ../../node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params2) => {
  const { data, path, errorMaps, issueData } = params2;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (typeof value.value !== "undefined" || pair.alwaysSet) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params2) {
  if (!params2)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params2;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def3) {
    this.spa = this.safeParseAsync;
    this._def = def3;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params2) {
    const result = this.safeParse(data, params2);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params2) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params2 === null || params2 === void 0 ? void 0 : params2.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap
      },
      path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params2) {
    const result = await this.safeParseAsync(data, params2);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params2) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap,
        async: true
      },
      path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check2(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def3) {
    const defaultValueFunc = typeof def3 === "function" ? def3 : () => def3;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def3) {
    const catchValueFunc = typeof def3 === "function" ? def3 : () => def3;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target2) {
    return ZodPipeline.create(this, target2);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
var emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class extends ZodType {
  constructor() {
    super(...arguments);
    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
    this.trim = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
    this.toLowerCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
    this.toUpperCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          }
          status.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex = datetimeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _addCheck(check2) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params2) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params2)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params2) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
    ...processCreateParams(params2)
  });
};
var ZodBigInt = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params2) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params2)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params2) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
    ...processCreateParams(params2)
  });
};
var ZodDate = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params2) => {
  return new ZodDate({
    checks: [],
    coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params2)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params2) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params2)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params2) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params2)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params2) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params2)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params2) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params2)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params2) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params2)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params2) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params2)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params2) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params2)
  });
};
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def3 = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def3.exactLength !== null) {
      const tooBig = ctx.data.length > def3.exactLength.value;
      const tooSmall = ctx.data.length < def3.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def3.exactLength.value : void 0,
          maximum: tooBig ? def3.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def3.exactLength.message
        });
        status.dirty();
      }
    }
    if (def3.minLength !== null) {
      if (ctx.data.length < def3.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def3.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def3.minLength.message
        });
        status.dirty();
      }
    }
    if (def3.maxLength !== null) {
      if (ctx.data.length > def3.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def3.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def3.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def3.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def3.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema3, params2) => {
  return new ZodArray({
    type: schema3,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params2)
  });
};
function deepPartialify(schema3) {
  if (schema3 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema3.shape) {
      const fieldSchema = schema3.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema3._def,
      shape: () => newShape
    });
  } else if (schema3 instanceof ZodArray) {
    return new ZodArray({
      ...schema3._def,
      type: deepPartialify(schema3.element)
    });
  } else if (schema3 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema3.unwrap()));
  } else if (schema3 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema3.unwrap()));
  } else if (schema3 instanceof ZodTuple) {
    return ZodTuple.create(schema3.items.map((item) => deepPartialify(item)));
  } else {
    return schema3;
  }
}
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema3) {
    return this.augment({ [key]: schema3 });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params2) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params2)
  });
};
ZodObject.strictCreate = (shape, params2) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params2)
  });
};
ZodObject.lazycreate = (shape, params2) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params2)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params2) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params2)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params2) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params2)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params2) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params2)
  });
};
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema3 = this._def.items[itemIndex] || this._def.rest;
      if (!schema3)
        return null;
      return schema3._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params2) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params2)
  });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params2) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params2)
  });
};
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def3 = this._def;
    if (def3.minSize !== null) {
      if (ctx.data.size < def3.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def3.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def3.minSize.message
        });
        status.dirty();
      }
    }
    if (def3.maxSize !== null) {
      if (ctx.data.size > def3.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def3.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def3.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params2) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params2)
  });
};
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params2 = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      return OK(async (...args) => {
        const error = new ZodError([]);
        const parsedArgs = await this._def.args.parseAsync(args, params2).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await fn(...parsedArgs);
        const parsedReturns = await this._def.returns._def.type.parseAsync(result, params2).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      return OK((...args) => {
        const parsedArgs = this._def.args.safeParse(args, params2);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = fn(...parsedArgs.data);
        const parsedReturns = this._def.returns.safeParse(result, params2);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params2) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params2)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params2) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params2)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params2) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params2)
  });
};
function createZodEnum(values, params2) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params2)
  });
}
var ZodEnum = class extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params2) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params2)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema3, params2) => {
  return new ZodPromise({
    type: schema3,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params2)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base3 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base3))
          return base3;
        const result = effect.transform(base3.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {
          if (!isValid(base3))
            return base3;
          return Promise.resolve(effect.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema3, effect, params2) => {
  return new ZodEffects({
    schema: schema3,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params2)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema3, params2) => {
  return new ZodEffects({
    schema: schema3,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params2)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params2) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params2)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params2) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params2)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params2) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params2.default === "function" ? params2.default : () => params2.default,
    ...processCreateParams(params2)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params2) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params2.catch === "function" ? params2.catch : () => params2.catch,
    ...processCreateParams(params2)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params2) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params2)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var custom = (check2, params2 = {}, fatal) => {
  if (check2)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check2(data)) {
        const p = typeof params2 === "function" ? params2(data) : typeof params2 === "string" ? { message: params2 } : params2;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params2 = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params2);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// ../syntax/src/nsid.ts
var NSID = class {
  constructor(nsid2) {
    this.segments = [];
    ensureValidNsid(nsid2);
    this.segments = nsid2.split(".");
  }
  static parse(nsid2) {
    return new NSID(nsid2);
  }
  static create(authority, name3) {
    const segments = [...authority.split(".").reverse(), name3].join(".");
    return new NSID(segments);
  }
  static isValid(nsid2) {
    try {
      NSID.parse(nsid2);
      return true;
    } catch (e) {
      return false;
    }
  }
  get authority() {
    return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
  }
  get name() {
    return this.segments.at(this.segments.length - 1);
  }
  toString() {
    return this.segments.join(".");
  }
};
var ensureValidNsid = (nsid2) => {
  const toCheck = nsid2;
  if (!/^[a-zA-Z0-9.-]*$/.test(toCheck)) {
    throw new InvalidNsidError("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
  }
  if (toCheck.length > 253 + 1 + 63) {
    throw new InvalidNsidError("NSID is too long (317 chars max)");
  }
  const labels = toCheck.split(".");
  if (labels.length < 3) {
    throw new InvalidNsidError("NSID needs at least three parts");
  }
  for (let i = 0; i < labels.length; i++) {
    const l = labels[i];
    if (l.length < 1) {
      throw new InvalidNsidError("NSID parts can not be empty");
    }
    if (l.length > 63) {
      throw new InvalidNsidError("NSID part too long (max 63 chars)");
    }
    if (l.endsWith("-") || l.startsWith("-")) {
      throw new InvalidNsidError("NSID parts can not start or end with hyphen");
    }
    if (/^[0-9]/.test(l) && i == 0) {
      throw new InvalidNsidError("NSID first part may not start with a digit");
    }
    if (!/^[a-zA-Z]+$/.test(l) && i + 1 == labels.length) {
      throw new InvalidNsidError("NSID name part must be only letters");
    }
  }
};
var InvalidNsidError = class extends Error {
};

// ../common-web/src/check.ts
var check_exports = {};
__export(check_exports, {
  assure: () => assure,
  is: () => is,
  isObject: () => isObject
});
var is = (obj, def3) => {
  return def3.safeParse(obj).success;
};
var assure = (def3, obj) => {
  return def3.parse(obj);
};
var isObject = (obj) => {
  return typeof obj === "object" && obj !== null;
};

// ../common-web/src/util.ts
var flattenUint8Arrays = (arrs) => {
  const length2 = arrs.reduce((acc, cur) => {
    return acc + cur.length;
  }, 0);
  const flattened = new Uint8Array(length2);
  let offset = 0;
  arrs.forEach((arr) => {
    flattened.set(arr, offset);
    offset += arr.length;
  });
  return flattened;
};
var streamToBuffer = async (stream) => {
  const arrays = [];
  for await (const chunk of stream) {
    arrays.push(chunk);
  }
  return flattenUint8Arrays(arrays);
};
var S32_CHAR = "234567abcdefghijklmnopqrstuvwxyz";
var s32encode = (i) => {
  let s = "";
  while (i) {
    const c = i % 32;
    i = Math.floor(i / 32);
    s = S32_CHAR.charAt(c) + s;
  }
  return s;
};
var s32decode = (s) => {
  let i = 0;
  for (const c of s) {
    i = i * 32 + S32_CHAR.indexOf(c);
  }
  return i;
};

// ../common-web/src/tid.ts
var TID_LEN = 13;
var lastTimestamp = 0;
var timestampCount = 0;
var clockid = null;
function dedash(str) {
  return str.replaceAll("-", "");
}
var TID = class {
  constructor(str) {
    const noDashes = dedash(str);
    if (noDashes.length !== TID_LEN) {
      throw new Error(`Poorly formatted TID: ${noDashes.length} length`);
    }
    this.str = noDashes;
  }
  static next(prev) {
    const time = Math.max(Date.now(), lastTimestamp);
    if (time === lastTimestamp) {
      timestampCount++;
    }
    lastTimestamp = time;
    const timestamp = time * 1e3 + timestampCount;
    if (clockid === null) {
      clockid = Math.floor(Math.random() * 32);
    }
    const tid = TID.fromTime(timestamp, clockid);
    if (!prev || tid.newerThan(prev)) {
      return tid;
    }
    return TID.fromTime(prev.timestamp() + 1, clockid);
  }
  static nextStr(prev) {
    return TID.next(prev ? new TID(prev) : void 0).toString();
  }
  static fromTime(timestamp, clockid2) {
    const str = `${s32encode(timestamp)}${s32encode(clockid2).padStart(2, "2")}`;
    return new TID(str);
  }
  static fromStr(str) {
    return new TID(str);
  }
  static oldestFirst(a, b) {
    return a.compareTo(b);
  }
  static newestFirst(a, b) {
    return b.compareTo(a);
  }
  static is(str) {
    return dedash(str).length === TID_LEN;
  }
  timestamp() {
    return s32decode(this.str.slice(0, 11));
  }
  clockid() {
    return s32decode(this.str.slice(11, 13));
  }
  formatted() {
    const str = this.toString();
    return `${str.slice(0, 4)}-${str.slice(4, 7)}-${str.slice(7, 11)}-${str.slice(11, 13)}`;
  }
  toString() {
    return this.str;
  }
  compareTo(other) {
    if (this.str > other.str)
      return 1;
    if (this.str < other.str)
      return -1;
    return 0;
  }
  equals(other) {
    return this.str === other.str;
  }
  newerThan(other) {
    return this.compareTo(other) > 0;
  }
  olderThan(other) {
    return this.compareTo(other) < 0;
  }
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/varint.js
var encode_1 = encode;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode.bytes = offset - oldOffset + 1;
  return out;
}
var decode = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/varint.js
var decode2 = (data, offset = 0) => {
  const code4 = varint_default.decode(data, offset);
  return [
    code4,
    varint_default.decode.bytes
  ];
};
var encodeTo = (int, target2, offset = 0) => {
  varint_default.encode(int, target2, offset);
  return target2;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bytes.js
var empty = new Uint8Array(0);
var equals = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce2 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString = (str) => new TextEncoder().encode(str);
var toString = (b) => new TextDecoder().decode(b);

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/digest.js
var create = (code4, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength(code4);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes3 = new Uint8Array(digestOffset + size);
  encodeTo(code4, bytes3, 0);
  encodeTo(size, bytes3, sizeOffset);
  bytes3.set(digest2, digestOffset);
  return new Digest(code4, size, digest2, bytes3);
};
var decode3 = (multihash) => {
  const bytes3 = coerce2(multihash);
  const [code4, sizeOffset] = decode2(bytes3);
  const [size, digestOffset] = decode2(bytes3.subarray(sizeOffset));
  const digest2 = bytes3.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code4, size, digest2, bytes3);
};
var equals2 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
  }
};
var Digest = class {
  constructor(code4, size, digest2, bytes3) {
    this.code = code4;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes3;
  }
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/base-x.js
function base(ALPHABET, name3) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode9(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode9(string3) {
    var buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name3} character`);
  }
  return {
    encode: encode9,
    decodeUnsafe,
    decode: decode9
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base.js
var Encoder = class {
  constructor(name3, prefix, baseEncode) {
    this.name = name3;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes3) {
    if (bytes3 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes3)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  constructor(name3, prefix, baseDecode) {
    this.name = name3;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder2) {
    return or(this, decoder2);
  }
};
var ComposedDecoder = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder2) {
    return or(this, decoder2);
  }
  decode(input) {
    const prefix = input[0];
    const decoder2 = this.decoders[prefix];
    if (decoder2) {
      return decoder2.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec = class {
  constructor(name3, prefix, baseEncode, baseDecode) {
    this.name = name3;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name3, prefix, baseEncode);
    this.decoder = new Decoder(name3, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name: name3, prefix, encode: encode9, decode: decode9 }) => new Codec(name3, prefix, encode9, decode9);
var baseX = ({ prefix, name: name3, alphabet: alphabet2 }) => {
  const { encode: encode9, decode: decode9 } = base_x_default(alphabet2, name3);
  return from({
    prefix,
    name: name3,
    encode: encode9,
    decode: (text) => coerce2(decode9(text))
  });
};
var decode4 = (string3, alphabet2, bitsPerChar, name3) => {
  const codes = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    codes[alphabet2[i]] = i;
  }
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes[string3[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name3} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode2 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name3, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from({
    prefix,
    name: name3,
    encode(input) {
      return encode2(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode4(input, alphabet2, bitsPerChar, name3);
    }
  });
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/cid.js
var CID = class {
  constructor(version2, code4, multihash, bytes3) {
    this.code = code4;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes3;
    this.byteOffset = bytes3.byteOffset;
    this.byteLength = bytes3.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code4, multihash } = this;
        if (code4 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code4, digest: digest2 } = this.multihash;
        const multihash = create(code4, digest2);
        return CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes: bytes3, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0(bytes3, _baseCache, base3 || base58btc.encoder);
      default:
        return toStringV1(bytes3, _baseCache, base3 || base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code4, multihash, bytes: bytes3 } = value;
      return new CID(version2, code4, multihash, bytes3 || encodeCID(version2, code4, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const { version: version2, multihash, code: code4 } = value;
      const digest2 = decode3(multihash);
      return CID.create(version2, code4, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code4, digest2) {
    if (typeof code4 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code4 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new CID(version2, code4, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes3 = encodeCID(version2, code4, digest2.bytes);
        return new CID(version2, code4, digest2, bytes3);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return CID.create(0, DAG_PB_CODE, digest2);
  }
  static createV1(code4, digest2) {
    return CID.create(1, code4, digest2);
  }
  static decode(bytes3) {
    const [cid2, remainder] = CID.decodeFirst(bytes3);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid2;
  }
  static decodeFirst(bytes3) {
    const specs = CID.inspectBytes(bytes3);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce2(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid2 = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);
    return [
      cid2,
      bytes3.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length2] = decode2(initialBytes.subarray(offset));
      offset += length2;
      return i;
    };
    let version2 = next();
    let codec = DAG_PB_CODE;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base3) {
    const [prefix, bytes3] = parseCIDtoBytes(source, base3);
    const cid2 = CID.decode(bytes3);
    cid2._baseCache.set(prefix, source);
    return cid2;
  }
};
var parseCIDtoBytes = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder2 = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder2.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder2 = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder2.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder2 = base3 || base32;
      return [
        base32.prefix,
        decoder2.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes3, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid2 = cache.get(prefix);
  if (cid2 == null) {
    const cid3 = base3.encode(bytes3).slice(1);
    cache.set(prefix, cid3);
    return cid3;
  } else {
    return cid2;
  }
};
var toStringV1 = (bytes3, cache, base3) => {
  const { prefix } = base3;
  const cid2 = cache.get(prefix);
  if (cid2 == null) {
    const cid3 = base3.encode(bytes3);
    cache.set(prefix, cid3);
    return cid3;
  } else {
    return cid2;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID = (version2, code4, multihash) => {
  const codeOffset = encodingLength(version2);
  const hashOffset = codeOffset + encodingLength(code4);
  const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version2, bytes3, 0);
  encodeTo(code4, bytes3, codeOffset);
  bytes3.set(multihash, hashOffset);
  return bytes3;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version = "0.0.0-dev";
var deprecate = (range, message) => {
  if (range.test(version)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// ../../node_modules/.pnpm/uint8arrays@3.0.0/node_modules/uint8arrays/esm/src/equals.js
function equals3(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString(buf2),
  decode: (str) => fromString(str)
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode3(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode5(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode3,
  decode: decode5
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/sha2.js
var sha2_exports = {};
__export(sha2_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
var import_crypto = __toESM(require("crypto"), 1);

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/hasher.js
var from2 = ({ name: name3, code: code4, encode: encode9 }) => new Hasher(name3, code4, encode9);
var Hasher = class {
  constructor(name3, code4, encode9) {
    this.name = name3;
    this.code = code4;
    this.encode = encode9;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/sha2.js
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: (input) => coerce2(import_crypto.default.createHash("sha256").update(input).digest())
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: (input) => coerce2(import_crypto.default.createHash("sha512").update(input).digest())
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code = 0;
var name = "identity";
var encode4 = coerce2;
var digest = (input) => create(code, encode4(input));
var identity2 = {
  code,
  name,
  encode: encode4,
  digest
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/json.js
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/basics.js
var bases = {
  ...identity_exports,
  ...base2_exports,
  ...base8_exports,
  ...base10_exports,
  ...base16_exports,
  ...base32_exports,
  ...base36_exports,
  ...base58_exports,
  ...base64_exports,
  ...base256emoji_exports
};
var hashes = {
  ...sha2_exports,
  ...identity_exports2
};

// ../../node_modules/.pnpm/uint8arrays@3.0.0/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name3, prefix, encode9, decode9) {
  return {
    name: name3,
    prefix,
    encoder: {
      name: name3,
      prefix,
      encode: encode9
    },
    decoder: { decode: decode9 }
  };
}
var string = createCodec("utf8", "u", (buf2) => {
  const decoder2 = new TextDecoder("utf8");
  return "u" + decoder2.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf2) => {
  let string3 = "a";
  for (let i = 0; i < buf2.length; i++) {
    string3 += String.fromCharCode(buf2[i]);
  }
  return string3;
}, (str) => {
  str = str.substring(1);
  const buf2 = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    buf2[i] = str.charCodeAt(i);
  }
  return buf2;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// ../../node_modules/.pnpm/uint8arrays@3.0.0/node_modules/uint8arrays/esm/src/from-string.js
function fromString2(string3, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base3.decoder.decode(`${base3.prefix}${string3}`);
}

// ../../node_modules/.pnpm/uint8arrays@3.0.0/node_modules/uint8arrays/esm/src/to-string.js
function toString2(array2, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base3.encoder.encode(array2).substring(1);
}

// ../common-web/src/ipld.ts
var ipldToJson = (val) => {
  if (Array.isArray(val)) {
    return val.map((item) => ipldToJson(item));
  }
  if (val && typeof val === "object") {
    if (val instanceof Uint8Array) {
      return {
        $bytes: toString2(val, "base64")
      };
    }
    if (CID.asCID(val)) {
      return {
        $link: val.toString()
      };
    }
    const toReturn = {};
    for (const key of Object.keys(val)) {
      toReturn[key] = ipldToJson(val[key]);
    }
    return toReturn;
  }
  return val;
};

// ../common-web/src/types.ts
var cidSchema = z.any().refine((obj) => CID.asCID(obj) !== null, {
  message: "Not a CID"
}).transform((obj) => CID.asCID(obj));
var schema = {
  cid: cidSchema,
  bytes: z.instanceof(Uint8Array),
  string: z.string(),
  array: z.array(z.unknown()),
  map: z.record(z.string(), z.unknown()),
  unknown: z.unknown()
};
var def = {
  cid: {
    name: "cid",
    schema: schema.cid
  },
  bytes: {
    name: "bytes",
    schema: schema.bytes
  },
  string: {
    name: "string",
    schema: schema.string
  },
  map: {
    name: "map",
    schema: schema.map
  },
  unknown: {
    name: "unknown",
    schema: schema.unknown
  }
};

// ../common-web/src/times.ts
var SECOND = 1e3;
var MINUTE = SECOND * 60;
var HOUR = MINUTE * 60;
var DAY = HOUR * 24;

// ../common-web/src/strings.ts
var import_graphemer = __toESM(require_lib());

// ../common-web/src/did-doc.ts
var verificationMethod = z.object({
  id: z.string(),
  type: z.string(),
  controller: z.string(),
  publicKeyMultibase: z.string().optional()
});
var service = z.object({
  id: z.string(),
  type: z.string(),
  serviceEndpoint: z.union([z.string(), z.record(z.unknown())])
});
var didDocument = z.object({
  id: z.string(),
  alsoKnownAs: z.array(z.string()).optional(),
  verificationMethod: z.array(verificationMethod).optional(),
  service: z.array(service).optional()
});

// ../lexicon/src/validators/formats.ts
var import_iso_datestring_validator = __toESM(require_dist());

// ../lexicon/src/blob-refs.ts
var typedJsonBlobRef = z.object({
  $type: z.literal("blob"),
  ref: schema.cid,
  mimeType: z.string(),
  size: z.number()
}).strict();
var untypedJsonBlobRef = z.object({
  cid: z.string(),
  mimeType: z.string()
}).strict();
var jsonBlobRef = z.union([typedJsonBlobRef, untypedJsonBlobRef]);
var BlobRef = class {
  constructor(ref, mimeType, size, original) {
    this.ref = ref;
    this.mimeType = mimeType;
    this.size = size;
    this.original = original ?? {
      $type: "blob",
      ref,
      mimeType,
      size
    };
  }
  static asBlobRef(obj) {
    if (check_exports.is(obj, jsonBlobRef)) {
      return BlobRef.fromJsonRef(obj);
    }
    return null;
  }
  static fromJsonRef(json) {
    if (check_exports.is(json, typedJsonBlobRef)) {
      return new BlobRef(json.ref, json.mimeType, json.size);
    } else {
      return new BlobRef(CID.parse(json.cid), json.mimeType, -1, json);
    }
  }
  ipld() {
    return {
      $type: "blob",
      ref: this.ref,
      mimeType: this.mimeType,
      size: this.size
    };
  }
  toJSON() {
    return ipldToJson(this.ipld());
  }
};

// ../lexicon/src/util.ts
function requiredPropertiesRefinement(object2, ctx) {
  if (object2.required === void 0) {
    return;
  }
  if (!Array.isArray(object2.required)) {
    ctx.addIssue({
      code: z.ZodIssueCode.invalid_type,
      received: typeof object2.required,
      expected: "array"
    });
    return;
  }
  if (object2.properties === void 0) {
    if (object2.required.length > 0) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Required fields defined but no properties defined`
      });
    }
    return;
  }
  for (const field of object2.required) {
    if (object2.properties[field] === void 0) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Required field "${field}" not defined`
      });
    }
  }
}

// ../lexicon/src/types.ts
var lexBoolean = z.object({
  type: z.literal("boolean"),
  description: z.string().optional(),
  default: z.boolean().optional(),
  const: z.boolean().optional()
}).strict();
var lexInteger = z.object({
  type: z.literal("integer"),
  description: z.string().optional(),
  default: z.number().int().optional(),
  minimum: z.number().int().optional(),
  maximum: z.number().int().optional(),
  enum: z.number().int().array().optional(),
  const: z.number().int().optional()
}).strict();
var lexStringFormat = z.enum([
  "datetime",
  "uri",
  "at-uri",
  "did",
  "handle",
  "at-identifier",
  "nsid",
  "cid",
  "language"
]);
var lexString = z.object({
  type: z.literal("string"),
  format: lexStringFormat.optional(),
  description: z.string().optional(),
  default: z.string().optional(),
  minLength: z.number().int().optional(),
  maxLength: z.number().int().optional(),
  minGraphemes: z.number().int().optional(),
  maxGraphemes: z.number().int().optional(),
  enum: z.string().array().optional(),
  const: z.string().optional(),
  knownValues: z.string().array().optional()
}).strict();
var lexUnknown = z.object({
  type: z.literal("unknown"),
  description: z.string().optional()
}).strict();
var lexPrimitive = z.discriminatedUnion("type", [
  lexBoolean,
  lexInteger,
  lexString,
  lexUnknown
]);
var lexBytes = z.object({
  type: z.literal("bytes"),
  description: z.string().optional(),
  maxLength: z.number().optional(),
  minLength: z.number().optional()
}).strict();
var lexCidLink = z.object({
  type: z.literal("cid-link"),
  description: z.string().optional()
}).strict();
var lexIpldType = z.discriminatedUnion("type", [lexBytes, lexCidLink]);
var lexRef = z.object({
  type: z.literal("ref"),
  description: z.string().optional(),
  ref: z.string()
}).strict();
var lexRefUnion = z.object({
  type: z.literal("union"),
  description: z.string().optional(),
  refs: z.string().array(),
  closed: z.boolean().optional()
}).strict();
var lexRefVariant = z.discriminatedUnion("type", [lexRef, lexRefUnion]);
var lexBlob = z.object({
  type: z.literal("blob"),
  description: z.string().optional(),
  accept: z.string().array().optional(),
  maxSize: z.number().optional()
}).strict();
var lexArray = z.object({
  type: z.literal("array"),
  description: z.string().optional(),
  items: z.union([lexPrimitive, lexIpldType, lexBlob, lexRefVariant]),
  minLength: z.number().int().optional(),
  maxLength: z.number().int().optional()
}).strict();
var lexPrimitiveArray = lexArray.merge(z.object({
  items: lexPrimitive
}).strict());
var lexToken = z.object({
  type: z.literal("token"),
  description: z.string().optional()
}).strict();
var lexObject = z.object({
  type: z.literal("object"),
  description: z.string().optional(),
  required: z.string().array().optional(),
  nullable: z.string().array().optional(),
  properties: z.record(z.union([lexRefVariant, lexIpldType, lexArray, lexBlob, lexPrimitive]))
}).strict().superRefine(requiredPropertiesRefinement);
var lexXrpcParameters = z.object({
  type: z.literal("params"),
  description: z.string().optional(),
  required: z.string().array().optional(),
  properties: z.record(z.union([lexPrimitive, lexPrimitiveArray]))
}).strict().superRefine(requiredPropertiesRefinement);
var lexXrpcBody = z.object({
  description: z.string().optional(),
  encoding: z.string(),
  schema: z.union([lexRefVariant, lexObject]).optional()
}).strict();
var lexXrpcSubscriptionMessage = z.object({
  description: z.string().optional(),
  schema: z.union([lexRefVariant, lexObject]).optional()
}).strict();
var lexXrpcError = z.object({
  name: z.string(),
  description: z.string().optional()
}).strict();
var lexXrpcQuery = z.object({
  type: z.literal("query"),
  description: z.string().optional(),
  parameters: lexXrpcParameters.optional(),
  output: lexXrpcBody.optional(),
  errors: lexXrpcError.array().optional()
}).strict();
var lexXrpcProcedure = z.object({
  type: z.literal("procedure"),
  description: z.string().optional(),
  parameters: lexXrpcParameters.optional(),
  input: lexXrpcBody.optional(),
  output: lexXrpcBody.optional(),
  errors: lexXrpcError.array().optional()
}).strict();
var lexXrpcSubscription = z.object({
  type: z.literal("subscription"),
  description: z.string().optional(),
  parameters: lexXrpcParameters.optional(),
  message: lexXrpcSubscriptionMessage.optional(),
  errors: lexXrpcError.array().optional()
}).strict();
var lexRecord = z.object({
  type: z.literal("record"),
  description: z.string().optional(),
  key: z.string().optional(),
  record: lexObject
}).strict();
var lexUserType = z.custom((val) => {
  if (!val || typeof val !== "object") {
    return;
  }
  if (val["type"] === void 0) {
    return;
  }
  switch (val["type"]) {
    case "record":
      return lexRecord.parse(val);
    case "query":
      return lexXrpcQuery.parse(val);
    case "procedure":
      return lexXrpcProcedure.parse(val);
    case "subscription":
      return lexXrpcSubscription.parse(val);
    case "blob":
      return lexBlob.parse(val);
    case "array":
      return lexArray.parse(val);
    case "token":
      return lexToken.parse(val);
    case "object":
      return lexObject.parse(val);
    case "boolean":
      return lexBoolean.parse(val);
    case "integer":
      return lexInteger.parse(val);
    case "string":
      return lexString.parse(val);
    case "bytes":
      return lexBytes.parse(val);
    case "cid-link":
      return lexCidLink.parse(val);
    case "unknown":
      return lexUnknown.parse(val);
  }
}, (val) => {
  if (!val || typeof val !== "object") {
    return {
      message: "Must be an object",
      fatal: true
    };
  }
  if (val["type"] === void 0) {
    return {
      message: "Must have a type",
      fatal: true
    };
  }
  return {
    message: `Invalid type: ${val["type"]} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
    fatal: true
  };
});
var lexiconDoc = z.object({
  lexicon: z.literal(1),
  id: z.string().refine((v) => NSID.isValid(v), {
    message: "Must be a valid NSID"
  }),
  revision: z.number().optional(),
  description: z.string().optional(),
  defs: z.record(lexUserType)
}).strict().superRefine((doc, ctx) => {
  for (const defId in doc.defs) {
    const def3 = doc.defs[defId];
    if (defId !== "main" && (def3.type === "record" || def3.type === "procedure" || def3.type === "query" || def3.type === "subscription")) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Records, procedures, queries, and subscriptions must be the main definition.`
      });
    }
  }
});
var discriminatedObject = z.object({ $type: z.string() });

// ../lexicon/src/serialize.ts
var lexToIpld = (val) => {
  if (Array.isArray(val)) {
    return val.map((item) => lexToIpld(item));
  }
  if (val && typeof val === "object") {
    if (val instanceof BlobRef) {
      return val.original;
    }
    if (CID.asCID(val) || val instanceof Uint8Array) {
      return val;
    }
    const toReturn = {};
    for (const key of Object.keys(val)) {
      toReturn[key] = lexToIpld(val[key]);
    }
    return toReturn;
  }
  return val;
};
var ipldToLex = (val) => {
  if (Array.isArray(val)) {
    return val.map((item) => ipldToLex(item));
  }
  if (val && typeof val === "object") {
    if ((val["$type"] === "blob" || typeof val["cid"] === "string" && typeof val["mimeType"] === "string") && check_exports.is(val, jsonBlobRef)) {
      return BlobRef.fromJsonRef(val);
    }
    if (CID.asCID(val) || val instanceof Uint8Array) {
      return val;
    }
    const toReturn = {};
    for (const key of Object.keys(val)) {
      toReturn[key] = ipldToLex(val[key]);
    }
    return toReturn;
  }
  return val;
};

// ../common/src/dates.ts
var import_iso_datestring_validator2 = __toESM(require_dist());

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/block.js
var readonly2 = ({ enumerable = true, configurable = false } = {}) => ({
  enumerable,
  configurable,
  writable: false
});
var links = function* (source, base3) {
  if (source == null)
    return;
  if (source instanceof Uint8Array)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base3,
      key
    ];
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          const cid2 = CID.asCID(element);
          if (cid2) {
            yield [
              elementPath.join("/"),
              cid2
            ];
          } else if (typeof element === "object") {
            yield* links(element, elementPath);
          }
        }
      } else {
        const cid2 = CID.asCID(value);
        if (cid2) {
          yield [
            path.join("/"),
            cid2
          ];
        } else {
          yield* links(value, path);
        }
      }
    }
  }
};
var tree = function* (source, base3) {
  if (source == null)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base3,
      key
    ];
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID.asCID(value)) {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          yield elementPath.join("/");
          if (typeof element === "object" && !CID.asCID(element)) {
            yield* tree(element, elementPath);
          }
        }
      } else {
        yield* tree(value, path);
      }
    }
  }
};
var get = (source, path) => {
  let node = source;
  for (const [index, key] of path.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid2 = CID.asCID(node);
    if (cid2) {
      return {
        value: cid2,
        remaining: path.slice(index + 1).join("/")
      };
    }
  }
  return { value: node };
};
var Block = class {
  constructor({ cid: cid2, bytes: bytes3, value }) {
    if (!cid2 || !bytes3 || typeof value === "undefined")
      throw new Error("Missing required argument");
    this.cid = cid2;
    this.bytes = bytes3;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly2(),
      bytes: readonly2(),
      value: readonly2(),
      asBlock: readonly2()
    });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path = "/") {
    return get(this.value, path.split("/").filter(Boolean));
  }
};
var encode5 = async ({ value, codec, hasher }) => {
  if (typeof value === "undefined")
    throw new Error('Missing required argument "value"');
  if (!codec || !hasher)
    throw new Error("Missing required argument: codec or hasher");
  const bytes3 = codec.encode(value);
  const hash2 = await hasher.digest(bytes3);
  const cid2 = CID.create(1, codec.code, hash2);
  return new Block({
    value,
    bytes: bytes3,
    cid: cid2
  });
};

// ../../node_modules/.pnpm/@ipld+dag-cbor@7.0.3/node_modules/@ipld/dag-cbor/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  code: () => code2,
  decode: () => decode7,
  encode: () => encode7,
  name: () => name2
});

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/is.js
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is2(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType2 = getObjectType(value);
  if (objectType2) {
    return objectType2;
  }
  return "Object";
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/token.js
var Type = class {
  constructor(major, name3, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name3;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/byte-utils.js
var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
var textDecoder2 = new TextDecoder();
var textEncoder2 = new TextEncoder();
function isBuffer2(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
var toString3 = useBuffer ? (bytes3, start, end) => {
  return end - start > 64 ? globalThis.Buffer.from(bytes3.subarray(start, end)).toString("utf8") : utf8Slice(bytes3, start, end);
} : (bytes3, start, end) => {
  return end - start > 64 ? textDecoder2.decode(bytes3.subarray(start, end)) : utf8Slice(bytes3, start, end);
};
var fromString3 = useBuffer ? (string3) => {
  return string3.length > 64 ? globalThis.Buffer.from(string3) : utf8ToBytes(string3);
} : (string3) => {
  return string3.length > 64 ? textEncoder2.encode(string3) : utf8ToBytes(string3);
};
var fromArray = (arr) => {
  return Uint8Array.from(arr);
};
var slice = useBuffer ? (bytes3, start, end) => {
  if (isBuffer2(bytes3)) {
    return new Uint8Array(bytes3.subarray(start, end));
  }
  return bytes3.slice(start, end);
} : (bytes3, start, end) => {
  return bytes3.slice(start, end);
};
var concat2 = useBuffer ? (chunks, length2) => {
  chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
  return asU8A(globalThis.Buffer.concat(chunks, length2));
} : (chunks, length2) => {
  const out = new Uint8Array(length2);
  let off = 0;
  for (let b of chunks) {
    if (off + b.length > out.length) {
      b = b.subarray(0, out.length - off);
    }
    out.set(b, off);
    off += b.length;
  }
  return out;
};
var alloc = useBuffer ? (size) => {
  return globalThis.Buffer.allocUnsafe(size);
} : (size) => {
  return new Uint8Array(size);
};
function compare2(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string3, units = Infinity) {
  let codePoint;
  const length2 = string3.length;
  let leadSurrogate = null;
  const bytes3 = [];
  for (let i = 0; i < length2; ++i) {
    codePoint = string3.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
          continue;
        } else if (i + 1 === length2) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes3.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes3.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes3.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes3.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes3.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes3.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes3;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/bl.js
var defaultChunkSize = 256;
var Bl = class {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes3) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes3.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes3, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes3.length < 64 && bytes3.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes3, 0);
      } else {
        this.chunks.push(bytes3);
        this.maxCursor += bytes3.length;
      }
    }
    this.cursor += bytes3.length;
  }
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat2(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/common.js
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/0uint.js
var uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf2.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/1negint.js
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/2bytes.js
function toToken(data, pos, prefix, length2) {
  assertEnoughData(data, pos, prefix + length2);
  const buf2 = slice(data, pos + prefix, pos + prefix + length2);
  return new Token(Type.bytes, buf2, prefix + length2);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString3(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes3 = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes3.length);
  buf2.push(bytes3);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes3 = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes3.length) + bytes3.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare2(b1, b2);
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/3string.js
function toToken2(data, pos, prefix, length2, options) {
  const totLength = prefix + length2;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString3(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
var encodeString = encodeBytes;

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/4array.js
function toToken3(_data, _pos, prefix, length2) {
  return new Token(Type.array, length2, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/5map.js
function toToken4(_data, _pos, prefix, length2) {
  return new Token(Type.map, length2, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/7float.js
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes3, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes3);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
var jump = [];
for (let i = 0; i <= 23; i++) {
  jump[i] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i = 32; i <= 55; i++) {
  jump[i] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i = 64; i <= 87; i++) {
  jump[i] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i = 96; i <= 119; i++) {
  jump[i] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i = 128; i <= 151; i++) {
  jump[i] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i = 160; i <= 183; i++) {
  jump[i] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i = 192; i <= 215; i++) {
  jump[i] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i = 224; i <= 243; i++) {
  jump[i] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i = 0; i < 24; i++) {
  quick[i] = new Token(Type.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick[31 - i] = new Token(Type.negint, i, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/encode.js
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class {
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token(Type.array, obj.length),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length2 = isMap ? obj.size : keys.length;
    if (!length2) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key of keys) {
      entries[i++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token(Type.map, length2),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.map, length2),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is2(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size = encoder.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode6(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/decode.js
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder2 = jump[byt];
      if (!decoder2) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder2(this.data, this.pos, minor, this.options);
    }
    this.pos += token.encodedLength;
    return token;
  }
};
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode6(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}

// ../../node_modules/.pnpm/@ipld+dag-cbor@7.0.3/node_modules/@ipld/dag-cbor/esm/index.js
var CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid2 = CID.asCID(obj);
  if (!cid2) {
    return null;
  }
  const bytes3 = new Uint8Array(cid2.bytes.byteLength + 1);
  bytes3.set(cid2.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes3)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes3) {
  if (bytes3[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes3.subarray(1));
}
var decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var name2 = "dag-cbor";
var code2 = 113;
var encode7 = (node) => encode6(node, encodeOptions);
var decode7 = (data) => decode6(data, decodeOptions);

// ../common/src/ipld.ts
var cborDecode = decode7;
var dataToCborBlock = async (data) => {
  return encode5({
    value: data,
    codec: esm_exports,
    hasher: sha256
  });
};
var cidForCbor = async (data) => {
  const block = await dataToCborBlock(data);
  return block.cid;
};
var verifyCidForBytes = async (cid2, bytes3) => {
  const digest2 = await sha256.digest(bytes3);
  const expected = CID.createV1(cid2.code, digest2);
  if (!cid2.equals(expected)) {
    throw new Error(`Not a valid CID for bytes. Expected: ${expected.toString()} Got: ${cid2.toString()}`);
  }
};

// ../../node_modules/.pnpm/cbor-x@1.5.1/node_modules/cbor-x/decode.js
var decoder;
try {
  decoder = new TextDecoder();
} catch (error) {
}
var src2;
var srcEnd;
var position = 0;
var EMPTY_ARRAY = [];
var LEGACY_RECORD_INLINE_ID = 105;
var RECORD_DEFINITIONS_ID = 57342;
var RECORD_INLINE_ID = 57343;
var BUNDLED_STRINGS_ID = 57337;
var PACKED_REFERENCE_TAG_ID = 6;
var STOP_CODE = {};
var strings = EMPTY_ARRAY;
var stringPosition = 0;
var currentDecoder = {};
var currentStructures;
var srcString;
var srcStringStart = 0;
var srcStringEnd = 0;
var bundledStrings;
var referenceMap;
var currentExtensions = [];
var currentExtensionRanges = [];
var packedValues;
var dataView2;
var restoreMapsAsObject;
var defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};
var sequentialMode = false;
var Decoder2 = class {
  constructor(options) {
    if (options) {
      if ((options.keyMap || options._keyMap) && !options.useRecords) {
        options.useRecords = false;
        options.mapsAsObjects = true;
      }
      if (options.useRecords === false && options.mapsAsObjects === void 0)
        options.mapsAsObjects = true;
      if (options.getStructures)
        options.getShared = options.getStructures;
      if (options.getShared && !options.structures)
        (options.structures = []).uninitialized = true;
      if (options.keyMap) {
        this.mapKey = /* @__PURE__ */ new Map();
        for (let [k, v] of Object.entries(options.keyMap))
          this.mapKey.set(v, k);
      }
    }
    Object.assign(this, options);
  }
  decodeKey(key) {
    return this.keyMap ? this.mapKey.get(key) || key : key;
  }
  encodeKey(key) {
    return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key;
  }
  encodeKeys(rec) {
    if (!this._keyMap)
      return rec;
    let map = /* @__PURE__ */ new Map();
    for (let [k, v] of Object.entries(rec))
      map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);
    return map;
  }
  decodeKeys(map) {
    if (!this._keyMap || map.constructor.name != "Map")
      return map;
    if (!this._mapKey) {
      this._mapKey = /* @__PURE__ */ new Map();
      for (let [k, v] of Object.entries(this._keyMap))
        this._mapKey.set(v, k);
    }
    let res = {};
    map.forEach((v, k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v);
    return res;
  }
  mapDecode(source, end) {
    let res = this.decode(source);
    if (this._keyMap) {
      switch (res.constructor.name) {
        case "Array":
          return res.map((r) => this.decodeKeys(r));
      }
    }
    return res;
  }
  decode(source, end) {
    if (src2) {
      return saveState(() => {
        clearSource();
        return this ? this.decode(source, end) : Decoder2.prototype.decode.call(defaultOptions, source, end);
      });
    }
    srcEnd = end > -1 ? end : source.length;
    position = 0;
    stringPosition = 0;
    srcStringEnd = 0;
    srcString = null;
    strings = EMPTY_ARRAY;
    bundledStrings = null;
    src2 = source;
    try {
      dataView2 = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error) {
      src2 = null;
      if (source instanceof Uint8Array)
        throw error;
      throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
    }
    if (this instanceof Decoder2) {
      currentDecoder = this;
      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
      if (this.structures) {
        currentStructures = this.structures;
        return checkedRead();
      } else if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentDecoder = defaultOptions;
      if (!currentStructures || currentStructures.length > 0)
        currentStructures = [];
      packedValues = null;
    }
    return checkedRead();
  }
  decodeMultiple(source, forEach) {
    let values, lastPosition = 0;
    try {
      let size = source.length;
      sequentialMode = true;
      let value = this ? this.decode(source, size) : defaultDecoder.decode(source, size);
      if (forEach) {
        if (forEach(value) === false) {
          return;
        }
        while (position < size) {
          lastPosition = position;
          if (forEach(checkedRead()) === false) {
            return;
          }
        }
      } else {
        values = [value];
        while (position < size) {
          lastPosition = position;
          values.push(checkedRead());
        }
        return values;
      }
    } catch (error) {
      error.lastPosition = lastPosition;
      error.values = values;
      throw error;
    } finally {
      sequentialMode = false;
      clearSource();
    }
  }
};
function checkedRead() {
  try {
    let result = read2();
    if (bundledStrings) {
      if (position >= bundledStrings.postBundlePosition) {
        let error = new Error("Unexpected bundle position");
        error.incomplete = true;
        throw error;
      }
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (position == srcEnd) {
      currentStructures = null;
      src2 = null;
      if (referenceMap)
        referenceMap = null;
    } else if (position > srcEnd) {
      let error = new Error("Unexpected end of CBOR data");
      error.incomplete = true;
      throw error;
    } else if (!sequentialMode) {
      throw new Error("Data read, but end of buffer not reached");
    }
    return result;
  } catch (error) {
    clearSource();
    if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
      error.incomplete = true;
    }
    throw error;
  }
}
function read2() {
  let token = src2[position++];
  let majorType = token >> 5;
  token = token & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src2[position++];
        break;
      case 25:
        if (majorType == 7) {
          return getFloat16();
        }
        token = dataView2.getUint16(position);
        position += 2;
        break;
      case 26:
        if (majorType == 7) {
          let value = dataView2.getFloat32(position);
          if (currentDecoder.useFloat32 > 2) {
            let multiplier = mult10[(src2[position] & 127) << 1 | src2[position + 1] >> 7];
            position += 4;
            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
          }
          position += 4;
          return value;
        }
        token = dataView2.getUint32(position);
        position += 4;
        break;
      case 27:
        if (majorType == 7) {
          let value = dataView2.getFloat64(position);
          position += 8;
          return value;
        }
        if (majorType > 1) {
          if (dataView2.getUint32(position) > 0)
            throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
          token = dataView2.getUint32(position + 4);
        } else if (currentDecoder.int64AsNumber) {
          token = dataView2.getUint32(position) * 4294967296;
          token += dataView2.getUint32(position + 4);
        } else
          token = dataView2.getBigUint64(position);
        position += 8;
        break;
      case 31:
        switch (majorType) {
          case 2:
          case 3:
            throw new Error("Indefinite length not supported for byte or text strings");
          case 4:
            let array2 = [];
            let value, i = 0;
            while ((value = read2()) != STOP_CODE) {
              array2[i++] = value;
            }
            return majorType == 4 ? array2 : majorType == 3 ? array2.join("") : Buffer.concat(array2);
          case 5:
            let key;
            if (currentDecoder.mapsAsObjects) {
              let object2 = {};
              if (currentDecoder.keyMap)
                while ((key = read2()) != STOP_CODE)
                  object2[safeKey(currentDecoder.decodeKey(key))] = read2();
              else
                while ((key = read2()) != STOP_CODE)
                  object2[safeKey(key)] = read2();
              return object2;
            } else {
              if (restoreMapsAsObject) {
                currentDecoder.mapsAsObjects = true;
                restoreMapsAsObject = false;
              }
              let map = /* @__PURE__ */ new Map();
              if (currentDecoder.keyMap)
                while ((key = read2()) != STOP_CODE)
                  map.set(currentDecoder.decodeKey(key), read2());
              else
                while ((key = read2()) != STOP_CODE)
                  map.set(key, read2());
              return map;
            }
          case 7:
            return STOP_CODE;
          default:
            throw new Error("Invalid major type for indefinite length " + majorType);
        }
      default:
        throw new Error("Unknown token " + token);
    }
  }
  switch (majorType) {
    case 0:
      return token;
    case 1:
      return ~token;
    case 2:
      return readBin(token);
    case 3:
      if (srcStringEnd >= position) {
        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
      }
      if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
        let string3 = token < 16 ? shortStringInJS(token) : longStringInJS(token);
        if (string3 != null)
          return string3;
      }
      return readFixedString(token);
    case 4:
      let array2 = new Array(token);
      for (let i = 0; i < token; i++)
        array2[i] = read2();
      return array2;
    case 5:
      if (currentDecoder.mapsAsObjects) {
        let object2 = {};
        if (currentDecoder.keyMap)
          for (let i = 0; i < token; i++)
            object2[safeKey(currentDecoder.decodeKey(read2()))] = read2();
        else
          for (let i = 0; i < token; i++)
            object2[safeKey(read2())] = read2();
        return object2;
      } else {
        if (restoreMapsAsObject) {
          currentDecoder.mapsAsObjects = true;
          restoreMapsAsObject = false;
        }
        let map = /* @__PURE__ */ new Map();
        if (currentDecoder.keyMap)
          for (let i = 0; i < token; i++)
            map.set(currentDecoder.decodeKey(read2()), read2());
        else
          for (let i = 0; i < token; i++)
            map.set(read2(), read2());
        return map;
      }
    case 6:
      if (token >= BUNDLED_STRINGS_ID) {
        let structure = currentStructures[token & 8191];
        if (structure) {
          if (!structure.read)
            structure.read = createStructureReader(structure);
          return structure.read();
        }
        if (token < 65536) {
          if (token == RECORD_INLINE_ID) {
            let length2 = readJustLength();
            let id = read2();
            let structure2 = read2();
            recordDefinition(id, structure2);
            let object2 = {};
            if (currentDecoder.keyMap)
              for (let i = 2; i < length2; i++) {
                let key = currentDecoder.decodeKey(structure2[i - 2]);
                object2[safeKey(key)] = read2();
              }
            else
              for (let i = 2; i < length2; i++) {
                let key = structure2[i - 2];
                object2[safeKey(key)] = read2();
              }
            return object2;
          } else if (token == RECORD_DEFINITIONS_ID) {
            let length2 = readJustLength();
            let id = read2();
            for (let i = 2; i < length2; i++) {
              recordDefinition(id++, read2());
            }
            return read2();
          } else if (token == BUNDLED_STRINGS_ID) {
            return readBundleExt();
          }
          if (currentDecoder.getShared) {
            loadShared();
            structure = currentStructures[token & 8191];
            if (structure) {
              if (!structure.read)
                structure.read = createStructureReader(structure);
              return structure.read();
            }
          }
        }
      }
      let extension = currentExtensions[token];
      if (extension) {
        if (extension.handlesRead)
          return extension(read2);
        else
          return extension(read2());
      } else {
        let input = read2();
        for (let i = 0; i < currentExtensionRanges.length; i++) {
          let value = currentExtensionRanges[i](token, input);
          if (value !== void 0)
            return value;
        }
        return new Tag(input, token);
      }
    case 7:
      switch (token) {
        case 20:
          return false;
        case 21:
          return true;
        case 22:
          return null;
        case 23:
          return;
        case 31:
        default:
          let packedValue = (packedValues || getPackedValues())[token];
          if (packedValue !== void 0)
            return packedValue;
          throw new Error("Unknown token " + token);
      }
    default:
      if (isNaN(token)) {
        let error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      }
      throw new Error("Unknown CBOR token " + token);
  }
}
var validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure) {
  function readObject() {
    let length2 = src2[position++];
    length2 = length2 & 31;
    if (length2 > 23) {
      switch (length2) {
        case 24:
          length2 = src2[position++];
          break;
        case 25:
          length2 = dataView2.getUint16(position);
          position += 2;
          break;
        case 26:
          length2 = dataView2.getUint32(position);
          position += 4;
          break;
        default:
          throw new Error("Expected array header, but got " + src2[position - 1]);
      }
    }
    let compiledReader = this.compiledReader;
    while (compiledReader) {
      if (compiledReader.propertyCount === length2)
        return compiledReader(read2);
      compiledReader = compiledReader.next;
    }
    if (this.slowReads++ >= 3) {
      let array2 = this.length == length2 ? this : this.slice(0, length2);
      compiledReader = currentDecoder.keyMap ? new Function("r", "return {" + array2.map((k) => currentDecoder.decodeKey(k)).map((k) => validName.test(k) ? safeKey(k) + ":r()" : "[" + JSON.stringify(k) + "]:r()").join(",") + "}") : new Function("r", "return {" + array2.map((key) => validName.test(key) ? safeKey(key) + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "}");
      if (this.compiledReader)
        compiledReader.next = this.compiledReader;
      compiledReader.propertyCount = length2;
      this.compiledReader = compiledReader;
      return compiledReader(read2);
    }
    let object2 = {};
    if (currentDecoder.keyMap)
      for (let i = 0; i < length2; i++)
        object2[safeKey(currentDecoder.decodeKey(this[i]))] = read2();
    else
      for (let i = 0; i < length2; i++) {
        object2[safeKey(this[i])] = read2();
      }
    return object2;
  }
  structure.slowReads = 0;
  return readObject;
}
function safeKey(key) {
  return key === "__proto__" ? "__proto_" : key;
}
var readFixedString = readStringJS;
var readString8 = readStringJS;
var readString16 = readStringJS;
var readString32 = readStringJS;
var isNativeAccelerationEnabled = false;
function setExtractor(extractStrings) {
  isNativeAccelerationEnabled = true;
  readFixedString = readString(1);
  readString8 = readString(2);
  readString16 = readString(3);
  readString32 = readString(5);
  function readString(headerLength) {
    return function readString2(length2) {
      let string3 = strings[stringPosition++];
      if (string3 == null) {
        if (bundledStrings)
          return readStringJS(length2);
        let extraction = extractStrings(position, srcEnd, length2, src2);
        if (typeof extraction == "string") {
          string3 = extraction;
          strings = EMPTY_ARRAY;
        } else {
          strings = extraction;
          stringPosition = 1;
          srcStringEnd = 1;
          string3 = strings[0];
          if (string3 === void 0)
            throw new Error("Unexpected end of buffer");
        }
      }
      let srcStringLength = string3.length;
      if (srcStringLength <= length2) {
        position += length2;
        return string3;
      }
      srcString = string3;
      srcStringStart = position;
      srcStringEnd = position + srcStringLength;
      position += length2;
      return string3.slice(0, length2);
    };
  }
}
function readStringJS(length2) {
  let result;
  if (length2 < 16) {
    if (result = shortStringInJS(length2))
      return result;
  }
  if (length2 > 64 && decoder)
    return decoder.decode(src2.subarray(position, position += length2));
  const end = position + length2;
  const units = [];
  result = "";
  while (position < end) {
    const byte1 = src2[position++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = src2[position++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = src2[position++] & 63;
      const byte3 = src2[position++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = src2[position++] & 63;
      const byte3 = src2[position++] & 63;
      const byte4 = src2[position++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 4096) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
var fromCharCode = String.fromCharCode;
function longStringInJS(length2) {
  let start = position;
  let bytes3 = new Array(length2);
  for (let i = 0; i < length2; i++) {
    const byte = src2[position++];
    if ((byte & 128) > 0) {
      position = start;
      return;
    }
    bytes3[i] = byte;
  }
  return fromCharCode.apply(String, bytes3);
}
function shortStringInJS(length2) {
  if (length2 < 4) {
    if (length2 < 2) {
      if (length2 === 0)
        return "";
      else {
        let a = src2[position++];
        if ((a & 128) > 1) {
          position -= 1;
          return;
        }
        return fromCharCode(a);
      }
    } else {
      let a = src2[position++];
      let b = src2[position++];
      if ((a & 128) > 0 || (b & 128) > 0) {
        position -= 2;
        return;
      }
      if (length2 < 3)
        return fromCharCode(a, b);
      let c = src2[position++];
      if ((c & 128) > 0) {
        position -= 3;
        return;
      }
      return fromCharCode(a, b, c);
    }
  } else {
    let a = src2[position++];
    let b = src2[position++];
    let c = src2[position++];
    let d = src2[position++];
    if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
      position -= 4;
      return;
    }
    if (length2 < 6) {
      if (length2 === 4)
        return fromCharCode(a, b, c, d);
      else {
        let e = src2[position++];
        if ((e & 128) > 0) {
          position -= 5;
          return;
        }
        return fromCharCode(a, b, c, d, e);
      }
    } else if (length2 < 8) {
      let e = src2[position++];
      let f = src2[position++];
      if ((e & 128) > 0 || (f & 128) > 0) {
        position -= 6;
        return;
      }
      if (length2 < 7)
        return fromCharCode(a, b, c, d, e, f);
      let g = src2[position++];
      if ((g & 128) > 0) {
        position -= 7;
        return;
      }
      return fromCharCode(a, b, c, d, e, f, g);
    } else {
      let e = src2[position++];
      let f = src2[position++];
      let g = src2[position++];
      let h = src2[position++];
      if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
        position -= 8;
        return;
      }
      if (length2 < 10) {
        if (length2 === 8)
          return fromCharCode(a, b, c, d, e, f, g, h);
        else {
          let i = src2[position++];
          if ((i & 128) > 0) {
            position -= 9;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i);
        }
      } else if (length2 < 12) {
        let i = src2[position++];
        let j = src2[position++];
        if ((i & 128) > 0 || (j & 128) > 0) {
          position -= 10;
          return;
        }
        if (length2 < 11)
          return fromCharCode(a, b, c, d, e, f, g, h, i, j);
        let k = src2[position++];
        if ((k & 128) > 0) {
          position -= 11;
          return;
        }
        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
      } else {
        let i = src2[position++];
        let j = src2[position++];
        let k = src2[position++];
        let l = src2[position++];
        if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
          position -= 12;
          return;
        }
        if (length2 < 14) {
          if (length2 === 12)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
          else {
            let m = src2[position++];
            if ((m & 128) > 0) {
              position -= 13;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
          }
        } else {
          let m = src2[position++];
          let n = src2[position++];
          if ((m & 128) > 0 || (n & 128) > 0) {
            position -= 14;
            return;
          }
          if (length2 < 15)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
          let o = src2[position++];
          if ((o & 128) > 0) {
            position -= 15;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
        }
      }
    }
  }
}
function readBin(length2) {
  return currentDecoder.copyBuffers ? Uint8Array.prototype.slice.call(src2, position, position += length2) : src2.subarray(position, position += length2);
}
var f32Array = new Float32Array(1);
var u8Array = new Uint8Array(f32Array.buffer, 0, 4);
function getFloat16() {
  let byte0 = src2[position++];
  let byte1 = src2[position++];
  let exponent = (byte0 & 127) >> 2;
  if (exponent === 31) {
    if (byte1 || byte0 & 3)
      return NaN;
    return byte0 & 128 ? -Infinity : Infinity;
  }
  if (exponent === 0) {
    let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
    return byte0 & 128 ? -abs : abs;
  }
  u8Array[3] = byte0 & 128 | (exponent >> 1) + 56;
  u8Array[2] = (byte0 & 7) << 5 | byte1 >> 3;
  u8Array[1] = byte1 << 5;
  u8Array[0] = 0;
  return f32Array[0];
}
var keyCache = new Array(4096);
var Tag = class {
  constructor(value, tag) {
    this.value = value;
    this.tag = tag;
  }
};
currentExtensions[0] = (dateString) => {
  return new Date(dateString);
};
currentExtensions[1] = (epochSec) => {
  return new Date(Math.round(epochSec * 1e3));
};
currentExtensions[2] = (buffer2) => {
  let value = BigInt(0);
  for (let i = 0, l = buffer2.byteLength; i < l; i++) {
    value = BigInt(buffer2[i]) + value << BigInt(8);
  }
  return value;
};
currentExtensions[3] = (buffer2) => {
  return BigInt(-1) - currentExtensions[2](buffer2);
};
currentExtensions[4] = (fraction) => {
  return +(fraction[1] + "e" + fraction[0]);
};
currentExtensions[5] = (fraction) => {
  return fraction[1] * Math.exp(fraction[0] * Math.log(2));
};
var recordDefinition = (id, structure) => {
  id = id - 57344;
  let existingStructure = currentStructures[id];
  if (existingStructure && existingStructure.isShared) {
    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
  }
  currentStructures[id] = structure;
  structure.read = createStructureReader(structure);
};
currentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {
  let length2 = data.length;
  let structure = data[1];
  recordDefinition(data[0], structure);
  let object2 = {};
  for (let i = 2; i < length2; i++) {
    let key = structure[i - 2];
    object2[safeKey(key)] = data[i];
  }
  return object2;
};
currentExtensions[14] = (value) => {
  if (bundledStrings)
    return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
  return new Tag(value, 14);
};
currentExtensions[15] = (value) => {
  if (bundledStrings)
    return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
  return new Tag(value, 15);
};
var glbl = { Error, RegExp };
currentExtensions[27] = (data) => {
  return (glbl[data[0]] || Error)(data[1], data[2]);
};
var packedTable = (read3) => {
  if (src2[position++] != 132)
    throw new Error("Packed values structure must be followed by a 4 element array");
  let newPackedValues = read3();
  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
  packedValues.prefixes = read3();
  packedValues.suffixes = read3();
  return read3();
};
packedTable.handlesRead = true;
currentExtensions[51] = packedTable;
currentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {
  if (!packedValues) {
    if (currentDecoder.getShared)
      loadShared();
    else
      return new Tag(data, PACKED_REFERENCE_TAG_ID);
  }
  if (typeof data == "number")
    return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
  throw new Error("No support for non-integer packed references yet");
};
currentExtensions[28] = (read3) => {
  if (!referenceMap) {
    referenceMap = /* @__PURE__ */ new Map();
    referenceMap.id = 0;
  }
  let id = referenceMap.id++;
  let token = src2[position];
  let target2;
  if (token >> 5 == 4)
    target2 = [];
  else
    target2 = {};
  let refEntry = { target: target2 };
  referenceMap.set(id, refEntry);
  let targetProperties = read3();
  if (refEntry.used)
    return Object.assign(target2, targetProperties);
  refEntry.target = targetProperties;
  return targetProperties;
};
currentExtensions[28].handlesRead = true;
currentExtensions[29] = (id) => {
  let refEntry = referenceMap.get(id);
  refEntry.used = true;
  return refEntry.target;
};
currentExtensions[258] = (array2) => new Set(array2);
(currentExtensions[259] = (read3) => {
  if (currentDecoder.mapsAsObjects) {
    currentDecoder.mapsAsObjects = false;
    restoreMapsAsObject = true;
  }
  return read3();
}).handlesRead = true;
function combine(a, b) {
  if (typeof a === "string")
    return a + b;
  if (a instanceof Array)
    return a.concat(b);
  return Object.assign({}, a, b);
}
function getPackedValues() {
  if (!packedValues) {
    if (currentDecoder.getShared)
      loadShared();
    else
      throw new Error("No packed values available");
  }
  return packedValues;
}
var SHARED_DATA_TAG_ID = 1399353956;
currentExtensionRanges.push((tag, input) => {
  if (tag >= 225 && tag <= 255)
    return combine(getPackedValues().prefixes[tag - 224], input);
  if (tag >= 28704 && tag <= 32767)
    return combine(getPackedValues().prefixes[tag - 28672], input);
  if (tag >= 1879052288 && tag <= 2147483647)
    return combine(getPackedValues().prefixes[tag - 1879048192], input);
  if (tag >= 216 && tag <= 223)
    return combine(input, getPackedValues().suffixes[tag - 216]);
  if (tag >= 27647 && tag <= 28671)
    return combine(input, getPackedValues().suffixes[tag - 27639]);
  if (tag >= 1811940352 && tag <= 1879048191)
    return combine(input, getPackedValues().suffixes[tag - 1811939328]);
  if (tag == SHARED_DATA_TAG_ID) {
    return {
      packedValues,
      structures: currentStructures.slice(0),
      version: input
    };
  }
  if (tag == 55799)
    return input;
});
var isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
var typedArrays = [
  Uint8Array,
  Uint8ClampedArray,
  Uint16Array,
  Uint32Array,
  typeof BigUint64Array == "undefined" ? { name: "BigUint64Array" } : BigUint64Array,
  Int8Array,
  Int16Array,
  Int32Array,
  typeof BigInt64Array == "undefined" ? { name: "BigInt64Array" } : BigInt64Array,
  Float32Array,
  Float64Array
];
var typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];
for (let i = 0; i < typedArrays.length; i++) {
  registerTypedArray(typedArrays[i], typedArrayTags[i]);
}
function registerTypedArray(TypedArray, tag) {
  let dvMethod = "get" + TypedArray.name.slice(0, -5);
  if (typeof TypedArray !== "function")
    TypedArray = null;
  let bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
    if (!littleEndian && bytesPerElement == 1)
      continue;
    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? (buffer2) => {
      if (!TypedArray)
        throw new Error("Could not find typed array for code " + tag);
      return new TypedArray(Uint8Array.prototype.slice.call(buffer2, 0).buffer);
    } : (buffer2) => {
      if (!TypedArray)
        throw new Error("Could not find typed array for code " + tag);
      let dv = new DataView(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
      let elements = buffer2.length >> sizeShift;
      let ta = new TypedArray(elements);
      let method = dv[dvMethod];
      for (let i = 0; i < elements; i++) {
        ta[i] = method.call(dv, i << sizeShift, littleEndian);
      }
      return ta;
    };
  }
}
function readBundleExt() {
  let length2 = readJustLength();
  let bundlePosition = position + read2();
  for (let i = 2; i < length2; i++) {
    let bundleLength = readJustLength();
    position += bundleLength;
  }
  let dataPosition = position;
  position = bundlePosition;
  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];
  bundledStrings.position0 = 0;
  bundledStrings.position1 = 0;
  bundledStrings.postBundlePosition = position;
  position = dataPosition;
  return read2();
}
function readJustLength() {
  let token = src2[position++] & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src2[position++];
        break;
      case 25:
        token = dataView2.getUint16(position);
        position += 2;
        break;
      case 26:
        token = dataView2.getUint32(position);
        position += 4;
        break;
    }
  }
  return token;
}
function loadShared() {
  if (currentDecoder.getShared) {
    let sharedData = saveState(() => {
      src2 = null;
      return currentDecoder.getShared();
    }) || {};
    let updatedStructures = sharedData.structures || [];
    currentDecoder.sharedVersion = sharedData.version;
    packedValues = currentDecoder.sharedValues = sharedData.packedValues;
    if (currentStructures === true)
      currentDecoder.structures = currentStructures = updatedStructures;
    else
      currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
  }
}
function saveState(callback) {
  let savedSrcEnd = srcEnd;
  let savedPosition = position;
  let savedStringPosition = stringPosition;
  let savedSrcStringStart = srcStringStart;
  let savedSrcStringEnd = srcStringEnd;
  let savedSrcString = srcString;
  let savedStrings = strings;
  let savedReferenceMap = referenceMap;
  let savedBundledStrings = bundledStrings;
  let savedSrc = new Uint8Array(src2.slice(0, srcEnd));
  let savedStructures = currentStructures;
  let savedDecoder = currentDecoder;
  let savedSequentialMode = sequentialMode;
  let value = callback();
  srcEnd = savedSrcEnd;
  position = savedPosition;
  stringPosition = savedStringPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  strings = savedStrings;
  referenceMap = savedReferenceMap;
  bundledStrings = savedBundledStrings;
  src2 = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentDecoder = savedDecoder;
  dataView2 = new DataView(src2.buffer, src2.byteOffset, src2.byteLength);
  return value;
}
function clearSource() {
  src2 = null;
  referenceMap = null;
  currentStructures = null;
}
function addExtension(extension) {
  currentExtensions[extension.tag] = extension.decode;
}
var mult10 = new Array(147);
for (let i = 0; i < 256; i++) {
  mult10[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
}
var defaultDecoder = new Decoder2({ useRecords: false });
var decode8 = defaultDecoder.decode;
var decodeMultiple = defaultDecoder.decodeMultiple;
var FLOAT32_OPTIONS = {
  NEVER: 0,
  ALWAYS: 1,
  DECIMAL_ROUND: 3,
  DECIMAL_FIT: 4
};

// ../../node_modules/.pnpm/cbor-x@1.5.1/node_modules/cbor-x/encode.js
var textEncoder3;
try {
  textEncoder3 = new TextEncoder();
} catch (error) {
}
var extensions;
var extensionClasses;
var Buffer2 = globalThis.Buffer;
var hasNodeBuffer = typeof Buffer2 !== "undefined";
var ByteArrayAllocate = hasNodeBuffer ? Buffer2.allocUnsafeSlow : Uint8Array;
var ByteArray = hasNodeBuffer ? Buffer2 : Uint8Array;
var MAX_STRUCTURES = 256;
var MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
var throwOnIterable;
var target;
var targetView;
var position2 = 0;
var safeEnd;
var bundledStrings2 = null;
var MAX_BUNDLE_SIZE = 61440;
var hasNonLatin = /[\u0080-\uFFFF]/;
var RECORD_SYMBOL = Symbol("record-id");
var Encoder2 = class extends Decoder2 {
  constructor(options) {
    super(options);
    this.offset = 0;
    let typeBuffer;
    let start;
    let sharedStructures;
    let hasSharedUpdate;
    let structures;
    let referenceMap2;
    options = options || {};
    let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string3, position3, maxBytes) {
      return target.utf8Write(string3, position3, maxBytes);
    } : textEncoder3 && textEncoder3.encodeInto ? function(string3, position3) {
      return textEncoder3.encodeInto(string3, target.subarray(position3)).written;
    } : false;
    let encoder = this;
    let hasSharedStructures = options.structures || options.saveStructures;
    let maxSharedStructures = options.maxSharedStructures;
    if (maxSharedStructures == null)
      maxSharedStructures = hasSharedStructures ? 128 : 0;
    if (maxSharedStructures > 8190)
      throw new Error("Maximum maxSharedStructure is 8190");
    let isSequential = options.sequential;
    if (isSequential) {
      maxSharedStructures = 0;
    }
    if (!this.structures)
      this.structures = [];
    if (this.saveStructures)
      this.saveShared = this.saveStructures;
    let samplingPackedValues, packedObjectMap2, sharedValues = options.sharedValues;
    let sharedPackedObjectMap2;
    if (sharedValues) {
      sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
      for (let i = 0, l = sharedValues.length; i < l; i++) {
        sharedPackedObjectMap2[sharedValues[i]] = i;
      }
    }
    let recordIdsToRemove = [];
    let transitionsCount = 0;
    let serializationsSinceTransitionRebuild = 0;
    this.mapEncode = function(value, encodeOptions2) {
      if (this._keyMap && !this._mapped) {
        switch (value.constructor.name) {
          case "Array":
            value = value.map((r) => this.encodeKeys(r));
            break;
        }
      }
      return this.encode(value, encodeOptions2);
    };
    this.encode = function(value, encodeOptions2) {
      if (!target) {
        target = new ByteArrayAllocate(8192);
        targetView = new DataView(target.buffer, 0, 8192);
        position2 = 0;
      }
      safeEnd = target.length - 10;
      if (safeEnd - position2 < 2048) {
        target = new ByteArrayAllocate(target.length);
        targetView = new DataView(target.buffer, 0, target.length);
        safeEnd = target.length - 10;
        position2 = 0;
      } else if (encodeOptions2 === REUSE_BUFFER_MODE)
        position2 = position2 + 7 & 2147483640;
      start = position2;
      if (encoder.useSelfDescribedHeader) {
        targetView.setUint32(position2, 3654940416);
        position2 += 3;
      }
      referenceMap2 = encoder.structuredClone ? /* @__PURE__ */ new Map() : null;
      if (encoder.bundleStrings && typeof value !== "string") {
        bundledStrings2 = [];
        bundledStrings2.size = Infinity;
      } else
        bundledStrings2 = null;
      sharedStructures = encoder.structures;
      if (sharedStructures) {
        if (sharedStructures.uninitialized) {
          let sharedData = encoder.getShared() || {};
          encoder.structures = sharedStructures = sharedData.structures || [];
          encoder.sharedVersion = sharedData.version;
          let sharedValues2 = encoder.sharedValues = sharedData.packedValues;
          if (sharedValues2) {
            sharedPackedObjectMap2 = {};
            for (let i = 0, l = sharedValues2.length; i < l; i++)
              sharedPackedObjectMap2[sharedValues2[i]] = i;
          }
        }
        let sharedStructuresLength = sharedStructures.length;
        if (sharedStructuresLength > maxSharedStructures && !isSequential)
          sharedStructuresLength = maxSharedStructures;
        if (!sharedStructures.transitions) {
          sharedStructures.transitions = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < sharedStructuresLength; i++) {
            let keys = sharedStructures[i];
            if (!keys)
              continue;
            let nextTransition, transition = sharedStructures.transitions;
            for (let j = 0, l = keys.length; j < l; j++) {
              if (transition[RECORD_SYMBOL] === void 0)
                transition[RECORD_SYMBOL] = i;
              let key = keys[j];
              nextTransition = transition[key];
              if (!nextTransition) {
                nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
              }
              transition = nextTransition;
            }
            transition[RECORD_SYMBOL] = i | 1048576;
          }
        }
        if (!isSequential)
          sharedStructures.nextId = sharedStructuresLength;
      }
      if (hasSharedUpdate)
        hasSharedUpdate = false;
      structures = sharedStructures || [];
      packedObjectMap2 = sharedPackedObjectMap2;
      if (options.pack) {
        let packedValues2 = /* @__PURE__ */ new Map();
        packedValues2.values = [];
        packedValues2.encoder = encoder;
        packedValues2.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap2 ? 16 : Infinity);
        packedValues2.objectMap = sharedPackedObjectMap2 || false;
        packedValues2.samplingPackedValues = samplingPackedValues;
        findRepetitiveStrings(value, packedValues2);
        if (packedValues2.values.length > 0) {
          target[position2++] = 216;
          target[position2++] = 51;
          writeArrayHeader(4);
          let valuesArray = packedValues2.values;
          encode9(valuesArray);
          writeArrayHeader(0);
          writeArrayHeader(0);
          packedObjectMap2 = Object.create(sharedPackedObjectMap2 || null);
          for (let i = 0, l = valuesArray.length; i < l; i++) {
            packedObjectMap2[valuesArray[i]] = i;
          }
        }
      }
      throwOnIterable = encodeOptions2 & THROW_ON_ITERABLE;
      try {
        if (throwOnIterable)
          return;
        encode9(value);
        if (bundledStrings2) {
          writeBundles(start, encode9);
        }
        encoder.offset = position2;
        if (referenceMap2 && referenceMap2.idsToInsert) {
          position2 += referenceMap2.idsToInsert.length * 2;
          if (position2 > safeEnd)
            makeRoom(position2);
          encoder.offset = position2;
          let serialized = insertIds(target.subarray(start, position2), referenceMap2.idsToInsert);
          referenceMap2 = null;
          return serialized;
        }
        if (encodeOptions2 & REUSE_BUFFER_MODE) {
          target.start = start;
          target.end = position2;
          return target;
        }
        return target.subarray(start, position2);
      } finally {
        if (sharedStructures) {
          if (serializationsSinceTransitionRebuild < 10)
            serializationsSinceTransitionRebuild++;
          if (sharedStructures.length > maxSharedStructures)
            sharedStructures.length = maxSharedStructures;
          if (transitionsCount > 1e4) {
            sharedStructures.transitions = null;
            serializationsSinceTransitionRebuild = 0;
            transitionsCount = 0;
            if (recordIdsToRemove.length > 0)
              recordIdsToRemove = [];
          } else if (recordIdsToRemove.length > 0 && !isSequential) {
            for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
              recordIdsToRemove[i][RECORD_SYMBOL] = void 0;
            }
            recordIdsToRemove = [];
          }
        }
        if (hasSharedUpdate && encoder.saveShared) {
          if (encoder.structures.length > maxSharedStructures) {
            encoder.structures = encoder.structures.slice(0, maxSharedStructures);
          }
          let returnBuffer = target.subarray(start, position2);
          if (encoder.updateSharedData() === false)
            return encoder.encode(value);
          return returnBuffer;
        }
        if (encodeOptions2 & RESET_BUFFER_MODE)
          position2 = start;
      }
    };
    this.findCommonStringsToPack = () => {
      samplingPackedValues = /* @__PURE__ */ new Map();
      if (!sharedPackedObjectMap2)
        sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
      return (options2) => {
        let threshold = options2 && options2.threshold || 4;
        let position3 = this.pack ? options2.maxPrivatePackedValues || 16 : 0;
        if (!sharedValues)
          sharedValues = this.sharedValues = [];
        for (let [key, status] of samplingPackedValues) {
          if (status.count > threshold) {
            sharedPackedObjectMap2[key] = position3++;
            sharedValues.push(key);
            hasSharedUpdate = true;
          }
        }
        while (this.saveShared && this.updateSharedData() === false) {
        }
        samplingPackedValues = null;
      };
    };
    const encode9 = (value) => {
      if (position2 > safeEnd)
        target = makeRoom(position2);
      var type = typeof value;
      var length2;
      if (type === "string") {
        if (packedObjectMap2) {
          let packedPosition = packedObjectMap2[value];
          if (packedPosition >= 0) {
            if (packedPosition < 16)
              target[position2++] = packedPosition + 224;
            else {
              target[position2++] = 198;
              if (packedPosition & 1)
                encode9(15 - packedPosition >> 1);
              else
                encode9(packedPosition - 16 >> 1);
            }
            return;
          } else if (samplingPackedValues && !options.pack) {
            let status = samplingPackedValues.get(value);
            if (status)
              status.count++;
            else
              samplingPackedValues.set(value, {
                count: 1
              });
          }
        }
        let strLength = value.length;
        if (bundledStrings2 && strLength >= 4 && strLength < 1024) {
          if ((bundledStrings2.size += strLength) > MAX_BUNDLE_SIZE) {
            let extStart;
            let maxBytes2 = (bundledStrings2[0] ? bundledStrings2[0].length * 3 + bundledStrings2[1].length : 0) + 10;
            if (position2 + maxBytes2 > safeEnd)
              target = makeRoom(position2 + maxBytes2);
            target[position2++] = 217;
            target[position2++] = 223;
            target[position2++] = 249;
            target[position2++] = bundledStrings2.position ? 132 : 130;
            target[position2++] = 26;
            extStart = position2 - start;
            position2 += 4;
            if (bundledStrings2.position) {
              writeBundles(start, encode9);
            }
            bundledStrings2 = ["", ""];
            bundledStrings2.size = 0;
            bundledStrings2.position = extStart;
          }
          let twoByte = hasNonLatin.test(value);
          bundledStrings2[twoByte ? 0 : 1] += value;
          target[position2++] = twoByte ? 206 : 207;
          encode9(strLength);
          return;
        }
        let headerSize;
        if (strLength < 32) {
          headerSize = 1;
        } else if (strLength < 256) {
          headerSize = 2;
        } else if (strLength < 65536) {
          headerSize = 3;
        } else {
          headerSize = 5;
        }
        let maxBytes = strLength * 3;
        if (position2 + maxBytes > safeEnd)
          target = makeRoom(position2 + maxBytes);
        if (strLength < 64 || !encodeUtf8) {
          let i, c1, c2, strPosition = position2 + headerSize;
          for (i = 0; i < strLength; i++) {
            c1 = value.charCodeAt(i);
            if (c1 < 128) {
              target[strPosition++] = c1;
            } else if (c1 < 2048) {
              target[strPosition++] = c1 >> 6 | 192;
              target[strPosition++] = c1 & 63 | 128;
            } else if ((c1 & 64512) === 55296 && ((c2 = value.charCodeAt(i + 1)) & 64512) === 56320) {
              c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
              i++;
              target[strPosition++] = c1 >> 18 | 240;
              target[strPosition++] = c1 >> 12 & 63 | 128;
              target[strPosition++] = c1 >> 6 & 63 | 128;
              target[strPosition++] = c1 & 63 | 128;
            } else {
              target[strPosition++] = c1 >> 12 | 224;
              target[strPosition++] = c1 >> 6 & 63 | 128;
              target[strPosition++] = c1 & 63 | 128;
            }
          }
          length2 = strPosition - position2 - headerSize;
        } else {
          length2 = encodeUtf8(value, position2 + headerSize, maxBytes);
        }
        if (length2 < 24) {
          target[position2++] = 96 | length2;
        } else if (length2 < 256) {
          if (headerSize < 2) {
            target.copyWithin(position2 + 2, position2 + 1, position2 + 1 + length2);
          }
          target[position2++] = 120;
          target[position2++] = length2;
        } else if (length2 < 65536) {
          if (headerSize < 3) {
            target.copyWithin(position2 + 3, position2 + 2, position2 + 2 + length2);
          }
          target[position2++] = 121;
          target[position2++] = length2 >> 8;
          target[position2++] = length2 & 255;
        } else {
          if (headerSize < 5) {
            target.copyWithin(position2 + 5, position2 + 3, position2 + 3 + length2);
          }
          target[position2++] = 122;
          targetView.setUint32(position2, length2);
          position2 += 4;
        }
        position2 += length2;
      } else if (type === "number") {
        if (value >>> 0 === value) {
          if (value < 24) {
            target[position2++] = value;
          } else if (value < 256) {
            target[position2++] = 24;
            target[position2++] = value;
          } else if (value < 65536) {
            target[position2++] = 25;
            target[position2++] = value >> 8;
            target[position2++] = value & 255;
          } else {
            target[position2++] = 26;
            targetView.setUint32(position2, value);
            position2 += 4;
          }
        } else if (value >> 0 === value) {
          if (value >= -24) {
            target[position2++] = 31 - value;
          } else if (value >= -256) {
            target[position2++] = 56;
            target[position2++] = ~value;
          } else if (value >= -65536) {
            target[position2++] = 57;
            targetView.setUint16(position2, ~value);
            position2 += 2;
          } else {
            target[position2++] = 58;
            targetView.setUint32(position2, ~value);
            position2 += 4;
          }
        } else {
          let useFloat32;
          if ((useFloat32 = this.useFloat32) > 0 && value < 4294967296 && value >= -2147483648) {
            target[position2++] = 250;
            targetView.setFloat32(position2, value);
            let xShifted;
            if (useFloat32 < 4 || (xShifted = value * mult10[(target[position2] & 127) << 1 | target[position2 + 1] >> 7]) >> 0 === xShifted) {
              position2 += 4;
              return;
            } else
              position2--;
          }
          target[position2++] = 251;
          targetView.setFloat64(position2, value);
          position2 += 8;
        }
      } else if (type === "object") {
        if (!value)
          target[position2++] = 246;
        else {
          if (referenceMap2) {
            let referee = referenceMap2.get(value);
            if (referee) {
              target[position2++] = 216;
              target[position2++] = 29;
              target[position2++] = 25;
              if (!referee.references) {
                let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                referee.references = [];
                idsToInsert.push(referee);
              }
              referee.references.push(position2 - start);
              position2 += 2;
              return;
            } else
              referenceMap2.set(value, { offset: position2 - start });
          }
          let constructor = value.constructor;
          if (constructor === Object) {
            writeObject(value, true);
          } else if (constructor === Array) {
            length2 = value.length;
            if (length2 < 24) {
              target[position2++] = 128 | length2;
            } else {
              writeArrayHeader(length2);
            }
            for (let i = 0; i < length2; i++) {
              encode9(value[i]);
            }
          } else if (constructor === Map) {
            if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
              target[position2++] = 217;
              target[position2++] = 1;
              target[position2++] = 3;
            }
            length2 = value.size;
            if (length2 < 24) {
              target[position2++] = 160 | length2;
            } else if (length2 < 256) {
              target[position2++] = 184;
              target[position2++] = length2;
            } else if (length2 < 65536) {
              target[position2++] = 185;
              target[position2++] = length2 >> 8;
              target[position2++] = length2 & 255;
            } else {
              target[position2++] = 186;
              targetView.setUint32(position2, length2);
              position2 += 4;
            }
            if (encoder.keyMap) {
              for (let [key, entryValue] of value) {
                encode9(encoder.encodeKey(key));
                encode9(entryValue);
              }
            } else {
              for (let [key, entryValue] of value) {
                encode9(key);
                encode9(entryValue);
              }
            }
          } else {
            for (let i = 0, l = extensions.length; i < l; i++) {
              let extensionClass = extensionClasses[i];
              if (value instanceof extensionClass) {
                let extension = extensions[i];
                let tag = extension.tag;
                if (tag == void 0)
                  tag = extension.getTag && extension.getTag.call(this, value);
                if (tag < 24) {
                  target[position2++] = 192 | tag;
                } else if (tag < 256) {
                  target[position2++] = 216;
                  target[position2++] = tag;
                } else if (tag < 65536) {
                  target[position2++] = 217;
                  target[position2++] = tag >> 8;
                  target[position2++] = tag & 255;
                } else if (tag > -1) {
                  target[position2++] = 218;
                  targetView.setUint32(position2, tag);
                  position2 += 4;
                }
                extension.encode.call(this, value, encode9, makeRoom);
                return;
              }
            }
            if (value[Symbol.iterator]) {
              if (throwOnIterable) {
                let error = new Error("Iterable should be serialized as iterator");
                error.iteratorNotHandled = true;
                throw error;
              }
              target[position2++] = 159;
              for (let entry of value) {
                encode9(entry);
              }
              target[position2++] = 255;
              return;
            }
            if (value[Symbol.asyncIterator] || isBlob(value)) {
              let error = new Error("Iterable/blob should be serialized as iterator");
              error.iteratorNotHandled = true;
              throw error;
            }
            writeObject(value, !value.hasOwnProperty);
          }
        }
      } else if (type === "boolean") {
        target[position2++] = value ? 245 : 244;
      } else if (type === "bigint") {
        if (value < BigInt(1) << BigInt(64) && value >= 0) {
          target[position2++] = 27;
          targetView.setBigUint64(position2, value);
        } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {
          target[position2++] = 59;
          targetView.setBigUint64(position2, -value - BigInt(1));
        } else {
          if (this.largeBigIntToFloat) {
            target[position2++] = 251;
            targetView.setFloat64(position2, Number(value));
          } else {
            throw new RangeError(value + " was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64");
          }
        }
        position2 += 8;
      } else if (type === "undefined") {
        target[position2++] = 247;
      } else {
        throw new Error("Unknown type: " + type);
      }
    };
    const writeObject = this.useRecords === false ? this.variableMapSize ? (object2) => {
      let keys = Object.keys(object2);
      let vals = Object.values(object2);
      let length2 = keys.length;
      if (length2 < 24) {
        target[position2++] = 160 | length2;
      } else if (length2 < 256) {
        target[position2++] = 184;
        target[position2++] = length2;
      } else if (length2 < 65536) {
        target[position2++] = 185;
        target[position2++] = length2 >> 8;
        target[position2++] = length2 & 255;
      } else {
        target[position2++] = 186;
        targetView.setUint32(position2, length2);
        position2 += 4;
      }
      let key;
      if (encoder.keyMap) {
        for (let i = 0; i < length2; i++) {
          encode9(encodeKey(keys[i]));
          encode9(vals[i]);
        }
      } else {
        for (let i = 0; i < length2; i++) {
          encode9(keys[i]);
          encode9(vals[i]);
        }
      }
    } : (object2, safePrototype) => {
      target[position2++] = 185;
      let objectOffset = position2 - start;
      position2 += 2;
      let size = 0;
      if (encoder.keyMap) {
        for (let key in object2)
          if (safePrototype || object2.hasOwnProperty(key)) {
            encode9(encoder.encodeKey(key));
            encode9(object2[key]);
            size++;
          }
      } else {
        for (let key in object2)
          if (safePrototype || object2.hasOwnProperty(key)) {
            encode9(key);
            encode9(object2[key]);
            size++;
          }
      }
      target[objectOffset++ + start] = size >> 8;
      target[objectOffset + start] = size & 255;
    } : (object2, safePrototype) => {
      let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
      let newTransitions = 0;
      let length2 = 0;
      let parentRecordId;
      let keys;
      if (this.keyMap) {
        keys = Object.keys(object2).map((k) => this.encodeKey(k));
        length2 = keys.length;
        for (let i = 0; i < length2; i++) {
          let key = keys[i];
          nextTransition = transition[key];
          if (!nextTransition) {
            nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
            newTransitions++;
          }
          transition = nextTransition;
        }
      } else {
        for (let key in object2)
          if (safePrototype || object2.hasOwnProperty(key)) {
            nextTransition = transition[key];
            if (!nextTransition) {
              if (transition[RECORD_SYMBOL] & 1048576) {
                parentRecordId = transition[RECORD_SYMBOL] & 65535;
              }
              nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
              newTransitions++;
            }
            transition = nextTransition;
            length2++;
          }
      }
      let recordId = transition[RECORD_SYMBOL];
      if (recordId !== void 0) {
        recordId &= 65535;
        target[position2++] = 217;
        target[position2++] = recordId >> 8 | 224;
        target[position2++] = recordId & 255;
      } else {
        if (!keys)
          keys = transition.__keys__ || (transition.__keys__ = Object.keys(object2));
        if (parentRecordId === void 0) {
          recordId = structures.nextId++;
          if (!recordId) {
            recordId = 0;
            structures.nextId = 1;
          }
          if (recordId >= MAX_STRUCTURES) {
            structures.nextId = (recordId = maxSharedStructures) + 1;
          }
        } else {
          recordId = parentRecordId;
        }
        structures[recordId] = keys;
        if (recordId < maxSharedStructures) {
          target[position2++] = 217;
          target[position2++] = recordId >> 8 | 224;
          target[position2++] = recordId & 255;
          transition = structures.transitions;
          for (let i = 0; i < length2; i++) {
            if (transition[RECORD_SYMBOL] === void 0 || transition[RECORD_SYMBOL] & 1048576)
              transition[RECORD_SYMBOL] = recordId;
            transition = transition[keys[i]];
          }
          transition[RECORD_SYMBOL] = recordId | 1048576;
          hasSharedUpdate = true;
        } else {
          transition[RECORD_SYMBOL] = recordId;
          targetView.setUint32(position2, 3655335680);
          position2 += 3;
          if (newTransitions)
            transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
          if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)
            recordIdsToRemove.shift()[RECORD_SYMBOL] = void 0;
          recordIdsToRemove.push(transition);
          writeArrayHeader(length2 + 2);
          encode9(57344 + recordId);
          encode9(keys);
          if (safePrototype === null)
            return;
          for (let key in object2)
            if (safePrototype || object2.hasOwnProperty(key))
              encode9(object2[key]);
          return;
        }
      }
      if (length2 < 24) {
        target[position2++] = 128 | length2;
      } else {
        writeArrayHeader(length2);
      }
      if (safePrototype === null)
        return;
      for (let key in object2)
        if (safePrototype || object2.hasOwnProperty(key))
          encode9(object2[key]);
    };
    const makeRoom = (end) => {
      let newSize;
      if (end > 16777216) {
        if (end - start > MAX_BUFFER_SIZE)
          throw new Error("Encoded buffer would be larger than maximum buffer size");
        newSize = Math.min(MAX_BUFFER_SIZE, Math.round(Math.max((end - start) * (end > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096);
      } else
        newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
      let newBuffer = new ByteArrayAllocate(newSize);
      targetView = new DataView(newBuffer.buffer, 0, newSize);
      if (target.copy)
        target.copy(newBuffer, 0, start, end);
      else
        newBuffer.set(target.slice(start, end));
      position2 -= start;
      start = 0;
      safeEnd = newBuffer.length - 10;
      return target = newBuffer;
    };
    let chunkThreshold = 100;
    let continuedChunkThreshold = 1e3;
    this.encodeAsIterable = function(value, options2) {
      return startEncoding(value, options2, encodeObjectAsIterable);
    };
    this.encodeAsAsyncIterable = function(value, options2) {
      return startEncoding(value, options2, encodeObjectAsAsyncIterable);
    };
    function* encodeObjectAsIterable(object2, iterateProperties, finalIterable) {
      let constructor = object2.constructor;
      if (constructor === Object) {
        let useRecords = encoder.useRecords !== false;
        if (useRecords)
          writeObject(object2, null);
        else
          writeEntityLength(Object.keys(object2).length, 160);
        for (let key in object2) {
          let value = object2[key];
          if (!useRecords)
            encode9(key);
          if (value && typeof value === "object") {
            if (iterateProperties[key])
              yield* encodeObjectAsIterable(value, iterateProperties[key]);
            else
              yield* tryEncode(value, iterateProperties, key);
          } else
            encode9(value);
        }
      } else if (constructor === Array) {
        let length2 = object2.length;
        writeArrayHeader(length2);
        for (let i = 0; i < length2; i++) {
          let value = object2[i];
          if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
            if (iterateProperties.element)
              yield* encodeObjectAsIterable(value, iterateProperties.element);
            else
              yield* tryEncode(value, iterateProperties, "element");
          } else
            encode9(value);
        }
      } else if (object2[Symbol.iterator]) {
        target[position2++] = 159;
        for (let value of object2) {
          if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
            if (iterateProperties.element)
              yield* encodeObjectAsIterable(value, iterateProperties.element);
            else
              yield* tryEncode(value, iterateProperties, "element");
          } else
            encode9(value);
        }
        target[position2++] = 255;
      } else if (isBlob(object2)) {
        writeEntityLength(object2.size, 64);
        yield target.subarray(start, position2);
        yield object2;
        restartEncoding();
      } else if (object2[Symbol.asyncIterator]) {
        target[position2++] = 159;
        yield target.subarray(start, position2);
        yield object2;
        restartEncoding();
        target[position2++] = 255;
      } else {
        encode9(object2);
      }
      if (finalIterable && position2 > start)
        yield target.subarray(start, position2);
      else if (position2 - start > chunkThreshold) {
        yield target.subarray(start, position2);
        restartEncoding();
      }
    }
    function* tryEncode(value, iterateProperties, key) {
      let restart = position2 - start;
      try {
        encode9(value);
        if (position2 - start > chunkThreshold) {
          yield target.subarray(start, position2);
          restartEncoding();
        }
      } catch (error) {
        if (error.iteratorNotHandled) {
          iterateProperties[key] = {};
          position2 = start + restart;
          yield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);
        } else
          throw error;
      }
    }
    function restartEncoding() {
      chunkThreshold = continuedChunkThreshold;
      encoder.encode(null, THROW_ON_ITERABLE);
    }
    function startEncoding(value, options2, encodeIterable) {
      if (options2 && options2.chunkThreshold)
        chunkThreshold = continuedChunkThreshold = options2.chunkThreshold;
      else
        chunkThreshold = 100;
      if (value && typeof value === "object") {
        encoder.encode(null, THROW_ON_ITERABLE);
        return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);
      }
      return [encoder.encode(value)];
    }
    async function* encodeObjectAsAsyncIterable(value, iterateProperties) {
      for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {
        let constructor = encodedValue.constructor;
        if (constructor === ByteArray || constructor === Uint8Array)
          yield encodedValue;
        else if (isBlob(encodedValue)) {
          let reader = encodedValue.stream().getReader();
          let next;
          while (!(next = await reader.read()).done) {
            yield next.value;
          }
        } else if (encodedValue[Symbol.asyncIterator]) {
          for await (let asyncValue of encodedValue) {
            restartEncoding();
            if (asyncValue)
              yield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));
            else
              yield encoder.encode(asyncValue);
          }
        } else {
          yield encodedValue;
        }
      }
    }
  }
  useBuffer(buffer2) {
    target = buffer2;
    targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
    position2 = 0;
  }
  clearSharedData() {
    if (this.structures)
      this.structures = [];
    if (this.sharedValues)
      this.sharedValues = void 0;
  }
  updateSharedData() {
    let lastVersion = this.sharedVersion || 0;
    this.sharedVersion = lastVersion + 1;
    let structuresCopy = this.structures.slice(0);
    let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);
    let saveResults = this.saveShared(sharedData, (existingShared) => (existingShared && existingShared.version || 0) == lastVersion);
    if (saveResults === false) {
      sharedData = this.getShared() || {};
      this.structures = sharedData.structures || [];
      this.sharedValues = sharedData.packedValues;
      this.sharedVersion = sharedData.version;
      this.structures.nextId = this.structures.length;
    } else {
      structuresCopy.forEach((structure, i) => this.structures[i] = structure);
    }
    return saveResults;
  }
};
function writeEntityLength(length2, majorValue) {
  if (length2 < 24)
    target[position2++] = majorValue | length2;
  else if (length2 < 256) {
    target[position2++] = majorValue | 24;
    target[position2++] = length2;
  } else if (length2 < 65536) {
    target[position2++] = majorValue | 25;
    target[position2++] = length2 >> 8;
    target[position2++] = length2 & 255;
  } else {
    target[position2++] = majorValue | 26;
    targetView.setUint32(position2, length2);
    position2 += 4;
  }
}
var SharedData = class {
  constructor(structures, values, version2) {
    this.structures = structures;
    this.packedValues = values;
    this.version = version2;
  }
};
function writeArrayHeader(length2) {
  if (length2 < 24)
    target[position2++] = 128 | length2;
  else if (length2 < 256) {
    target[position2++] = 152;
    target[position2++] = length2;
  } else if (length2 < 65536) {
    target[position2++] = 153;
    target[position2++] = length2 >> 8;
    target[position2++] = length2 & 255;
  } else {
    target[position2++] = 154;
    targetView.setUint32(position2, length2);
    position2 += 4;
  }
}
var BlobConstructor = typeof Blob === "undefined" ? function() {
} : Blob;
function isBlob(object2) {
  if (object2 instanceof BlobConstructor)
    return true;
  let tag = object2[Symbol.toStringTag];
  return tag === "Blob" || tag === "File";
}
function findRepetitiveStrings(value, packedValues2) {
  switch (typeof value) {
    case "string":
      if (value.length > 3) {
        if (packedValues2.objectMap[value] > -1 || packedValues2.values.length >= packedValues2.maxValues)
          return;
        let packedStatus = packedValues2.get(value);
        if (packedStatus) {
          if (++packedStatus.count == 2) {
            packedValues2.values.push(value);
          }
        } else {
          packedValues2.set(value, {
            count: 1
          });
          if (packedValues2.samplingPackedValues) {
            let status = packedValues2.samplingPackedValues.get(value);
            if (status)
              status.count++;
            else
              packedValues2.samplingPackedValues.set(value, {
                count: 1
              });
          }
        }
      }
      break;
    case "object":
      if (value) {
        if (value instanceof Array) {
          for (let i = 0, l = value.length; i < l; i++) {
            findRepetitiveStrings(value[i], packedValues2);
          }
        } else {
          let includeKeys = !packedValues2.encoder.useRecords;
          for (var key in value) {
            if (value.hasOwnProperty(key)) {
              if (includeKeys)
                findRepetitiveStrings(key, packedValues2);
              findRepetitiveStrings(value[key], packedValues2);
            }
          }
        }
      }
      break;
    case "function":
      console.log(value);
  }
}
var isLittleEndianMachine2 = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
extensionClasses = [
  Date,
  Set,
  Error,
  RegExp,
  Tag,
  ArrayBuffer,
  Uint8Array,
  Uint8ClampedArray,
  Uint16Array,
  Uint32Array,
  typeof BigUint64Array == "undefined" ? function() {
  } : BigUint64Array,
  Int8Array,
  Int16Array,
  Int32Array,
  typeof BigInt64Array == "undefined" ? function() {
  } : BigInt64Array,
  Float32Array,
  Float64Array,
  SharedData
];
extensions = [
  {
    tag: 1,
    encode(date, encode9) {
      let seconds = date.getTime() / 1e3;
      if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 4294967296) {
        target[position2++] = 26;
        targetView.setUint32(position2, seconds);
        position2 += 4;
      } else {
        target[position2++] = 251;
        targetView.setFloat64(position2, seconds);
        position2 += 8;
      }
    }
  },
  {
    tag: 258,
    encode(set, encode9) {
      let array2 = Array.from(set);
      encode9(array2);
    }
  },
  {
    tag: 27,
    encode(error, encode9) {
      encode9([error.name, error.message]);
    }
  },
  {
    tag: 27,
    encode(regex, encode9) {
      encode9(["RegExp", regex.source, regex.flags]);
    }
  },
  {
    getTag(tag) {
      return tag.tag;
    },
    encode(tag, encode9) {
      encode9(tag.value);
    }
  },
  {
    encode(arrayBuffer, encode9, makeRoom) {
      writeBuffer(arrayBuffer, makeRoom);
    }
  },
  {
    getTag(typedArray) {
      if (typedArray.constructor === Uint8Array) {
        if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)
          return 64;
      }
    },
    encode(typedArray, encode9, makeRoom) {
      writeBuffer(typedArray, makeRoom);
    }
  },
  typedArrayEncoder(68, 1),
  typedArrayEncoder(69, 2),
  typedArrayEncoder(70, 4),
  typedArrayEncoder(71, 8),
  typedArrayEncoder(72, 1),
  typedArrayEncoder(77, 2),
  typedArrayEncoder(78, 4),
  typedArrayEncoder(79, 8),
  typedArrayEncoder(85, 4),
  typedArrayEncoder(86, 8),
  {
    encode(sharedData, encode9) {
      let packedValues2 = sharedData.packedValues || [];
      let sharedStructures = sharedData.structures || [];
      if (packedValues2.values.length > 0) {
        target[position2++] = 216;
        target[position2++] = 51;
        writeArrayHeader(4);
        let valuesArray = packedValues2.values;
        encode9(valuesArray);
        writeArrayHeader(0);
        writeArrayHeader(0);
        packedObjectMap = Object.create(sharedPackedObjectMap || null);
        for (let i = 0, l = valuesArray.length; i < l; i++) {
          packedObjectMap[valuesArray[i]] = i;
        }
      }
      if (sharedStructures) {
        targetView.setUint32(position2, 3655335424);
        position2 += 3;
        let definitions = sharedStructures.slice(0);
        definitions.unshift(57344);
        definitions.push(new Tag(sharedData.version, 1399353956));
        encode9(definitions);
      } else
        encode9(new Tag(sharedData.version, 1399353956));
    }
  }
];
function typedArrayEncoder(tag, size) {
  if (!isLittleEndianMachine2 && size > 1)
    tag -= 4;
  return {
    tag,
    encode: function writeExtBuffer(typedArray, encode9) {
      let length2 = typedArray.byteLength;
      let offset = typedArray.byteOffset || 0;
      let buffer2 = typedArray.buffer || typedArray;
      encode9(hasNodeBuffer ? Buffer2.from(buffer2, offset, length2) : new Uint8Array(buffer2, offset, length2));
    }
  };
}
function writeBuffer(buffer2, makeRoom) {
  let length2 = buffer2.byteLength;
  if (length2 < 24) {
    target[position2++] = 64 + length2;
  } else if (length2 < 256) {
    target[position2++] = 88;
    target[position2++] = length2;
  } else if (length2 < 65536) {
    target[position2++] = 89;
    target[position2++] = length2 >> 8;
    target[position2++] = length2 & 255;
  } else {
    target[position2++] = 90;
    targetView.setUint32(position2, length2);
    position2 += 4;
  }
  if (position2 + length2 >= target.length) {
    makeRoom(position2 + length2);
  }
  target.set(buffer2.buffer ? buffer2 : new Uint8Array(buffer2), position2);
  position2 += length2;
}
function insertIds(serialized, idsToInsert) {
  let nextId;
  let distanceToMove = idsToInsert.length * 2;
  let lastEnd = serialized.length - distanceToMove;
  idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
  for (let id = 0; id < idsToInsert.length; id++) {
    let referee = idsToInsert[id];
    referee.id = id;
    for (let position3 of referee.references) {
      serialized[position3++] = id >> 8;
      serialized[position3] = id & 255;
    }
  }
  while (nextId = idsToInsert.pop()) {
    let offset = nextId.offset;
    serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
    distanceToMove -= 2;
    let position3 = offset + distanceToMove;
    serialized[position3++] = 216;
    serialized[position3++] = 28;
    lastEnd = offset;
  }
  return serialized;
}
function writeBundles(start, encode9) {
  targetView.setUint32(bundledStrings2.position + start, position2 - bundledStrings2.position - start + 1);
  let writeStrings = bundledStrings2;
  bundledStrings2 = null;
  encode9(writeStrings[0]);
  encode9(writeStrings[1]);
}
function addExtension2(extension) {
  if (extension.Class) {
    if (!extension.encode)
      throw new Error("Extension has no encode function");
    extensionClasses.unshift(extension.Class);
    extensions.unshift(extension);
  }
  addExtension(extension);
}
var defaultEncoder = new Encoder2({ useRecords: false });
var encode8 = defaultEncoder.encode;
var encodeAsIterable = defaultEncoder.encodeAsIterable;
var encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable;
var { NEVER: NEVER2, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;
var REUSE_BUFFER_MODE = 512;
var RESET_BUFFER_MODE = 1024;
var THROW_ON_ITERABLE = 2048;

// ../../node_modules/.pnpm/cbor-x@1.5.1/node_modules/cbor-x/node-index.js
var import_module = require("module");
var import_meta = {};
var nativeAccelerationDisabled = process.env.CBOR_NATIVE_ACCELERATION_DISABLED !== void 0 && process.env.CBOR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === "true";
if (!nativeAccelerationDisabled) {
  let extractor;
  try {
    if (typeof require == "function")
      extractor = require_cbor_extract();
    else
      extractor = (0, import_module.createRequire)(import_meta.url)("cbor-extract");
    if (extractor)
      setExtractor(extractor.extractStrings);
  } catch (error) {
  }
}

// ../common/src/ipld-multi.ts
addExtension2({
  Class: CID,
  tag: 42,
  encode: () => {
    throw new Error("cannot encode cids");
  },
  decode: (bytes3) => {
    if (bytes3[0] !== 0) {
      throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
    }
    return CID.decode(bytes3.subarray(1));
  }
});

// ../common/src/logger.ts
var import_pino = __toESM(require_pino());
var allSystemsEnabled = !process.env.LOG_SYSTEMS;
var enabledSystems = (process.env.LOG_SYSTEMS || "").replace(",", " ").split(" ");
var enabledEnv = process.env.LOG_ENABLED;
var enabled = enabledEnv === "true" || enabledEnv === "t" || enabledEnv === "1";
var level = process.env.LOG_LEVEL || "info";
var config = {
  enabled,
  level
};
var rootLogger = process.env.LOG_DESTINATION ? (0, import_pino.default)(config, import_pino.default.destination(process.env.LOG_DESTINATION)) : (0, import_pino.default)(config);
var subsystems = {};
var subsystemLogger = (name3) => {
  if (subsystems[name3])
    return subsystems[name3];
  const subsystemEnabled = enabled && (allSystemsEnabled || enabledSystems.indexOf(name3) > -1);
  subsystems[name3] = rootLogger.child({ name: name3 }, { level: subsystemEnabled ? level : "silent" });
  return subsystems[name3];
};

// ../common/src/streams.ts
var import_stream2 = require("stream");
var byteIterableToStream = (iter) => {
  return import_stream2.Readable.from(iter, { objectMode: false });
};

// src/block-map.ts
var BlockMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  async add(value) {
    const block = await dataToCborBlock(lexToIpld(value));
    this.set(block.cid, block.bytes);
    return block.cid;
  }
  set(cid2, bytes3) {
    this.map.set(cid2.toString(), bytes3);
  }
  get(cid2) {
    return this.map.get(cid2.toString());
  }
  delete(cid2) {
    this.map.delete(cid2.toString());
  }
  getMany(cids) {
    const missing = [];
    const blocks = new BlockMap();
    for (const cid2 of cids) {
      const got = this.map.get(cid2.toString());
      if (got) {
        blocks.set(cid2, got);
      } else {
        missing.push(cid2);
      }
    }
    return { blocks, missing };
  }
  has(cid2) {
    return this.map.has(cid2.toString());
  }
  clear() {
    this.map.clear();
  }
  forEach(cb) {
    this.map.forEach((val, key) => cb(val, CID.parse(key)));
  }
  entries() {
    const entries = [];
    this.forEach((bytes3, cid2) => {
      entries.push({ cid: cid2, bytes: bytes3 });
    });
    return entries;
  }
  cids() {
    return this.entries().map((e) => e.cid);
  }
  addMap(toAdd) {
    toAdd.forEach((bytes3, cid2) => {
      this.set(cid2, bytes3);
    });
  }
  get size() {
    return this.map.size;
  }
  get byteSize() {
    let size = 0;
    this.forEach((bytes3) => {
      size += bytes3.length;
    });
    return size;
  }
  equals(other) {
    if (this.size !== other.size) {
      return false;
    }
    for (const entry of this.entries()) {
      const otherBytes = other.get(entry.cid);
      if (!otherBytes)
        return false;
      if (!equals3(entry.bytes, otherBytes)) {
        return false;
      }
    }
    return true;
  }
};
var block_map_default = BlockMap;

// src/cid-set.ts
var CidSet = class {
  constructor(arr = []) {
    const strArr = arr.map((c) => c.toString());
    this.set = new Set(strArr);
  }
  add(cid2) {
    this.set.add(cid2.toString());
    return this;
  }
  addSet(toMerge) {
    toMerge.toList().map((c) => this.add(c));
    return this;
  }
  subtractSet(toSubtract) {
    toSubtract.toList().map((c) => this.delete(c));
    return this;
  }
  delete(cid2) {
    this.set.delete(cid2.toString());
    return this;
  }
  has(cid2) {
    return this.set.has(cid2.toString());
  }
  size() {
    return this.set.size;
  }
  clear() {
    this.set.clear();
    return this;
  }
  toList() {
    return [...this.set].map((c) => CID.parse(c));
  }
};
var cid_set_default = CidSet;

// src/types.ts
var unsignedCommit = z.object({
  did: z.string(),
  version: z.literal(3),
  data: schema.cid,
  rev: z.string(),
  prev: schema.cid.nullable()
});
var commit = z.object({
  did: z.string(),
  version: z.literal(3),
  data: schema.cid,
  rev: z.string(),
  prev: schema.cid.nullable(),
  sig: schema.bytes
});
var legacyV2Commit = z.object({
  did: z.string(),
  version: z.literal(2),
  data: schema.cid,
  rev: z.string().optional(),
  prev: schema.cid.nullable(),
  sig: schema.bytes
});
var versionedCommit = z.discriminatedUnion("version", [
  commit,
  legacyV2Commit
]);
var schema2 = {
  ...schema,
  commit,
  legacyV2Commit,
  versionedCommit
};
var def2 = {
  ...def,
  commit: {
    name: "commit",
    schema: schema2.commit
  },
  versionedCommit: {
    name: "versioned_commit",
    schema: schema2.versionedCommit
  }
};
var WriteOpAction = /* @__PURE__ */ ((WriteOpAction2) => {
  WriteOpAction2["Create"] = "create";
  WriteOpAction2["Update"] = "update";
  WriteOpAction2["Delete"] = "delete";
  return WriteOpAction2;
})(WriteOpAction || {});

// src/mst/util.ts
var util_exports2 = {};
__export(util_exports2, {
  InvalidMstKeyError: () => InvalidMstKeyError,
  cidForEntries: () => cidForEntries,
  countPrefixLen: () => countPrefixLen,
  deserializeNodeData: () => deserializeNodeData,
  ensureValidMstKey: () => ensureValidMstKey,
  isValidChars: () => isValidChars,
  isValidMstKey: () => isValidMstKey,
  layerForEntries: () => layerForEntries,
  leadingZerosOnHash: () => leadingZerosOnHash,
  serializeNodeData: () => serializeNodeData,
  validCharsRegex: () => validCharsRegex
});

// ../crypto/src/const.ts
var P256_DID_PREFIX = new Uint8Array([128, 36]);
var SECP256K1_DID_PREFIX = new Uint8Array([231, 1]);
var BASE58_MULTIBASE_PREFIX = "z";
var DID_KEY_PREFIX = "did:key:";
var P256_JWT_ALG = "ES256";
var SECP256K1_JWT_ALG = "ES256K";

// ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes2(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert = {
  number,
  bool,
  bytes: bytes2,
  hash,
  exists,
  output
};
var assert_default = assert;

// ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/cryptoNode.js
var nc = __toESM(require("node:crypto"), 1);
var crypto2 = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : void 0;

// ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/utils.js
var u8a = (a) => a instanceof Uint8Array;
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  if (!u8a(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
var Hash = class {
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    assert_default.hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf2) {
    assert_default.exists(this);
    this.iHash.update(buf2);
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// ../../node_modules/.pnpm/@noble+curves@1.1.0/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes3,
  validateObject: () => validateObject
});
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var u8a2 = (a) => a instanceof Uint8Array;
var hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes3) {
  if (!u8a2(bytes3))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex += hexes2[bytes3[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array2 = new Uint8Array(len / 2);
  for (let i = 0; i < array2.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array2[i] = byte;
  }
  return array2;
}
function bytesToNumberBE(bytes3) {
  return hexToNumber(bytesToHex(bytes3));
}
function bytesToNumberLE(bytes3) {
  if (!u8a2(bytes3))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (u8a2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a2(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n;
}
var bitSet = (n, pos, value) => {
  return n | (value ? _1n : _0n) << BigInt(pos);
};
var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object2;
}

// ../../node_modules/.pnpm/@noble+curves@1.1.0/node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n2 || power < _0n2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod(number2, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n2) / _2n2;
  let Q, S, Z;
  for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
    ;
  for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp3, n) {
      const root = Fp3.pow(n, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n2;
  return function tonelliSlow(Fp3, n) {
    if (Fp3.pow(n, legendreC) === Fp3.neg(Fp3.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
    let x = Fp3.pow(n, Q1div2);
    let b = Fp3.pow(n, Q);
    while (!Fp3.eql(b, Fp3.ONE)) {
      if (Fp3.eql(b, Fp3.ZERO))
        return Fp3.ZERO;
      let m = 1;
      for (let t2 = Fp3.sqr(b); m < r; m++) {
        if (Fp3.eql(t2, Fp3.ONE))
          break;
        t2 = Fp3.sqr(t2);
      }
      const ge = Fp3.pow(g, _1n2 << BigInt(r - m - 1));
      g = Fp3.sqr(ge);
      x = Fp3.mul(x, ge);
      b = Fp3.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n2) / _4n;
    return function sqrt3mod4(Fp3, n) {
      const root = Fp3.pow(n, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp3, n) {
      const n2 = Fp3.mul(n, _2n2);
      const v = Fp3.pow(n2, c1);
      const nv = Fp3.mul(n, v);
      const i = Fp3.mul(Fp3.mul(nv, _2n2), v);
      const root = Fp3.mul(nv, Fp3.sub(i, Fp3.ONE));
      if (!Fp3.eql(Fp3.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n2)
    throw new Error("Expected power > 0");
  if (power === _0n2)
    return f.ONE;
  if (power === _1n2)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes3) => {
      if (bytes3.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes3.length}`);
      return isLE2 ? bytesToNumberLE(bytes3) : bytesToNumberBE(bytes3);
    }
  });
  return Object.freeze(f);
}
function hashToPrivateScalar(hash2, groupOrder, isLE2 = false) {
  hash2 = ensureBytes("privateHash", hash2);
  const hashLen = hash2.length;
  const minLen = nLength(groupOrder).nByteLength + 8;
  if (minLen < 24 || hashLen < minLen || hashLen > 1024)
    throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
  const num = isLE2 ? bytesToNumberLE(hash2) : bytesToNumberBE(hash2);
  return mod(num, groupOrder - _1n2) + _1n2;
}

// ../../node_modules/.pnpm/@noble+curves@1.1.0/node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d);
        d = d.double();
        n >>= _1n3;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base3 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base3 = p;
        points.push(base3);
        for (let i = 1; i < windowSize; i++) {
          base3 = base3.add(p);
          points.push(base3);
        }
        p = base3.double();
      }
      return points;
    },
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// ../../node_modules/.pnpm/@noble+curves@1.1.0/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp3, a } = opts;
  if (endo) {
    if (!Fp3.eql(a, Fp3.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice2 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice2(h(sig.s));
    const r = slice2(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp3 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((c, point, isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp3.toBytes(a.x), Fp3.toBytes(a.y));
  });
  const fromBytes2 = CURVE.fromBytes || ((bytes3) => {
    const tail = bytes3.subarray(1);
    const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
    const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, a)), b);
  }
  if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp3.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp3.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp3.isValid(pz))
        throw new Error("z required");
    }
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp3.eql(i, Fp3.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    static fromHex(hex) {
      const P = Point2.fromAffine(fromBytes2(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp3.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp3.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp3.isOdd)
        return !Fp3.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U1 && U2;
    }
    negate() {
      return new Point2(this.px, Fp3.neg(this.py), this.pz);
    }
    double() {
      const { a, b } = CURVE;
      const b3 = Fp3.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a, Z3);
      Y3 = Fp3.mul(b3, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b3, Z3);
      t2 = Fp3.mul(a, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a = CURVE.a;
      const b3 = Fp3.mul(CURVE.b, _3n2);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a, t4);
      X3 = Fp3.mul(b3, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
        const toInv = Fp3.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      });
    }
    multiplyUnsafe(n) {
      const I = Point2.ZERO;
      if (n === _0n4)
        return I;
      assertGE(n);
      if (n === _1n4)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n4 || k2 > _0n4) {
        if (k1 & _1n4)
          k1p = k1p.add(d);
        if (k2 & _1n4)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n4;
        k2 >>= _1n4;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul = (P, a2) => a2 === _0n4 || a2 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    toAffine(iz) {
      const { px: x, py: y, pz: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp3.ONE : Fp3.inv(z2);
      const ax = Fp3.mul(x, iz);
      const ay = Fp3.mul(y, iz);
      const zz = Fp3.mul(z2, iz);
      if (is0)
        return { x: Fp3.ZERO, y: Fp3.ZERO };
      if (!Fp3.eql(zz, Fp3.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point2.ZERO = new Point2(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp3.BYTES + 1;
  const uncompressedLen = 2 * Fp3.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n4 < num && num < Fp3.ORDER;
  }
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp3.toBytes(a.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp3.toBytes(a.y));
      }
    },
    fromBytes(bytes3) {
      const len = bytes3.length;
      const head = bytes3[0];
      const tail = bytes3.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp3.sqrt(y2);
        const isYOdd = (y & _1n4) === _1n4;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp3.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n4;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b, from3, to) => bytesToNumberBE(b.slice(from3, to));
  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp3.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const rand = CURVE.randomBytes(Fp3.BYTES + 8);
      const num = hashToPrivateScalar(rand, CURVE_ORDER);
      return numberToBytesBE(num, CURVE.nByteLength);
    },
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes3) {
    const num = bytesToNumberBE(bytes3);
    const delta = bytes3.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes3) {
    return modN(bits2int(bytes3));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n4 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes2(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e, Fp3.BYTES));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n4)
        return;
      const s = modN(ik * modN(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is3 = invN(s);
    const u1 = modN(h * is3);
    const u2 = modN(r * is3);
    const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point2,
    Signature,
    utils
  };
}

// ../../node_modules/.pnpm/@noble+curves@1.1.0/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create3 = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create3(defHash), create: create3 });
}

// ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    assert_default.exists(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView3 = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView3, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length: length2, finished, destroyed, pos } = this;
    to.length = length2;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length2 % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
};

// ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha2562 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// ../../node_modules/.pnpm/@noble+curves@1.1.0/node_modules/@noble/curves/esm/p256.js
var Fp = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var CURVE_A = Fp.create(BigInt("-3"));
var CURVE_B = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var p256 = createCurve({
  a: CURVE_A,
  b: CURVE_B,
  Fp,
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
  h: BigInt(1),
  lowS: false
}, sha2562);

// ../crypto/src/p256/encoding.ts
var decompressPubkey = (compressed) => {
  if (compressed.length !== 33) {
    throw new Error("Expected 33 byte compress pubkey");
  }
  const point = p256.ProjectivePoint.fromHex(compressed);
  return point.toRawBytes(false);
};

// ../../node_modules/.pnpm/@noble+curves@1.1.0/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n4) / b;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n4, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n4, P);
  if (!Fp2.eql(Fp2.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fp2 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Fp2,
  n: secp256k1N,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha2562);
var _0n5 = BigInt(0);
var Point = secp256k1.ProjectivePoint;

// ../crypto/src/secp256k1/encoding.ts
var decompressPubkey2 = (compressed) => {
  if (compressed.length !== 33) {
    throw new Error("Expected 33 byte compress pubkey");
  }
  const point = secp256k1.ProjectivePoint.fromHex(compressed);
  return point.toRawBytes(false);
};

// ../crypto/src/p256/operations.ts
var verifyDidSig = async (did2, data, sig, opts) => {
  const { jwtAlg, keyBytes } = parseDidKey(did2);
  if (jwtAlg !== P256_JWT_ALG) {
    throw new Error(`Not a P-256 did:key: ${did2}`);
  }
  return verifySig(keyBytes, data, sig, opts);
};
var verifySig = async (publicKey, data, sig, opts) => {
  const allowMalleable = opts?.allowMalleableSig ?? false;
  const msgHash = await sha2562(data);
  if (!allowMalleable && !isCompactFormat(sig)) {
    return false;
  }
  return p256.verify(sig, msgHash, publicKey, {
    lowS: !allowMalleable
  });
};
var isCompactFormat = (sig) => {
  try {
    const parsed = p256.Signature.fromCompact(sig);
    return equals3(parsed.toCompactRawBytes(), sig);
  } catch {
    return false;
  }
};

// ../crypto/src/p256/plugin.ts
var p256Plugin = {
  prefix: P256_DID_PREFIX,
  jwtAlg: P256_JWT_ALG,
  verifySignature: verifyDidSig
};
var plugin_default = p256Plugin;

// ../crypto/src/secp256k1/operations.ts
var verifyDidSig2 = async (did2, data, sig, opts) => {
  const { jwtAlg, keyBytes } = parseDidKey(did2);
  if (jwtAlg !== SECP256K1_JWT_ALG) {
    throw new Error(`Not a secp256k1 did:key: ${did2}`);
  }
  return verifySig2(keyBytes, data, sig, opts);
};
var verifySig2 = async (publicKey, data, sig, opts) => {
  const allowMalleable = opts?.allowMalleableSig ?? false;
  const msgHash = await sha2562(data);
  if (!allowMalleable && !isCompactFormat2(sig)) {
    return false;
  }
  return secp256k1.verify(sig, msgHash, publicKey, {
    lowS: !allowMalleable
  });
};
var isCompactFormat2 = (sig) => {
  try {
    const parsed = secp256k1.Signature.fromCompact(sig);
    return equals3(parsed.toCompactRawBytes(), sig);
  } catch {
    return false;
  }
};

// ../crypto/src/secp256k1/plugin.ts
var secp256k1Plugin = {
  prefix: SECP256K1_DID_PREFIX,
  jwtAlg: SECP256K1_JWT_ALG,
  verifySignature: verifyDidSig2
};
var plugin_default2 = secp256k1Plugin;

// ../crypto/src/plugins.ts
var plugins = [plugin_default, plugin_default2];
var plugins_default = plugins;

// ../crypto/src/did.ts
var parseMultikey = (multikey) => {
  if (!multikey.startsWith(BASE58_MULTIBASE_PREFIX)) {
    throw new Error(`Incorrect prefix for multikey: ${multikey}`);
  }
  const prefixedBytes = fromString2(multikey.slice(BASE58_MULTIBASE_PREFIX.length), "base58btc");
  const plugin = plugins_default.find((p) => hasPrefix(prefixedBytes, p.prefix));
  if (!plugin) {
    throw new Error("Unsupported key type");
  }
  let keyBytes = prefixedBytes.slice(plugin.prefix.length);
  if (plugin.jwtAlg === P256_JWT_ALG) {
    keyBytes = decompressPubkey(keyBytes);
  } else if (plugin.jwtAlg === SECP256K1_JWT_ALG) {
    keyBytes = decompressPubkey2(keyBytes);
  }
  return {
    jwtAlg: plugin.jwtAlg,
    keyBytes
  };
};
var parseDidKey = (did2) => {
  if (!did2.startsWith(DID_KEY_PREFIX)) {
    throw new Error(`Incorrect prefix for did:key: ${did2}`);
  }
  return parseMultikey(did2.slice(DID_KEY_PREFIX.length));
};
var hasPrefix = (bytes3, prefix) => {
  return equals3(prefix, bytes3.subarray(0, prefix.byteLength));
};

// ../crypto/src/sha.ts
var sha2563 = async (input) => {
  const bytes3 = typeof input === "string" ? fromString2(input, "utf8") : input;
  return sha2562(bytes3);
};

// ../crypto/src/verify.ts
var verifySignature = (didKey, data, sig, opts) => {
  const parsed = parseDidKey(didKey);
  const plugin = plugins_default.find((p) => p.jwtAlg === parsed.jwtAlg);
  if (!plugin) {
    throw new Error(`Unsupported signature alg: ${parsed.jwtAlg}`);
  }
  return plugin.verifySignature(didKey, data, sig, opts);
};

// src/mst/util.ts
var leadingZerosOnHash = async (key) => {
  const hash2 = await sha2563(key);
  let leadingZeros = 0;
  for (let i = 0; i < hash2.length; i++) {
    const byte = hash2[i];
    if (byte < 64)
      leadingZeros++;
    if (byte < 16)
      leadingZeros++;
    if (byte < 4)
      leadingZeros++;
    if (byte === 0) {
      leadingZeros++;
    } else {
      break;
    }
  }
  return leadingZeros;
};
var layerForEntries = async (entries) => {
  const firstLeaf = entries.find((entry) => entry.isLeaf());
  if (!firstLeaf || firstLeaf.isTree())
    return null;
  return await leadingZerosOnHash(firstLeaf.key);
};
var deserializeNodeData = async (storage, data, opts) => {
  const { layer } = opts || {};
  const entries = [];
  if (data.l !== null) {
    entries.push(await MST.load(storage, data.l, {
      layer: layer ? layer - 1 : void 0
    }));
  }
  let lastKey = "";
  for (const entry of data.e) {
    const keyStr = toString2(entry.k, "ascii");
    const key = lastKey.slice(0, entry.p) + keyStr;
    ensureValidMstKey(key);
    entries.push(new Leaf(key, entry.v));
    lastKey = key;
    if (entry.t !== null) {
      entries.push(await MST.load(storage, entry.t, {
        layer: layer ? layer - 1 : void 0
      }));
    }
  }
  return entries;
};
var serializeNodeData = (entries) => {
  const data = {
    l: null,
    e: []
  };
  let i = 0;
  if (entries[0]?.isTree()) {
    i++;
    data.l = entries[0].pointer;
  }
  let lastKey = "";
  while (i < entries.length) {
    const leaf = entries[i];
    const next = entries[i + 1];
    if (!leaf.isLeaf()) {
      throw new Error("Not a valid node: two subtrees next to each other");
    }
    i++;
    let subtree = null;
    if (next?.isTree()) {
      subtree = next.pointer;
      i++;
    }
    ensureValidMstKey(leaf.key);
    const prefixLen = countPrefixLen(lastKey, leaf.key);
    data.e.push({
      p: prefixLen,
      k: fromString2(leaf.key.slice(prefixLen), "ascii"),
      v: leaf.value,
      t: subtree
    });
    lastKey = leaf.key;
  }
  return data;
};
var countPrefixLen = (a, b) => {
  let i;
  for (i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      break;
    }
  }
  return i;
};
var cidForEntries = async (entries) => {
  const data = serializeNodeData(entries);
  return cidForCbor(data);
};
var isValidMstKey = (str) => {
  const split = str.split("/");
  return str.length <= 256 && split.length === 2 && split[0].length > 0 && split[1].length > 0 && isValidChars(split[0]) && isValidChars(split[1]);
};
var validCharsRegex = /^[a-zA-Z0-9_\-:.]*$/;
var isValidChars = (str) => {
  return str.match(validCharsRegex) !== null;
};
var ensureValidMstKey = (str) => {
  if (!isValidMstKey(str)) {
    throw new InvalidMstKeyError(str);
  }
};
var InvalidMstKeyError = class extends Error {
  constructor(key) {
    super(`Not a valid MST key: ${key}`);
    this.key = key;
  }
};

// src/error.ts
var MissingBlockError = class extends Error {
  constructor(cid2, def3) {
    let msg = `block not found: ${cid2.toString()}`;
    if (def3) {
      msg += `, expected type: ${def3}`;
    }
    super(msg);
    this.cid = cid2;
  }
};
var MissingBlocksError = class extends Error {
  constructor(context, cids) {
    const cidStr = cids.map((c) => c.toString());
    super(`missing ${context} blocks: ${cidStr}`);
    this.context = context;
    this.cids = cids;
  }
};
var UnexpectedObjectError = class extends Error {
  constructor(cid2, def3) {
    super(`unexpected object at ${cid2.toString()}, expected: ${def3}`);
    this.cid = cid2;
    this.def = def3;
  }
};

// src/util.ts
var import_promises = require("node:timers/promises");

// ../../node_modules/.pnpm/@ipld+car@3.2.3/node_modules/@ipld/car/esm/lib/reader.js
var import_fs = __toESM(require("fs"), 1);
var import_util8 = require("util");

// ../../node_modules/.pnpm/@ipld+car@3.2.3/node_modules/@ipld/car/esm/lib/decoder.js
var import_varint2 = __toESM(require_varint(), 1);
var CIDV0_BYTES = {
  SHA2_256: 18,
  LENGTH: 32,
  DAG_PB: 112
};
async function readVarint(reader) {
  const bytes3 = await reader.upTo(8);
  const i = import_varint2.default.decode(bytes3);
  reader.seek(import_varint2.default.decode.bytes);
  return i;
}
async function readHeader(reader) {
  const length2 = await readVarint(reader);
  if (length2 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader.exactly(length2);
  reader.seek(length2);
  const block = decode7(header);
  if (block == null || Array.isArray(block) || typeof block !== "object") {
    throw new Error("Invalid CAR header format");
  }
  if (block.version !== 1) {
    if (typeof block.version === "string") {
      throw new Error(`Invalid CAR version: "${block.version}"`);
    }
    throw new Error(`Invalid CAR version: ${block.version}`);
  }
  if (!Array.isArray(block.roots)) {
    throw new Error("Invalid CAR header format");
  }
  if (Object.keys(block).filter((p) => p !== "roots" && p !== "version").length) {
    throw new Error("Invalid CAR header format");
  }
  return block;
}
async function readMultihash(reader) {
  const bytes3 = await reader.upTo(8);
  import_varint2.default.decode(bytes3);
  const codeLength = import_varint2.default.decode.bytes;
  const length2 = import_varint2.default.decode(bytes3.subarray(import_varint2.default.decode.bytes));
  const lengthLength = import_varint2.default.decode.bytes;
  const mhLength = codeLength + lengthLength + length2;
  const multihash = await reader.exactly(mhLength);
  reader.seek(mhLength);
  return multihash;
}
async function readCid(reader) {
  const first = await reader.exactly(2);
  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {
    const bytes4 = await reader.exactly(34);
    reader.seek(34);
    const multihash2 = decode3(bytes4);
    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version2 = await readVarint(reader);
  if (version2 !== 1) {
    throw new Error(`Unexpected CID version (${version2})`);
  }
  const codec = await readVarint(reader);
  const bytes3 = await readMultihash(reader);
  const multihash = decode3(bytes3);
  return CID.create(version2, codec, multihash);
}
async function readBlockHead(reader) {
  const start = reader.pos;
  let length2 = await readVarint(reader);
  if (length2 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length2 += reader.pos - start;
  const cid2 = await readCid(reader);
  const blockLength = length2 - (reader.pos - start);
  return {
    cid: cid2,
    length: length2,
    blockLength
  };
}
async function readBlock(reader) {
  const { cid: cid2, blockLength } = await readBlockHead(reader);
  const bytes3 = await reader.exactly(blockLength);
  reader.seek(blockLength);
  return {
    bytes: bytes3,
    cid: cid2
  };
}
async function readBlockIndex(reader) {
  const offset = reader.pos;
  const { cid: cid2, length: length2, blockLength } = await readBlockHead(reader);
  const index = {
    cid: cid2,
    length: length2,
    blockLength,
    offset,
    blockOffset: reader.pos
  };
  reader.seek(index.blockLength);
  return index;
}
function createDecoder(reader) {
  const headerPromise = readHeader(reader);
  return {
    header: () => headerPromise,
    async *blocks() {
      await headerPromise;
      while ((await reader.upTo(8)).length > 0) {
        yield await readBlock(reader);
      }
    },
    async *blocksIndex() {
      await headerPromise;
      while ((await reader.upTo(8)).length > 0) {
        yield await readBlockIndex(reader);
      }
    }
  };
}
function bytesReader(bytes3) {
  let pos = 0;
  return {
    async upTo(length2) {
      return bytes3.subarray(pos, pos + Math.min(length2, bytes3.length - pos));
    },
    async exactly(length2) {
      if (length2 > bytes3.length - pos) {
        throw new Error("Unexpected end of data");
      }
      return bytes3.subarray(pos, pos + length2);
    },
    seek(length2) {
      pos += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset = 0;
  let currentChunk = new Uint8Array(0);
  const read3 = async (length2) => {
    have = currentChunk.length - offset;
    const bufa = [currentChunk.subarray(offset)];
    while (have < length2) {
      const chunk = await readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
    let off = 0;
    for (const b of bufa) {
      currentChunk.set(b, off);
      off += b.length;
    }
    offset = 0;
  };
  return {
    async upTo(length2) {
      if (currentChunk.length - offset < length2) {
        await read3(length2);
      }
      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length2));
    },
    async exactly(length2) {
      if (currentChunk.length - offset < length2) {
        await read3(length2);
      }
      if (currentChunk.length - offset < length2) {
        throw new Error("Unexpected end of data");
      }
      return currentChunk.subarray(offset, offset + length2);
    },
    seek(length2) {
      pos += length2;
      offset += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  async function readChunk() {
    const next = await iterator.next();
    if (next.done) {
      return null;
    }
    return next.value;
  }
  return chunkReader(readChunk);
}

// ../../node_modules/.pnpm/@ipld+car@3.2.3/node_modules/@ipld/car/esm/lib/reader.js
var fsread = (0, import_util8.promisify)(import_fs.default.read);

// ../../node_modules/.pnpm/@ipld+car@3.2.3/node_modules/@ipld/car/esm/lib/indexer.js
var CarIndexer = class {
  constructor(version2, roots, iterator) {
    this._version = version2;
    this._roots = roots;
    this._iterator = iterator;
  }
  get version() {
    return this._version;
  }
  async getRoots() {
    return this._roots;
  }
  [Symbol.asyncIterator]() {
    return this._iterator;
  }
  static async fromBytes(bytes3) {
    if (!(bytes3 instanceof Uint8Array)) {
      throw new TypeError("fromBytes() requires a Uint8Array");
    }
    return decodeIndexerComplete(bytesReader(bytes3));
  }
  static async fromIterable(asyncIterable) {
    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
      throw new TypeError("fromIterable() requires an async iterable");
    }
    return decodeIndexerComplete(asyncIterableReader(asyncIterable));
  }
};
async function decodeIndexerComplete(reader) {
  const decoder2 = createDecoder(reader);
  const { version: version2, roots } = await decoder2.header();
  return new CarIndexer(version2, roots, decoder2.blocksIndex());
}

// ../../node_modules/.pnpm/@ipld+car@3.2.3/node_modules/@ipld/car/esm/lib/iterator.js
var CarIteratorBase = class {
  constructor(version2, roots, iterable) {
    this._version = version2;
    this._roots = roots;
    this._iterable = iterable;
    this._decoded = false;
  }
  get version() {
    return this._version;
  }
  async getRoots() {
    return this._roots;
  }
};
var CarBlockIterator = class extends CarIteratorBase {
  [Symbol.asyncIterator]() {
    if (this._decoded) {
      throw new Error("Cannot decode more than once");
    }
    if (!this._iterable) {
      throw new Error("Block iterable not found");
    }
    this._decoded = true;
    return this._iterable[Symbol.asyncIterator]();
  }
  static async fromBytes(bytes3) {
    const { version: version2, roots, iterator } = await fromBytes(bytes3);
    return new CarBlockIterator(version2, roots, iterator);
  }
  static async fromIterable(asyncIterable) {
    const { version: version2, roots, iterator } = await fromIterable(asyncIterable);
    return new CarBlockIterator(version2, roots, iterator);
  }
};
var CarCIDIterator = class extends CarIteratorBase {
  [Symbol.asyncIterator]() {
    if (this._decoded) {
      throw new Error("Cannot decode more than once");
    }
    if (!this._iterable) {
      throw new Error("Block iterable not found");
    }
    this._decoded = true;
    const iterable = this._iterable[Symbol.asyncIterator]();
    return {
      async next() {
        const next = await iterable.next();
        if (next.done) {
          return next;
        }
        return {
          done: false,
          value: next.value.cid
        };
      }
    };
  }
  static async fromBytes(bytes3) {
    const { version: version2, roots, iterator } = await fromBytes(bytes3);
    return new CarCIDIterator(version2, roots, iterator);
  }
  static async fromIterable(asyncIterable) {
    const { version: version2, roots, iterator } = await fromIterable(asyncIterable);
    return new CarCIDIterator(version2, roots, iterator);
  }
};
async function fromBytes(bytes3) {
  if (!(bytes3 instanceof Uint8Array)) {
    throw new TypeError("fromBytes() requires a Uint8Array");
  }
  return decodeIterator(bytesReader(bytes3));
}
async function fromIterable(asyncIterable) {
  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
    throw new TypeError("fromIterable() requires an async iterable");
  }
  return decodeIterator(asyncIterableReader(asyncIterable));
}
async function decodeIterator(reader) {
  const decoder2 = createDecoder(reader);
  const { version: version2, roots } = await decoder2.header();
  return {
    version: version2,
    roots,
    iterator: decoder2.blocks()
  };
}

// ../../node_modules/.pnpm/@ipld+car@3.2.3/node_modules/@ipld/car/esm/lib/writer.js
var import_fs2 = __toESM(require("fs"), 1);
var import_util9 = require("util");

// ../../node_modules/.pnpm/@ipld+car@3.2.3/node_modules/@ipld/car/esm/lib/encoder.js
var import_varint3 = __toESM(require_varint(), 1);
function createHeader(roots) {
  const headerBytes = encode7({
    version: 1,
    roots
  });
  const varintBytes = import_varint3.default.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder(writer) {
  return {
    async setRoots(roots) {
      const bytes3 = createHeader(roots);
      await writer.write(bytes3);
    },
    async writeBlock(block) {
      const { cid: cid2, bytes: bytes3 } = block;
      await writer.write(new Uint8Array(import_varint3.default.encode(cid2.bytes.length + bytes3.length)));
      await writer.write(cid2.bytes);
      if (bytes3.length) {
        await writer.write(bytes3);
      }
    },
    async close() {
      return writer.end();
    }
  };
}

// ../../node_modules/.pnpm/@ipld+car@3.2.3/node_modules/@ipld/car/esm/lib/iterator-channel.js
function noop() {
}
function create2() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop;
          resolve();
        };
      });
    }
    return drainer;
  };
  const writer = {
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    async end() {
      ended = true;
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    }
  };
  const iterator = {
    async next() {
      const chunk = chunkQueue.shift();
      if (chunk) {
        if (chunkQueue.length === 0) {
          drainerResolver();
        }
        return {
          done: false,
          value: chunk
        };
      }
      if (ended) {
        drainerResolver();
        return {
          done: true,
          value: void 0
        };
      }
      if (!outWait) {
        outWait = new Promise((resolve) => {
          outWaitResolver = () => {
            outWait = null;
            outWaitResolver = noop;
            return resolve(iterator.next());
          };
        });
      }
      return outWait;
    }
  };
  return {
    writer,
    iterator
  };
}

// ../../node_modules/.pnpm/@ipld+car@3.2.3/node_modules/@ipld/car/esm/lib/writer-browser.js
var CarWriter = class {
  constructor(roots, encoder) {
    this._encoder = encoder;
    this._mutex = encoder.setRoots(roots);
    this._ended = false;
  }
  async put(block) {
    if (!(block.bytes instanceof Uint8Array) || !block.cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    if (this._ended) {
      throw new Error("Already closed");
    }
    const cid2 = CID.asCID(block.cid);
    if (!cid2) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    this._mutex = this._mutex.then(() => this._encoder.writeBlock({
      cid: cid2,
      bytes: block.bytes
    }));
    return this._mutex;
  }
  async close() {
    if (this._ended) {
      throw new Error("Already closed");
    }
    await this._mutex;
    this._ended = true;
    return this._encoder.close();
  }
  static create(roots) {
    roots = toRoots(roots);
    const { encoder, iterator } = encodeWriter();
    const writer = new CarWriter(roots, encoder);
    const out = new CarWriterOut(iterator);
    return {
      writer,
      out
    };
  }
  static createAppender() {
    const { encoder, iterator } = encodeWriter();
    encoder.setRoots = () => Promise.resolve();
    const writer = new CarWriter([], encoder);
    const out = new CarWriterOut(iterator);
    return {
      writer,
      out
    };
  }
  static async updateRootsInBytes(bytes3, roots) {
    const reader = bytesReader(bytes3);
    await readHeader(reader);
    const newHeader = createHeader(roots);
    if (reader.pos !== newHeader.length) {
      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);
    }
    bytes3.set(newHeader, 0);
    return bytes3;
  }
};
var CarWriterOut = class {
  constructor(iterator) {
    this._iterator = iterator;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating) {
      throw new Error("Multiple iterator not supported");
    }
    this._iterating = true;
    return this._iterator;
  }
};
function encodeWriter() {
  const iw = create2();
  const { writer, iterator } = iw;
  const encoder = createEncoder(writer);
  return {
    encoder,
    iterator
  };
}
function toRoots(roots) {
  if (roots === void 0) {
    return [];
  }
  if (!Array.isArray(roots)) {
    const cid2 = CID.asCID(roots);
    if (!cid2) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid2];
  }
  const _roots = [];
  for (const root of roots) {
    const _root = CID.asCID(root);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}

// ../../node_modules/.pnpm/@ipld+car@3.2.3/node_modules/@ipld/car/esm/lib/writer.js
var fsread2 = (0, import_util9.promisify)(import_fs2.default.read);
var fswrite = (0, import_util9.promisify)(import_fs2.default.write);
var CarWriter2 = class extends CarWriter {
  static async updateRootsInFile(fd, roots) {
    const chunkSize = 256;
    let bytes3;
    let offset = 0;
    let readChunk;
    if (typeof fd === "number") {
      readChunk = async () => (await fsread2(fd, bytes3, 0, chunkSize, offset)).bytesRead;
    } else if (typeof fd === "object" && typeof fd.read === "function") {
      readChunk = async () => (await fd.read(bytes3, 0, chunkSize, offset)).bytesRead;
    } else {
      throw new TypeError("Bad fd");
    }
    const fdReader = chunkReader(async () => {
      bytes3 = new Uint8Array(chunkSize);
      const read3 = await readChunk();
      offset += read3;
      return read3 < chunkSize ? bytes3.subarray(0, read3) : bytes3;
    });
    await readHeader(fdReader);
    const newHeader = createHeader(roots);
    if (fdReader.pos !== newHeader.length) {
      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${fdReader.pos} bytes, new header is ${newHeader.length} bytes)`);
    }
    if (typeof fd === "number") {
      await fswrite(fd, newHeader, 0, newHeader.length, 0);
    } else if (typeof fd === "object" && typeof fd.read === "function") {
      await fd.write(newHeader, 0, newHeader.length, 0);
    }
  }
};

// src/util.ts
async function* verifyIncomingCarBlocks(car) {
  for await (const block of car) {
    await verifyCidForBytes(block.cid, block.bytes);
    yield block;
  }
}
function writeCarStream(root, fn) {
  const { writer, out } = root !== null ? CarWriter2.create(root) : CarWriter2.create();
  const stream = byteIterableToStream(out);
  fn(writer).catch((err) => {
    stream.destroy(err);
  }).finally(() => writer.close());
  return stream;
}
async function* writeCar(root, fn) {
  const stream = writeCarStream(root, fn);
  for await (const chunk of stream) {
    yield chunk;
  }
}
var blocksToCarStream = (root, blocks) => {
  return writeCar(root, async (writer) => {
    for (const entry of blocks.entries()) {
      await writer.put(entry);
    }
  });
};
var blocksToCarFile = (root, blocks) => {
  const carStream = blocksToCarStream(root, blocks);
  return streamToBuffer(carStream);
};
var carToBlocks = async (car) => {
  const roots = await car.getRoots();
  const blocks = new block_map_default();
  for await (const block of verifyIncomingCarBlocks(car)) {
    blocks.set(block.cid, block.bytes);
    await (0, import_promises.setImmediate)();
  }
  return {
    roots,
    blocks
  };
};
var readCar = async (bytes3) => {
  const car = await CarBlockIterator.fromBytes(bytes3);
  return carToBlocks(car);
};
var readCarStream = async (stream) => {
  const car = await CarBlockIterator.fromIterable(stream);
  return carToBlocks(car);
};
var readCarWithRoot = async (bytes3) => {
  const { roots, blocks } = await readCar(bytes3);
  if (roots.length !== 1) {
    throw new Error(`Expected one root, got ${roots.length}`);
  }
  const root = roots[0];
  return {
    root,
    blocks
  };
};
var diffToWriteDescripts = (diff) => {
  return Promise.all([
    ...diff.addList().map(async (add) => {
      const { collection, rkey } = parseDataKey(add.key);
      return {
        action: "create" /* Create */,
        collection,
        rkey,
        cid: add.cid
      };
    }),
    ...diff.updateList().map(async (upd) => {
      const { collection, rkey } = parseDataKey(upd.key);
      return {
        action: "update" /* Update */,
        collection,
        rkey,
        cid: upd.cid,
        prev: upd.prev
      };
    }),
    ...diff.deleteList().map((del) => {
      const { collection, rkey } = parseDataKey(del.key);
      return {
        action: "delete" /* Delete */,
        collection,
        rkey,
        cid: del.cid
      };
    })
  ]);
};
var ensureCreates = (descripts) => {
  const creates = [];
  for (const descript of descripts) {
    if (descript.action !== "create" /* Create */) {
      throw new Error(`Unexpected action: ${descript.action}`);
    } else {
      creates.push(descript);
    }
  }
  return creates;
};
var parseDataKey = (key) => {
  const parts = key.split("/");
  if (parts.length !== 2)
    throw new Error(`Invalid record key: ${key}`);
  return { collection: parts[0], rkey: parts[1] };
};
var formatDataKey = (collection, rkey) => {
  return collection + "/" + rkey;
};
var metaEqual = (a, b) => {
  return a.did === b.did && a.version === b.version;
};
var signCommit = async (unsigned, keypair) => {
  const encoded = encode7(unsigned);
  const sig = await keypair.sign(encoded);
  return {
    ...unsigned,
    sig
  };
};
var verifyCommitSig = async (commit2, didKey) => {
  const { sig, ...rest } = commit2;
  const encoded = encode7(rest);
  return verifySignature(didKey, encoded, sig);
};
var cborToLex = (val) => {
  return ipldToLex(cborDecode(val));
};
var cborToLexRecord = (val) => {
  const parsed = cborToLex(val);
  if (!check_exports.is(parsed, schema.map)) {
    throw new Error("lexicon records be a json object");
  }
  return parsed;
};
var cidForRecord = async (val) => {
  return cidForCbor(lexToIpld(val));
};
var ensureV3Commit = (commit2) => {
  if (commit2.version === 3) {
    return commit2;
  } else {
    return {
      ...commit2,
      version: 3,
      rev: commit2.rev ?? TID.nextStr()
    };
  }
};

// src/parse.ts
var getAndParseRecord = async (blocks, cid2) => {
  const bytes3 = blocks.get(cid2);
  if (!bytes3) {
    throw new MissingBlockError(cid2, "record");
  }
  const record = await cborToLexRecord(bytes3);
  return { record, bytes: bytes3 };
};
var getAndParseByDef = async (blocks, cid2, def3) => {
  const bytes3 = blocks.get(cid2);
  if (!bytes3) {
    throw new MissingBlockError(cid2, def3.name);
  }
  return parseObjByDef(bytes3, cid2, def3);
};
var parseObjByDef = (bytes3, cid2, def3) => {
  const obj = cborDecode(bytes3);
  const res = def3.schema.safeParse(obj);
  if (res.success) {
    return { obj: res.data, bytes: bytes3 };
  } else {
    throw new UnexpectedObjectError(cid2, def3.name);
  }
};

// src/mst/mst.ts
var subTreePointer = z.nullable(schema.cid);
var treeEntry = z.object({
  p: z.number(),
  k: schema.bytes,
  v: schema.cid,
  t: subTreePointer
});
var nodeData = z.object({
  l: subTreePointer,
  e: z.array(treeEntry)
});
var nodeDataDef = {
  name: "mst node",
  schema: nodeData
};
var MST = class {
  constructor(storage, pointer, entries, layer) {
    this.outdatedPointer = false;
    this.storage = storage;
    this.entries = entries;
    this.layer = layer;
    this.pointer = pointer;
  }
  static async create(storage, entries = [], opts) {
    const pointer = await cidForEntries(entries);
    const { layer = null } = opts || {};
    return new MST(storage, pointer, entries, layer);
  }
  static async fromData(storage, data, opts) {
    const { layer = null } = opts || {};
    const entries = await deserializeNodeData(storage, data, opts);
    const pointer = await cidForCbor(data);
    return new MST(storage, pointer, entries, layer);
  }
  static load(storage, cid2, opts) {
    const { layer = null } = opts || {};
    return new MST(storage, cid2, null, layer);
  }
  async newTree(entries) {
    const mst = new MST(this.storage, this.pointer, entries, this.layer);
    mst.outdatedPointer = true;
    return mst;
  }
  async getEntries() {
    if (this.entries)
      return [...this.entries];
    if (this.pointer) {
      const data = await this.storage.readObj(this.pointer, nodeDataDef);
      const firstLeaf = data.e[0];
      const layer = firstLeaf !== void 0 ? await leadingZerosOnHash(firstLeaf.k) : void 0;
      this.entries = await deserializeNodeData(this.storage, data, {
        layer
      });
      return this.entries;
    }
    throw new Error("No entries or CID provided");
  }
  async getPointer() {
    if (!this.outdatedPointer)
      return this.pointer;
    const { cid: cid2 } = await this.serialize();
    this.pointer = cid2;
    this.outdatedPointer = false;
    return this.pointer;
  }
  async serialize() {
    let entries = await this.getEntries();
    const outdated = entries.filter((e) => e.isTree() && e.outdatedPointer);
    if (outdated.length > 0) {
      await Promise.all(outdated.map((e) => e.getPointer()));
      entries = await this.getEntries();
    }
    const data = serializeNodeData(entries);
    const block = await dataToCborBlock(data);
    return {
      cid: block.cid,
      bytes: block.bytes
    };
  }
  async getLayer() {
    this.layer = await this.attemptGetLayer();
    if (this.layer === null)
      this.layer = 0;
    return this.layer;
  }
  async attemptGetLayer() {
    if (this.layer !== null)
      return this.layer;
    const entries = await this.getEntries();
    let layer = await layerForEntries(entries);
    if (layer === null) {
      for (const entry of entries) {
        if (entry.isTree()) {
          const childLayer = await entry.attemptGetLayer();
          if (childLayer !== null) {
            layer = childLayer + 1;
            break;
          }
        }
      }
    }
    if (layer !== null)
      this.layer = layer;
    return layer;
  }
  async getUnstoredBlocks() {
    const blocks = new block_map_default();
    const pointer = await this.getPointer();
    const alreadyHas = await this.storage.has(pointer);
    if (alreadyHas)
      return { root: pointer, blocks };
    const entries = await this.getEntries();
    const data = serializeNodeData(entries);
    await blocks.add(data);
    for (const entry of entries) {
      if (entry.isTree()) {
        const subtree = await entry.getUnstoredBlocks();
        blocks.addMap(subtree.blocks);
      }
    }
    return { root: pointer, blocks };
  }
  async add(key, value, knownZeros) {
    ensureValidMstKey(key);
    const keyZeros = knownZeros ?? await leadingZerosOnHash(key);
    const layer = await this.getLayer();
    const newLeaf = new Leaf(key, value);
    if (keyZeros === layer) {
      const index = await this.findGtOrEqualLeafIndex(key);
      const found = await this.atIndex(index);
      if (found?.isLeaf() && found.key === key) {
        throw new Error(`There is already a value at key: ${key}`);
      }
      const prevNode = await this.atIndex(index - 1);
      if (!prevNode || prevNode.isLeaf()) {
        return this.spliceIn(newLeaf, index);
      } else {
        const splitSubTree = await prevNode.splitAround(key);
        return this.replaceWithSplit(index - 1, splitSubTree[0], newLeaf, splitSubTree[1]);
      }
    } else if (keyZeros < layer) {
      const index = await this.findGtOrEqualLeafIndex(key);
      const prevNode = await this.atIndex(index - 1);
      if (prevNode && prevNode.isTree()) {
        const newSubtree = await prevNode.add(key, value, keyZeros);
        return this.updateEntry(index - 1, newSubtree);
      } else {
        const subTree = await this.createChild();
        const newSubTree = await subTree.add(key, value, keyZeros);
        return this.spliceIn(newSubTree, index);
      }
    } else {
      const split = await this.splitAround(key);
      let left = split[0];
      let right = split[1];
      const layer2 = await this.getLayer();
      const extraLayersToAdd = keyZeros - layer2;
      for (let i = 1; i < extraLayersToAdd; i++) {
        if (left !== null) {
          left = await left.createParent();
        }
        if (right !== null) {
          right = await right.createParent();
        }
      }
      const updated = [];
      if (left)
        updated.push(left);
      updated.push(new Leaf(key, value));
      if (right)
        updated.push(right);
      const newRoot = await MST.create(this.storage, updated, {
        layer: keyZeros
      });
      newRoot.outdatedPointer = true;
      return newRoot;
    }
  }
  async get(key) {
    const index = await this.findGtOrEqualLeafIndex(key);
    const found = await this.atIndex(index);
    if (found && found.isLeaf() && found.key === key) {
      return found.value;
    }
    const prev = await this.atIndex(index - 1);
    if (prev && prev.isTree()) {
      return prev.get(key);
    }
    return null;
  }
  async update(key, value) {
    ensureValidMstKey(key);
    const index = await this.findGtOrEqualLeafIndex(key);
    const found = await this.atIndex(index);
    if (found && found.isLeaf() && found.key === key) {
      return this.updateEntry(index, new Leaf(key, value));
    }
    const prev = await this.atIndex(index - 1);
    if (prev && prev.isTree()) {
      const updatedTree = await prev.update(key, value);
      return this.updateEntry(index - 1, updatedTree);
    }
    throw new Error(`Could not find a record with key: ${key}`);
  }
  async delete(key) {
    const altered = await this.deleteRecurse(key);
    return altered.trimTop();
  }
  async deleteRecurse(key) {
    const index = await this.findGtOrEqualLeafIndex(key);
    const found = await this.atIndex(index);
    if (found?.isLeaf() && found.key === key) {
      const prev2 = await this.atIndex(index - 1);
      const next = await this.atIndex(index + 1);
      if (prev2?.isTree() && next?.isTree()) {
        const merged = await prev2.appendMerge(next);
        return this.newTree([
          ...await this.slice(0, index - 1),
          merged,
          ...await this.slice(index + 2)
        ]);
      } else {
        return this.removeEntry(index);
      }
    }
    const prev = await this.atIndex(index - 1);
    if (prev?.isTree()) {
      const subtree = await prev.deleteRecurse(key);
      const subTreeEntries = await subtree.getEntries();
      if (subTreeEntries.length === 0) {
        return this.removeEntry(index - 1);
      } else {
        return this.updateEntry(index - 1, subtree);
      }
    } else {
      throw new Error(`Could not find a record with key: ${key}`);
    }
  }
  async updateEntry(index, entry) {
    const update = [
      ...await this.slice(0, index),
      entry,
      ...await this.slice(index + 1)
    ];
    return this.newTree(update);
  }
  async removeEntry(index) {
    const updated = [
      ...await this.slice(0, index),
      ...await this.slice(index + 1)
    ];
    return this.newTree(updated);
  }
  async append(entry) {
    const entries = await this.getEntries();
    return this.newTree([...entries, entry]);
  }
  async prepend(entry) {
    const entries = await this.getEntries();
    return this.newTree([entry, ...entries]);
  }
  async atIndex(index) {
    const entries = await this.getEntries();
    return entries[index] ?? null;
  }
  async slice(start, end) {
    const entries = await this.getEntries();
    return entries.slice(start, end);
  }
  async spliceIn(entry, index) {
    const update = [
      ...await this.slice(0, index),
      entry,
      ...await this.slice(index)
    ];
    return this.newTree(update);
  }
  async replaceWithSplit(index, left, leaf, right) {
    const update = await this.slice(0, index);
    if (left)
      update.push(left);
    update.push(leaf);
    if (right)
      update.push(right);
    update.push(...await this.slice(index + 1));
    return this.newTree(update);
  }
  async trimTop() {
    const entries = await this.getEntries();
    if (entries.length === 1 && entries[0].isTree()) {
      return entries[0].trimTop();
    } else {
      return this;
    }
  }
  async splitAround(key) {
    const index = await this.findGtOrEqualLeafIndex(key);
    const leftData = await this.slice(0, index);
    const rightData = await this.slice(index);
    let left = await this.newTree(leftData);
    let right = await this.newTree(rightData);
    const lastInLeft = leftData[leftData.length - 1];
    if (lastInLeft?.isTree()) {
      left = await left.removeEntry(leftData.length - 1);
      const split = await lastInLeft.splitAround(key);
      if (split[0]) {
        left = await left.append(split[0]);
      }
      if (split[1]) {
        right = await right.prepend(split[1]);
      }
    }
    return [
      (await left.getEntries()).length > 0 ? left : null,
      (await right.getEntries()).length > 0 ? right : null
    ];
  }
  async appendMerge(toMerge) {
    if (await this.getLayer() !== await toMerge.getLayer()) {
      throw new Error("Trying to merge two nodes from different layers of the MST");
    }
    const thisEntries = await this.getEntries();
    const toMergeEntries = await toMerge.getEntries();
    const lastInLeft = thisEntries[thisEntries.length - 1];
    const firstInRight = toMergeEntries[0];
    if (lastInLeft?.isTree() && firstInRight?.isTree()) {
      const merged = await lastInLeft.appendMerge(firstInRight);
      return this.newTree([
        ...thisEntries.slice(0, thisEntries.length - 1),
        merged,
        ...toMergeEntries.slice(1)
      ]);
    } else {
      return this.newTree([...thisEntries, ...toMergeEntries]);
    }
  }
  async createChild() {
    const layer = await this.getLayer();
    return MST.create(this.storage, [], {
      layer: layer - 1
    });
  }
  async createParent() {
    const layer = await this.getLayer();
    const parent = await MST.create(this.storage, [this], {
      layer: layer + 1
    });
    parent.outdatedPointer = true;
    return parent;
  }
  async findGtOrEqualLeafIndex(key) {
    const entries = await this.getEntries();
    const maybeIndex = entries.findIndex((entry) => entry.isLeaf() && entry.key >= key);
    return maybeIndex >= 0 ? maybeIndex : entries.length;
  }
  async *walkLeavesFrom(key) {
    const index = await this.findGtOrEqualLeafIndex(key);
    const entries = await this.getEntries();
    const prev = entries[index - 1];
    if (prev && prev.isTree()) {
      for await (const e of prev.walkLeavesFrom(key)) {
        yield e;
      }
    }
    for (let i = index; i < entries.length; i++) {
      const entry = entries[i];
      if (entry.isLeaf()) {
        yield entry;
      } else {
        for await (const e of entry.walkLeavesFrom(key)) {
          yield e;
        }
      }
    }
  }
  async list(count = Number.MAX_SAFE_INTEGER, after, before) {
    const vals = [];
    for await (const leaf of this.walkLeavesFrom(after || "")) {
      if (leaf.key === after)
        continue;
      if (vals.length >= count)
        break;
      if (before && leaf.key >= before)
        break;
      vals.push(leaf);
    }
    return vals;
  }
  async listWithPrefix(prefix, count = Number.MAX_SAFE_INTEGER) {
    const vals = [];
    for await (const leaf of this.walkLeavesFrom(prefix)) {
      if (vals.length >= count || !leaf.key.startsWith(prefix))
        break;
      vals.push(leaf);
    }
    return vals;
  }
  async *walk() {
    yield this;
    const entries = await this.getEntries();
    for (const entry of entries) {
      if (entry.isTree()) {
        for await (const e of entry.walk()) {
          yield e;
        }
      } else {
        yield entry;
      }
    }
  }
  async paths() {
    const entries = await this.getEntries();
    let paths = [];
    for (const entry of entries) {
      if (entry.isLeaf()) {
        paths.push([entry]);
      }
      if (entry.isTree()) {
        const subPaths = await entry.paths();
        paths = [...paths, ...subPaths.map((p) => [entry, ...p])];
      }
    }
    return paths;
  }
  async allNodes() {
    const nodes = [];
    for await (const entry of this.walk()) {
      nodes.push(entry);
    }
    return nodes;
  }
  async allCids() {
    const cids = new cid_set_default();
    const entries = await this.getEntries();
    for (const entry of entries) {
      if (entry.isLeaf()) {
        cids.add(entry.value);
      } else {
        const subtreeCids = await entry.allCids();
        cids.addSet(subtreeCids);
      }
    }
    cids.add(await this.getPointer());
    return cids;
  }
  async leaves() {
    const leaves = [];
    for await (const entry of this.walk()) {
      if (entry.isLeaf())
        leaves.push(entry);
    }
    return leaves;
  }
  async leafCount() {
    const leaves = await this.leaves();
    return leaves.length;
  }
  async *walkReachable() {
    yield this;
    const entries = await this.getEntries();
    for (const entry of entries) {
      if (entry.isTree()) {
        try {
          for await (const e of entry.walkReachable()) {
            yield e;
          }
        } catch (err) {
          if (err instanceof MissingBlockError) {
            continue;
          } else {
            throw err;
          }
        }
      } else {
        yield entry;
      }
    }
  }
  async reachableLeaves() {
    const leaves = [];
    for await (const entry of this.walkReachable()) {
      if (entry.isLeaf())
        leaves.push(entry);
    }
    return leaves;
  }
  async writeToCarStream(car) {
    const leaves = new cid_set_default();
    let toFetch = new cid_set_default();
    toFetch.add(await this.getPointer());
    while (toFetch.size() > 0) {
      const nextLayer = new cid_set_default();
      const fetched = await this.storage.getBlocks(toFetch.toList());
      if (fetched.missing.length > 0) {
        throw new MissingBlocksError("mst node", fetched.missing);
      }
      for (const cid2 of toFetch.toList()) {
        const found = await getAndParseByDef(fetched.blocks, cid2, nodeDataDef);
        await car.put({ cid: cid2, bytes: found.bytes });
        const entries = await deserializeNodeData(this.storage, found.obj);
        for (const entry of entries) {
          if (entry.isLeaf()) {
            leaves.add(entry.value);
          } else {
            nextLayer.add(await entry.getPointer());
          }
        }
      }
      toFetch = nextLayer;
    }
    const leafData = await this.storage.getBlocks(leaves.toList());
    if (leafData.missing.length > 0) {
      throw new MissingBlocksError("mst leaf", leafData.missing);
    }
    for (const leaf of leafData.blocks.entries()) {
      await car.put(leaf);
    }
  }
  async cidsForPath(key) {
    const cids = [await this.getPointer()];
    const index = await this.findGtOrEqualLeafIndex(key);
    const found = await this.atIndex(index);
    if (found && found.isLeaf() && found.key === key) {
      return [...cids, found.value];
    }
    const prev = await this.atIndex(index - 1);
    if (prev && prev.isTree()) {
      return [...cids, ...await prev.cidsForPath(key)];
    }
    return cids;
  }
  isTree() {
    return true;
  }
  isLeaf() {
    return false;
  }
  async equals(other) {
    if (other.isLeaf())
      return false;
    const thisPointer = await this.getPointer();
    const otherPointer = await other.getPointer();
    return thisPointer.equals(otherPointer);
  }
};
var Leaf = class {
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  isTree() {
    return false;
  }
  isLeaf() {
    return true;
  }
  equals(entry) {
    if (entry.isLeaf()) {
      return this.key === entry.key && this.value.equals(entry.value);
    } else {
      return false;
    }
  }
};

// src/data-diff.ts
var DataDiff = class {
  constructor() {
    this.adds = {};
    this.updates = {};
    this.deletes = {};
    this.newMstBlocks = new block_map_default();
    this.newLeafCids = new cid_set_default();
    this.removedCids = new cid_set_default();
  }
  static async of(curr, prev) {
    return mstDiff(curr, prev);
  }
  async nodeAdd(node) {
    if (node.isLeaf()) {
      this.leafAdd(node.key, node.value);
    } else {
      const data = await node.serialize();
      this.treeAdd(data.cid, data.bytes);
    }
  }
  async nodeDelete(node) {
    if (node.isLeaf()) {
      const key = node.key;
      const cid2 = node.value;
      this.deletes[key] = { key, cid: cid2 };
      this.removedCids.add(cid2);
    } else {
      const cid2 = await node.getPointer();
      this.treeDelete(cid2);
    }
  }
  leafAdd(key, cid2) {
    this.adds[key] = { key, cid: cid2 };
    if (this.removedCids.has(cid2)) {
      this.removedCids.delete(cid2);
    } else {
      this.newLeafCids.add(cid2);
    }
  }
  leafUpdate(key, prev, cid2) {
    if (prev.equals(cid2))
      return;
    this.updates[key] = { key, prev, cid: cid2 };
    this.removedCids.add(prev);
    this.newLeafCids.add(cid2);
  }
  leafDelete(key, cid2) {
    this.deletes[key] = { key, cid: cid2 };
    if (this.newLeafCids.has(cid2)) {
      this.newLeafCids.delete(cid2);
    } else {
      this.removedCids.add(cid2);
    }
  }
  treeAdd(cid2, bytes3) {
    if (this.removedCids.has(cid2)) {
      this.removedCids.delete(cid2);
    } else {
      this.newMstBlocks.set(cid2, bytes3);
    }
  }
  treeDelete(cid2) {
    if (this.newMstBlocks.has(cid2)) {
      this.newMstBlocks.delete(cid2);
    } else {
      this.removedCids.add(cid2);
    }
  }
  addList() {
    return Object.values(this.adds);
  }
  updateList() {
    return Object.values(this.updates);
  }
  deleteList() {
    return Object.values(this.deletes);
  }
  updatedKeys() {
    const keys = [
      ...Object.keys(this.adds),
      ...Object.keys(this.updates),
      ...Object.keys(this.deletes)
    ];
    return [...new Set(keys)];
  }
};
var data_diff_default = DataDiff;

// src/mst/walker.ts
var MstWalker = class {
  constructor(root) {
    this.root = root;
    this.stack = [];
    this.status = {
      done: false,
      curr: root,
      walking: null,
      index: 0
    };
  }
  layer() {
    if (this.status.done) {
      throw new Error("Walk is done");
    }
    if (this.status.walking) {
      return this.status.walking.layer ?? 0;
    }
    if (this.status.curr.isTree()) {
      return (this.status.curr.layer ?? 0) + 1;
    }
    throw new Error("Could not identify layer of walk");
  }
  async stepOver() {
    if (this.status.done)
      return;
    if (this.status.walking === null) {
      this.status = { done: true };
      return;
    }
    const entries = await this.status.walking.getEntries();
    this.status.index++;
    const next = entries[this.status.index];
    if (!next) {
      const popped = this.stack.pop();
      if (!popped) {
        this.status = { done: true };
        return;
      } else {
        this.status = popped;
        await this.stepOver();
        return;
      }
    } else {
      this.status.curr = next;
    }
  }
  async stepInto() {
    if (this.status.done)
      return;
    if (this.status.walking === null) {
      if (!this.status.curr.isTree()) {
        throw new Error("The root of the tree cannot be a leaf");
      }
      const next2 = await this.status.curr.atIndex(0);
      if (!next2) {
        this.status = { done: true };
      } else {
        this.status = {
          done: false,
          walking: this.status.curr,
          curr: next2,
          index: 0
        };
      }
      return;
    }
    if (!this.status.curr.isTree()) {
      throw new Error("No tree at pointer, cannot step into");
    }
    const next = await this.status.curr.atIndex(0);
    if (!next) {
      throw new Error("Tried to step into a node with 0 entries which is invalid");
    }
    this.stack.push({ ...this.status });
    this.status.walking = this.status.curr;
    this.status.curr = next;
    this.status.index = 0;
  }
  async advance() {
    if (this.status.done)
      return;
    if (this.status.curr.isLeaf()) {
      await this.stepOver();
    } else {
      await this.stepInto();
    }
  }
};
var walker_default = MstWalker;

// src/mst/diff.ts
var nullDiff = async (tree2) => {
  const diff = new DataDiff();
  for await (const entry of tree2.walk()) {
    await diff.nodeAdd(entry);
  }
  return diff;
};
var mstDiff = async (curr, prev) => {
  await curr.getPointer();
  if (prev === null) {
    return nullDiff(curr);
  }
  await prev.getPointer();
  const diff = new DataDiff();
  const leftWalker = new walker_default(prev);
  const rightWalker = new walker_default(curr);
  while (!leftWalker.status.done || !rightWalker.status.done) {
    if (leftWalker.status.done && !rightWalker.status.done) {
      await diff.nodeAdd(rightWalker.status.curr);
      await rightWalker.advance();
      continue;
    } else if (!leftWalker.status.done && rightWalker.status.done) {
      await diff.nodeDelete(leftWalker.status.curr);
      await leftWalker.advance();
      continue;
    }
    if (leftWalker.status.done || rightWalker.status.done)
      break;
    const left = leftWalker.status.curr;
    const right = rightWalker.status.curr;
    if (left === null || right === null)
      break;
    if (left.isLeaf() && right.isLeaf()) {
      if (left.key === right.key) {
        if (!left.value.equals(right.value)) {
          diff.leafUpdate(left.key, left.value, right.value);
        }
        await leftWalker.advance();
        await rightWalker.advance();
      } else if (left.key < right.key) {
        diff.leafDelete(left.key, left.value);
        await leftWalker.advance();
      } else {
        diff.leafAdd(right.key, right.value);
        await rightWalker.advance();
      }
      continue;
    }
    if (leftWalker.layer() > rightWalker.layer()) {
      if (left.isLeaf()) {
        await diff.nodeAdd(right);
        await rightWalker.advance();
      } else {
        await diff.nodeDelete(left);
        await leftWalker.stepInto();
      }
      continue;
    } else if (leftWalker.layer() < rightWalker.layer()) {
      if (right.isLeaf()) {
        await diff.nodeDelete(left);
        await leftWalker.advance();
      } else {
        await diff.nodeAdd(right);
        await rightWalker.stepInto();
      }
      continue;
    }
    if (left.isTree() && right.isTree()) {
      if (left.pointer.equals(right.pointer)) {
        await leftWalker.stepOver();
        await rightWalker.stepOver();
      } else {
        await diff.nodeAdd(right);
        await diff.nodeDelete(left);
        await leftWalker.stepInto();
        await rightWalker.stepInto();
      }
      continue;
    }
    if (left.isLeaf() && right.isTree()) {
      await diff.nodeAdd(right);
      await rightWalker.stepInto();
      continue;
    } else if (left.isTree() && right.isLeaf()) {
      await diff.nodeDelete(left);
      await leftWalker.stepInto();
      continue;
    }
    throw new Error("Unidentifiable case in diff walk");
  }
  return diff;
};

// src/logger.ts
var logger = subsystemLogger("repo");
var logger_default = logger;

// src/readable-repo.ts
var ReadableRepo = class {
  constructor(params2) {
    this.storage = params2.storage;
    this.data = params2.data;
    this.commit = params2.commit;
    this.cid = params2.cid;
  }
  static async load(storage, commitCid) {
    const commit2 = await storage.readObj(commitCid, def2.versionedCommit);
    const data = await MST.load(storage, commit2.data);
    logger_default.info({ did: commit2.did }, "loaded repo for");
    return new ReadableRepo({
      storage,
      data,
      commit: ensureV3Commit(commit2),
      cid: commitCid
    });
  }
  get did() {
    return this.commit.did;
  }
  get version() {
    return this.commit.version;
  }
  async *walkRecords(from3) {
    for await (const leaf of this.data.walkLeavesFrom(from3 ?? "")) {
      const { collection, rkey } = parseDataKey(leaf.key);
      const record = await this.storage.readRecord(leaf.value);
      yield { collection, rkey, cid: leaf.value, record };
    }
  }
  async getRecord(collection, rkey) {
    const dataKey = collection + "/" + rkey;
    const cid2 = await this.data.get(dataKey);
    if (!cid2)
      return null;
    return this.storage.readObj(cid2, def2.unknown);
  }
  async getContents() {
    const entries = await this.data.list();
    const cids = entries.map((e) => e.value);
    const { blocks, missing } = await this.storage.getBlocks(cids);
    if (missing.length > 0) {
      throw new MissingBlocksError("getContents record", missing);
    }
    const contents = {};
    for (const entry of entries) {
      const { collection, rkey } = parseDataKey(entry.key);
      contents[collection] ?? (contents[collection] = {});
      const parsed = await getAndParseRecord(blocks, entry.value);
      contents[collection][rkey] = parsed.record;
    }
    return contents;
  }
};
var readable_repo_default = ReadableRepo;

// src/repo.ts
var Repo = class extends ReadableRepo {
  constructor(params2) {
    super(params2);
    this.storage = params2.storage;
  }
  static async formatInitCommit(storage, did2, keypair, initialWrites = []) {
    const newBlocks = new block_map_default();
    let data = await MST.create(storage);
    for (const record of initialWrites) {
      const cid2 = await newBlocks.add(record.record);
      const dataKey = formatDataKey(record.collection, record.rkey);
      data = await data.add(dataKey, cid2);
    }
    const dataCid = await data.getPointer();
    const diff = await data_diff_default.of(data, null);
    newBlocks.addMap(diff.newMstBlocks);
    const rev = TID.nextStr();
    const commit2 = await signCommit({
      did: did2,
      version: 3,
      rev,
      prev: null,
      data: dataCid
    }, keypair);
    const commitCid = await newBlocks.add(commit2);
    return {
      cid: commitCid,
      rev,
      since: null,
      prev: null,
      newBlocks,
      removedCids: diff.removedCids
    };
  }
  static async createFromCommit(storage, commit2) {
    await storage.applyCommit(commit2);
    return Repo.load(storage, commit2.cid);
  }
  static async create(storage, did2, keypair, initialWrites = []) {
    const commit2 = await Repo.formatInitCommit(storage, did2, keypair, initialWrites);
    return Repo.createFromCommit(storage, commit2);
  }
  static async load(storage, cid2) {
    const commitCid = cid2 || await storage.getRoot();
    if (!commitCid) {
      throw new Error("No cid provided and none in storage");
    }
    const commit2 = await storage.readObj(commitCid, def2.versionedCommit);
    const data = await MST.load(storage, commit2.data);
    logger_default.info({ did: commit2.did }, "loaded repo for");
    return new Repo({
      storage,
      data,
      commit: ensureV3Commit(commit2),
      cid: commitCid
    });
  }
  async formatCommit(toWrite, keypair) {
    const writes = Array.isArray(toWrite) ? toWrite : [toWrite];
    const leaves = new block_map_default();
    let data = this.data;
    for (const write of writes) {
      if (write.action === "create" /* Create */) {
        const cid2 = await leaves.add(write.record);
        const dataKey = write.collection + "/" + write.rkey;
        data = await data.add(dataKey, cid2);
      } else if (write.action === "update" /* Update */) {
        const cid2 = await leaves.add(write.record);
        const dataKey = write.collection + "/" + write.rkey;
        data = await data.update(dataKey, cid2);
      } else if (write.action === "delete" /* Delete */) {
        const dataKey = write.collection + "/" + write.rkey;
        data = await data.delete(dataKey);
      }
    }
    const dataCid = await data.getPointer();
    const diff = await data_diff_default.of(data, this.data);
    const newBlocks = diff.newMstBlocks;
    const removedCids = diff.removedCids;
    const addedLeaves = leaves.getMany(diff.newLeafCids.toList());
    if (addedLeaves.missing.length > 0) {
      throw new Error(`Missing leaf blocks: ${addedLeaves.missing}`);
    }
    newBlocks.addMap(addedLeaves.blocks);
    const rev = TID.nextStr(this.commit.rev);
    const commit2 = await signCommit({
      did: this.did,
      version: 3,
      rev,
      prev: null,
      data: dataCid
    }, keypair);
    const commitCid = await newBlocks.add(commit2);
    if (commitCid.equals(this.cid)) {
      newBlocks.delete(commitCid);
    } else {
      removedCids.add(this.cid);
    }
    return {
      cid: commitCid,
      rev,
      since: this.commit.rev,
      prev: this.cid,
      newBlocks,
      removedCids
    };
  }
  async applyCommit(commitData) {
    await this.storage.applyCommit(commitData);
    return Repo.load(this.storage, commitData.cid);
  }
  async applyWrites(toWrite, keypair) {
    const commit2 = await this.formatCommit(toWrite, keypair);
    return this.applyCommit(commit2);
  }
  async formatResignCommit(rev, keypair) {
    const commit2 = await signCommit({
      did: this.did,
      version: 3,
      rev,
      prev: null,
      data: this.commit.data
    }, keypair);
    const newBlocks = new block_map_default();
    const commitCid = await newBlocks.add(commit2);
    return {
      cid: commitCid,
      rev,
      since: null,
      prev: null,
      newBlocks,
      removedCids: new cid_set_default([this.cid])
    };
  }
  async resignCommit(rev, keypair) {
    const formatted = await this.formatResignCommit(rev, keypair);
    return this.applyCommit(formatted);
  }
};

// src/storage/readable-blockstore.ts
var ReadableBlockstore = class {
  async attemptRead(cid2, def3) {
    const bytes3 = await this.getBytes(cid2);
    if (!bytes3)
      return null;
    return parseObjByDef(bytes3, cid2, def3);
  }
  async readObjAndBytes(cid2, def3) {
    const read3 = await this.attemptRead(cid2, def3);
    if (!read3) {
      throw new MissingBlockError(cid2, def3.name);
    }
    return read3;
  }
  async readObj(cid2, def3) {
    const obj = await this.readObjAndBytes(cid2, def3);
    return obj.obj;
  }
  async attemptReadRecord(cid2) {
    try {
      return await this.readRecord(cid2);
    } catch {
      return null;
    }
  }
  async readRecord(cid2) {
    const bytes3 = await this.getBytes(cid2);
    if (!bytes3) {
      throw new MissingBlockError(cid2);
    }
    return cborToLexRecord(bytes3);
  }
};
var readable_blockstore_default = ReadableBlockstore;

// src/storage/memory-blockstore.ts
var MemoryBlockstore = class extends readable_blockstore_default {
  constructor(blocks) {
    super();
    this.root = null;
    this.rev = null;
    this.blocks = new block_map_default();
    if (blocks) {
      this.blocks.addMap(blocks);
    }
  }
  async getRoot() {
    return this.root;
  }
  async getBytes(cid2) {
    return this.blocks.get(cid2) || null;
  }
  async has(cid2) {
    return this.blocks.has(cid2);
  }
  async getBlocks(cids) {
    return this.blocks.getMany(cids);
  }
  async putBlock(cid2, block) {
    this.blocks.set(cid2, block);
  }
  async putMany(blocks) {
    this.blocks.addMap(blocks);
  }
  async updateRoot(cid2, rev) {
    this.root = cid2;
    this.rev = rev;
  }
  async applyCommit(commit2) {
    this.root = commit2.cid;
    const rmCids = commit2.removedCids.toList();
    for (const cid2 of rmCids) {
      this.blocks.delete(cid2);
    }
    commit2.newBlocks.forEach((bytes3, cid2) => {
      this.blocks.set(cid2, bytes3);
    });
  }
  async sizeInBytes() {
    let total = 0;
    this.blocks.forEach((bytes3) => {
      total += bytes3.byteLength;
    });
    return total;
  }
  async destroy() {
    this.blocks.clear();
  }
};

// src/storage/sync-storage.ts
var SyncStorage = class extends readable_blockstore_default {
  constructor(staged, saved) {
    super();
    this.staged = staged;
    this.saved = saved;
  }
  async getBytes(cid2) {
    const got = await this.staged.getBytes(cid2);
    if (got)
      return got;
    return this.saved.getBytes(cid2);
  }
  async getBlocks(cids) {
    const fromStaged = await this.staged.getBlocks(cids);
    const fromSaved = await this.saved.getBlocks(fromStaged.missing);
    const blocks = fromStaged.blocks;
    blocks.addMap(fromSaved.blocks);
    return {
      blocks,
      missing: fromSaved.missing
    };
  }
  async has(cid2) {
    return await this.staged.has(cid2) || await this.saved.has(cid2);
  }
};

// src/storage/types.ts
var BlobNotFoundError = class extends Error {
};

// src/sync/consumer.ts
var verifyRepoCar = async (carBytes, did2, signingKey) => {
  const car = await readCarWithRoot(carBytes);
  return verifyRepo(car.blocks, car.root, did2, signingKey);
};
var verifyRepo = async (blocks, head, did2, signingKey, opts) => {
  const diff = await verifyDiff(null, blocks, head, did2, signingKey, opts);
  const creates = ensureCreates(diff.writes);
  return {
    creates,
    commit: diff.commit
  };
};
var verifyDiffCar = async (repo, carBytes, did2, signingKey, opts) => {
  const car = await readCarWithRoot(carBytes);
  return verifyDiff(repo, car.blocks, car.root, did2, signingKey, opts);
};
var verifyDiff = async (repo, updateBlocks, updateRoot, did2, signingKey, opts) => {
  const { ensureLeaves = true } = opts ?? {};
  const stagedStorage = new MemoryBlockstore(updateBlocks);
  const updateStorage = repo ? new SyncStorage(stagedStorage, repo.storage) : stagedStorage;
  const updated = await verifyRepoRoot(updateStorage, updateRoot, did2, signingKey);
  const diff = await data_diff_default.of(updated.data, repo?.data ?? null);
  const writes = await diffToWriteDescripts(diff);
  const newBlocks = diff.newMstBlocks;
  const leaves = updateBlocks.getMany(diff.newLeafCids.toList());
  if (leaves.missing.length > 0 && ensureLeaves) {
    throw new Error(`missing leaf blocks: ${leaves.missing}`);
  }
  newBlocks.addMap(leaves.blocks);
  const removedCids = diff.removedCids;
  const commitCid = await newBlocks.add(updated.commit);
  if (repo) {
    if (commitCid.equals(repo.cid)) {
      newBlocks.delete(commitCid);
    } else {
      removedCids.add(repo.cid);
    }
  }
  return {
    writes,
    commit: {
      cid: updated.cid,
      rev: updated.commit.rev,
      prev: repo?.cid ?? null,
      since: repo?.commit.rev ?? null,
      newBlocks,
      removedCids
    }
  };
};
var verifyRepoRoot = async (storage, head, did2, signingKey) => {
  const repo = await readable_repo_default.load(storage, head);
  if (did2 !== void 0 && repo.did !== did2) {
    throw new RepoVerificationError(`Invalid repo did: ${repo.did}`);
  }
  if (signingKey !== void 0) {
    const validSig = await verifyCommitSig(repo.commit, signingKey);
    if (!validSig) {
      throw new RepoVerificationError(`Invalid signature on commit: ${repo.cid.toString()}`);
    }
  }
  return repo;
};
var verifyProofs = async (proofs, claims, did2, didKey) => {
  const car = await readCarWithRoot(proofs);
  const blockstore = new MemoryBlockstore(car.blocks);
  const commit2 = await blockstore.readObj(car.root, def2.commit);
  if (commit2.did !== did2) {
    throw new RepoVerificationError(`Invalid repo did: ${commit2.did}`);
  }
  const validSig = await verifyCommitSig(commit2, didKey);
  if (!validSig) {
    throw new RepoVerificationError(`Invalid signature on commit: ${car.root.toString()}`);
  }
  const mst = MST.load(blockstore, commit2.data);
  const verified = [];
  const unverified = [];
  for (const claim of claims) {
    const found = await mst.get(formatDataKey(claim.collection, claim.rkey));
    const record = found ? await blockstore.readObj(found, def2.map) : null;
    if (claim.record === null) {
      if (record === null) {
        verified.push(claim);
      } else {
        unverified.push(claim);
      }
    } else {
      const expected = await cidForCbor(claim.record);
      if (expected.equals(found)) {
        verified.push(claim);
      } else {
        unverified.push(claim);
      }
    }
  }
  return { verified, unverified };
};
var verifyRecords = async (proofs, did2, signingKey) => {
  const car = await readCarWithRoot(proofs);
  const blockstore = new MemoryBlockstore(car.blocks);
  const commit2 = await blockstore.readObj(car.root, def2.commit);
  if (commit2.did !== did2) {
    throw new RepoVerificationError(`Invalid repo did: ${commit2.did}`);
  }
  const validSig = await verifyCommitSig(commit2, signingKey);
  if (!validSig) {
    throw new RepoVerificationError(`Invalid signature on commit: ${car.root.toString()}`);
  }
  const mst = MST.load(blockstore, commit2.data);
  const records = [];
  const leaves = await mst.reachableLeaves();
  for (const leaf of leaves) {
    const { collection, rkey } = parseDataKey(leaf.key);
    const record = await blockstore.attemptReadRecord(leaf.value);
    if (record) {
      records.push({
        collection,
        rkey,
        record
      });
    }
  }
  return records;
};
var RepoVerificationError = class extends Error {
};

// src/sync/provider.ts
var getFullRepo = (storage, commitCid) => {
  return writeCar(commitCid, async (car) => {
    const commit2 = await storage.readObjAndBytes(commitCid, def2.commit);
    await car.put({ cid: commitCid, bytes: commit2.bytes });
    const mst = MST.load(storage, commit2.obj.data);
    await mst.writeToCarStream(car);
  });
};
var getRecords = (storage, commitCid, paths) => {
  return writeCar(commitCid, async (car) => {
    const commit2 = await storage.readObjAndBytes(commitCid, def2.commit);
    await car.put({ cid: commitCid, bytes: commit2.bytes });
    const mst = MST.load(storage, commit2.obj.data);
    const cidsForPaths = await Promise.all(paths.map((p) => mst.cidsForPath(formatDataKey(p.collection, p.rkey))));
    const allCids = cidsForPaths.reduce((acc, cur) => {
      return acc.addSet(new cid_set_default(cur));
    }, new cid_set_default());
    const found = await storage.getBlocks(allCids.toList());
    if (found.missing.length > 0) {
      throw new MissingBlocksError("writeRecordsToCarStream", found.missing);
    }
    for (const block of found.blocks.entries()) {
      await car.put(block);
    }
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BlobNotFoundError,
  BlockMap,
  CidSet,
  DataDiff,
  Leaf,
  MST,
  MemoryBlockstore,
  MstWalker,
  ReadableBlockstore,
  Repo,
  RepoVerificationError,
  SyncStorage,
  WriteOpAction,
  blocksToCarFile,
  blocksToCarStream,
  carToBlocks,
  cborToLex,
  cborToLexRecord,
  cidForRecord,
  def,
  diffToWriteDescripts,
  ensureCreates,
  ensureV3Commit,
  formatDataKey,
  getAndParseByDef,
  getAndParseRecord,
  getFullRepo,
  getRecords,
  metaEqual,
  mstDiff,
  mstUtil,
  nodeDataDef,
  nullDiff,
  parseDataKey,
  parseObjByDef,
  readCar,
  readCarStream,
  readCarWithRoot,
  schema,
  signCommit,
  verifyCommitSig,
  verifyDiff,
  verifyDiffCar,
  verifyIncomingCarBlocks,
  verifyProofs,
  verifyRecords,
  verifyRepo,
  verifyRepoCar,
  writeCar,
  writeCarStream
});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=index.js.map
