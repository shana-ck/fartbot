import { RateLimiterAbstract, RateLimiterRes } from 'rate-limiter-flexible';
import { CalcKeyFn, CalcPointsFn, RateLimitExceededError, RateLimiterConsume, RateLimiterI, RateLimiterStatus, XRPCReqContext } from './types';
export type RateLimiterOpts = {
    keyPrefix: string;
    durationMs: number;
    points: number;
    bypassSecret?: string;
    bypassIps?: string[];
    calcKey?: CalcKeyFn;
    calcPoints?: CalcPointsFn;
    failClosed?: boolean;
};
export declare class RateLimiter implements RateLimiterI {
    limiter: RateLimiterAbstract;
    private bypassSecret?;
    private bypassIps?;
    private failClosed?;
    calcKey: CalcKeyFn;
    calcPoints: CalcPointsFn;
    constructor(limiter: RateLimiterAbstract, opts: RateLimiterOpts);
    static memory(opts: RateLimiterOpts): RateLimiter;
    static redis(storeClient: unknown, opts: RateLimiterOpts): RateLimiter;
    consume(ctx: XRPCReqContext, opts?: {
        calcKey?: CalcKeyFn;
        calcPoints?: CalcPointsFn;
    }): Promise<RateLimiterStatus | RateLimitExceededError | null>;
}
export declare const formatLimiterStatus: (limiter: RateLimiterAbstract, res: RateLimiterRes) => RateLimiterStatus;
export declare const consumeMany: (ctx: XRPCReqContext, fns: RateLimiterConsume[]) => Promise<RateLimiterStatus | RateLimitExceededError | null>;
export declare const setResHeaders: (ctx: XRPCReqContext, status: RateLimiterStatus) => void;
export declare const getTightestLimit: (resps: (RateLimiterStatus | RateLimitExceededError | null)[]) => RateLimiterStatus | RateLimitExceededError | null;
