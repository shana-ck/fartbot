/// <reference types="node" />
import { IncomingMessage } from 'http';
import express from 'express';
import zod from 'zod';
import { ResponseType } from '@atproto/xrpc';
export type Options = {
    validateResponse?: boolean;
    payload?: {
        jsonLimit?: number;
        blobLimit?: number;
        textLimit?: number;
    };
    rateLimits?: {
        creator: RateLimiterCreator;
        global?: ServerRateLimitDescription[];
        shared?: ServerRateLimitDescription[];
    };
};
export type UndecodedParams = typeof express.request['query'];
export type Primitive = string | number | boolean;
export type Params = Record<string, Primitive | Primitive[] | undefined>;
export declare const handlerInput: zod.ZodObject<{
    encoding: zod.ZodString;
    body: zod.ZodAny;
}, "strip", zod.ZodTypeAny, {
    encoding: string;
    body?: any;
}, {
    encoding: string;
    body?: any;
}>;
export type HandlerInput = zod.infer<typeof handlerInput>;
export declare const handlerAuth: zod.ZodObject<{
    credentials: zod.ZodAny;
    artifacts: zod.ZodAny;
}, "strip", zod.ZodTypeAny, {
    credentials?: any;
    artifacts?: any;
}, {
    credentials?: any;
    artifacts?: any;
}>;
export type HandlerAuth = zod.infer<typeof handlerAuth>;
export declare const handlerSuccess: zod.ZodObject<{
    encoding: zod.ZodString;
    body: zod.ZodAny;
    headers: zod.ZodOptional<zod.ZodRecord<zod.ZodString, zod.ZodString>>;
}, "strip", zod.ZodTypeAny, {
    encoding: string;
    body?: any;
    headers?: Record<string, string> | undefined;
}, {
    encoding: string;
    body?: any;
    headers?: Record<string, string> | undefined;
}>;
export type HandlerSuccess = zod.infer<typeof handlerSuccess>;
export declare const handlerPipeThrough: zod.ZodObject<{
    encoding: zod.ZodString;
    buffer: zod.ZodType<ArrayBuffer, zod.ZodTypeDef, ArrayBuffer>;
    headers: zod.ZodOptional<zod.ZodRecord<zod.ZodString, zod.ZodString>>;
}, "strip", zod.ZodTypeAny, {
    encoding: string;
    buffer: ArrayBuffer;
    headers?: Record<string, string> | undefined;
}, {
    encoding: string;
    buffer: ArrayBuffer;
    headers?: Record<string, string> | undefined;
}>;
export type HandlerPipeThrough = zod.infer<typeof handlerPipeThrough>;
export declare const handlerError: zod.ZodObject<{
    status: zod.ZodNumber;
    error: zod.ZodOptional<zod.ZodString>;
    message: zod.ZodOptional<zod.ZodString>;
}, "strip", zod.ZodTypeAny, {
    status: number;
    error?: string | undefined;
    message?: string | undefined;
}, {
    status: number;
    error?: string | undefined;
    message?: string | undefined;
}>;
export type HandlerError = zod.infer<typeof handlerError>;
export type HandlerOutput = HandlerSuccess | HandlerPipeThrough | HandlerError;
export type XRPCReqContext = {
    auth: HandlerAuth | undefined;
    params: Params;
    input: HandlerInput | undefined;
    req: express.Request;
    res: express.Response;
};
export type XRPCHandler = (ctx: XRPCReqContext) => Promise<HandlerOutput> | HandlerOutput | undefined;
export type XRPCStreamHandler = (ctx: {
    auth: HandlerAuth | undefined;
    params: Params;
    req: IncomingMessage;
    signal: AbortSignal;
}) => AsyncIterable<unknown>;
export type AuthOutput = HandlerAuth | HandlerError;
export type AuthVerifier = (ctx: {
    req: express.Request;
    res: express.Response;
}) => Promise<AuthOutput> | AuthOutput;
export type StreamAuthVerifier = (ctx: {
    req: IncomingMessage;
}) => Promise<AuthOutput> | AuthOutput;
export type CalcKeyFn = (ctx: XRPCReqContext) => string | null;
export type CalcPointsFn = (ctx: XRPCReqContext) => number;
export interface RateLimiterI {
    consume: RateLimiterConsume;
}
export type RateLimiterConsume = (ctx: XRPCReqContext, opts?: {
    calcKey?: CalcKeyFn;
    calcPoints?: CalcPointsFn;
}) => Promise<RateLimiterStatus | RateLimitExceededError | null>;
export type RateLimiterCreator = (opts: {
    keyPrefix: string;
    durationMs: number;
    points: number;
    calcKey?: CalcKeyFn;
    calcPoints?: CalcPointsFn;
}) => RateLimiterI;
export type ServerRateLimitDescription = {
    name: string;
    durationMs: number;
    points: number;
    calcKey?: CalcKeyFn;
    calcPoints?: CalcPointsFn;
};
export type SharedRateLimitOpts = {
    name: string;
    calcKey?: CalcKeyFn;
    calcPoints?: CalcPointsFn;
};
export type RouteRateLimitOpts = {
    durationMs: number;
    points: number;
    calcKey?: CalcKeyFn;
    calcPoints?: CalcPointsFn;
};
export type HandlerRateLimitOpts = SharedRateLimitOpts | RouteRateLimitOpts;
export declare const isShared: (opts: HandlerRateLimitOpts) => opts is SharedRateLimitOpts;
export type RateLimiterStatus = {
    limit: number;
    duration: number;
    remainingPoints: number;
    msBeforeNext: number;
    consumedPoints: number;
    isFirstInDuration: boolean;
};
export type RouteOpts = {
    blobLimit?: number;
};
export type XRPCHandlerConfig = {
    opts?: RouteOpts;
    rateLimit?: HandlerRateLimitOpts | HandlerRateLimitOpts[];
    auth?: AuthVerifier;
    handler: XRPCHandler;
};
export type XRPCStreamHandlerConfig = {
    auth?: StreamAuthVerifier;
    handler: XRPCStreamHandler;
};
export declare class XRPCError extends Error {
    type: ResponseType;
    errorMessage?: string | undefined;
    customErrorName?: string | undefined;
    constructor(type: ResponseType, errorMessage?: string | undefined, customErrorName?: string | undefined);
    get payload(): {
        error: string | undefined;
        message: string | undefined;
    };
    get typeName(): string | undefined;
    get typeStr(): string | undefined;
    static fromError(error: unknown): XRPCError;
}
export declare function isHandlerError(v: unknown): v is HandlerError;
export declare class InvalidRequestError extends XRPCError {
    constructor(errorMessage?: string, customErrorName?: string);
}
export declare class AuthRequiredError extends XRPCError {
    constructor(errorMessage?: string, customErrorName?: string);
}
export declare class ForbiddenError extends XRPCError {
    constructor(errorMessage?: string, customErrorName?: string);
}
export declare class RateLimitExceededError extends XRPCError {
    status: RateLimiterStatus;
    constructor(status: RateLimiterStatus, errorMessage?: string, customErrorName?: string);
}
export declare class InternalServerError extends XRPCError {
    constructor(errorMessage?: string, customErrorName?: string);
}
export declare class UpstreamFailureError extends XRPCError {
    constructor(errorMessage?: string, customErrorName?: string);
}
export declare class NotEnoughResourcesError extends XRPCError {
    constructor(errorMessage?: string, customErrorName?: string);
}
export declare class UpstreamTimeoutError extends XRPCError {
    constructor(errorMessage?: string, customErrorName?: string);
}
export declare class MethodNotImplementedError extends XRPCError {
    constructor(errorMessage?: string, customErrorName?: string);
}
