import { AppBskyFeedDefs, AppBskyFeedPost, AppBskyLabelerDefs, AtUri, ChatBskyConvoDefs, } from "@atproto/api";
import { EventEmitter } from "node:events";
import { RateLimitThreshold } from "rate-limit-threshold";
import { facetAwareSegment } from "../richtext/facetAwareSegment.js";
import { graphemeLength, RichText } from "../richtext/RichText.js";
import { ChatMessage } from "../struct/chat/ChatMessage.js";
import { Conversation } from "../struct/chat/Conversation.js";
import { DeletedChatMessage } from "../struct/chat/DeletedChatMessage.js";
import { FeedGenerator } from "../struct/FeedGenerator.js";
import { Labeler } from "../struct/Labeler.js";
import { List } from "../struct/List.js";
import { fetchExternalEmbedData, fetchMediaForBlob } from "../struct/post/embed/util.js";
import { Facet } from "../struct/post/Facet.js";
import { Post } from "../struct/post/Post.js";
import { PostReference } from "../struct/post/PostReference.js";
import { Profile } from "../struct/Profile.js";
import { StarterPack } from "../struct/StarterPack.js";
import { BotChatEmitter } from "./BotChatEmitter.js";
import { BotEventEmitter, EventStrategy } from "./BotEventEmitter.js";
import { makeCache } from "./cache.js";
import { RateLimitedAgent } from "./RateLimitedAgent.js";
const NO_SESSION_ERROR = "Active session not found. Make sure to call the login method first.";
/**
 * A bot that can interact with the Bluesky API.
 */
export class Bot extends EventEmitter {
    /** The agent used to communicate with the Bluesky API. */
    agent;
    /** A cache to store API responses. */
    cache;
    /** Receives and emits events. */
    eventEmitter;
    /** Receives and emits chat events. */
    chatEventEmitter;
    /** The proxy agent for chat-related requests. */
    chatProxy;
    /** The default list of languages to attach to posts. */
    langs = [];
    /** The bot account's Bluesky profile. */
    profile;
    /**
     * Create a new bot.
     * @param options Configuration options.
     */
    constructor({ service = "https://bsky.social", langs = ["en"], emitEvents = true, emitChatEvents = false, rateLimitOptions, cacheOptions, eventEmitterOptions = { strategy: EventStrategy.Polling }, } = {}) {
        super();
        this.agent = new RateLimitedAgent({ service }, new RateLimitThreshold(3000, rateLimitOptions?.rateLimitInterval ?? 300));
        this.langs = langs;
        this.cache = {
            profiles: makeCache(cacheOptions),
            posts: makeCache(cacheOptions),
            lists: makeCache({ maxEntries: 100, ...cacheOptions }),
            feeds: makeCache({ maxEntries: 50, ...cacheOptions }),
            labelers: makeCache({ maxEntries: 10, ...cacheOptions }),
            starterPacks: makeCache({ maxEntries: 10, ...cacheOptions }),
            conversations: makeCache({ maxEntries: 50, ...cacheOptions }),
        };
        if (emitEvents) {
            this.eventEmitter = new BotEventEmitter(eventEmitterOptions, this);
            this.eventEmitter.on("open", () => this.emit("open"));
            this.eventEmitter.on("error", (error) => this.emit("error", error));
            this.eventEmitter.on("close", () => this.emit("close"));
            this.eventEmitter.on("reply", (event) => this.emit("reply", event));
            this.eventEmitter.on("quote", (event) => this.emit("quote", event));
            this.eventEmitter.on("mention", (event) => this.emit("mention", event));
            this.eventEmitter.on("repost", (event) => this.emit("repost", event));
            this.eventEmitter.on("like", (event) => this.emit("like", event));
            this.eventEmitter.on("follow", (event) => this.emit("follow", event));
        }
        if (emitChatEvents) {
            this.chatEventEmitter = new BotChatEmitter(eventEmitterOptions, this);
            this.chatEventEmitter.on("message", (event) => this.emit("message", event));
            this.chatEventEmitter.on("error", (error) => this.emit("error", error));
        }
    }
    /** Whether the bot has an active session. */
    get hasSession() {
        return this.agent.hasSession;
    }
    /**
     * Log in with an identifier and password.
     * @param options The bot account's identifier and password.
     * @returns Session data.
     */
    async login({ identifier, password }) {
        if (identifier[0] === "@")
            identifier = identifier.slice(1);
        const response = await this.agent.login({ identifier, password }).catch((e) => {
            throw new Error("Failed to log in â€” double check your credentials and try again.", {
                cause: e,
            });
        });
        this.chatProxy = this.agent.withProxy("bsky_chat", "did:web:api.bsky.chat");
        this.profile = await this.getProfile(response.data.did).catch((e) => {
            throw new Error("Failed to fetch bot profile. Error:\n" + e);
        });
        return response.data;
    }
    /**
     * Resume an existing session.
     * @param session Session data.
     * @returns Updated session data.
     */
    async resumeSession(session) {
        const response = await this.agent.resumeSession(session).catch((e) => {
            throw new Error("Failed to resume session.", { cause: e });
        });
        this.profile = await this.getProfile(response.data.did);
        return response.data;
    }
    /**
     * Fetch a post by its AT URI.
     * @param uri The post's AT URI.
     * @param options Optional configuration.
     */
    async getPost(uri, options = {}) {
        options = { parentHeight: 1, depth: 1, ...options };
        if (!options.skipCache && this.cache.posts.has(uri))
            return this.cache.posts.get(uri);
        const postThread = await this.agent.getPostThread({
            uri,
            parentHeight: options.parentHeight,
            depth: options.depth,
        }).catch((e) => {
            throw new Error(`Failed to fetch post ${uri}`, { cause: e });
        });
        if (!AppBskyFeedDefs.isThreadViewPost(postThread.data.thread)) {
            if (this.cache.posts.has(uri))
                this.cache.posts.delete(uri);
            throw new Error(`Could not find post ${uri}. The bot may be blocked from viewing it, or the post may have been deleted.`);
        }
        const post = Post.fromThreadView(postThread.data.thread, this);
        if (!options.noCacheResponse)
            this.cache.posts.set(uri, post);
        return post;
    }
    /**
     * Fetch up to 25 posts by their AT URIs.
     * @param uris The URIs of the posts to fetch.
     * @param options Optional configuration.
     */
    async getPosts(uris, options = {}) {
        if (!uris.length)
            return [];
        if (uris.length > 25)
            throw new Error("You can only fetch up to 25 posts at a time.");
        if (!options.skipCache && uris.every((uri) => this.cache.posts.has(uri))) {
            return uris.map((uri) => this.cache.posts.get(uri));
        }
        const postViews = await this.agent.getPosts({ uris }).catch((e) => {
            throw new Error("Failed to fetch posts at URIs:\n" + uris.slice(0, 3).join("\n") + "\n...", { cause: e });
        });
        const posts = [];
        for (const postView of postViews.data.posts) {
            if (!AppBskyFeedPost.isRecord(postView.record))
                continue;
            const post = Post.fromView(postView, this);
            if (!options.noCacheResponse)
                this.cache.posts.set(post.uri, post);
            posts.push(post);
        }
        return posts;
    }
    /**
     * Fetch up to 100 (default 100) posts by a user's DID.
     * @param did The user's DID.
     * @param options Optional configuration.
     * @returns The user's posts and, if there are more posts to fetch, a cursor.
     */
    async getUserPosts(did, options = {}) {
        const response = await this.agent.getAuthorFeed({
            actor: did,
            filter: GetUserPostsFilter.PostsWithReplies,
            ...options,
        }).catch((e) => {
            throw new Error("Failed to fetch user posts.", { cause: e });
        });
        const posts = [];
        for (const feedViewPost of response.data.feed) {
            const post = Post.fromView(feedViewPost.post, this);
            if (!options.noCacheResponse)
                this.cache.posts.set(post.uri, post);
            posts.push(post);
        }
        return { cursor: response.data.cursor, posts };
    }
    /**
     * Fetch up to 100 (default 100) posts liked by a user.
     * @param did The user's DID.
     * @param options Optional configuration.
     */
    async getUserLikes(did, options = {}) {
        const response = await this.agent.getActorLikes({ actor: did, ...options }).catch((e) => {
            throw new Error("Failed to fetch user likes.", { cause: e });
        });
        const posts = [];
        for (const feedViewPost of response.data.feed) {
            const post = Post.fromView(feedViewPost.post, this);
            if (!options.noCacheResponse)
                this.cache.posts.set(post.uri, post);
            posts.push(post);
        }
        return { cursor: response.data.cursor, posts };
    }
    /**
     * Fetch a profile by DID or handle.
     * @param didOrHandle The user's DID or handle.
     * @param options Optional configuration.
     */
    async getProfile(didOrHandle, options = {}) {
        if (!options.skipCache && this.cache.profiles.has(didOrHandle)) {
            return this.cache.profiles.get(didOrHandle);
        }
        const profileView = await this.agent.getProfile({ actor: didOrHandle }).catch((e) => {
            throw new Error(`Failed to fetch profile ${didOrHandle}.`, { cause: e });
        });
        const profile = Profile.fromView(profileView.data, this);
        if (!options.noCacheResponse)
            this.cache.profiles.set(didOrHandle, profile);
        return profile;
    }
    /**
     * Fetch up to 25 (default 25) profiles by their DIDs or handles.
     * @param identifiers The identifiers of the profiles to fetch.
     * @param options Optional configuration.
     */
    async getProfiles(identifiers, options = {}) {
        if (!identifiers.length)
            return [];
        if (identifiers.length > 25) {
            throw new Error("You can only fetch up to 25 profiles at a time.");
        }
        if (!options.skipCache
            && identifiers.every((didOrHandle) => this.cache.profiles.has(didOrHandle))) {
            return identifiers.map((didOrHandle) => this.cache.profiles.get(didOrHandle));
        }
        const { data } = await this.agent.getProfiles({ actors: identifiers }).catch((e) => {
            throw new Error("Failed to fetch profiles at identifiers:\n" + identifiers.slice(0, 3).join("\n")
                + "\n...", { cause: e });
        });
        return data.profiles.map((profileView) => {
            const profile = Profile.fromView(profileView, this);
            if (!options.noCacheResponse)
                this.cache.profiles.set(profile.did, profile);
            return profile;
        });
    }
    /**
     * Fetch a list by its AT URI.
     * @param uri The list's AT URI.
     * @param options Optional configuration.
     */
    async getList(uri, options = {}) {
        if (!options.skipCache && this.cache.lists.has(uri)) {
            return this.cache.lists.get(uri);
        }
        const response = await this.agent.app.bsky.graph.getList({ list: uri }).catch((e) => {
            throw new Error(`Failed to fetch list ${uri}`, { cause: e });
        });
        const list = List.fromView(response.data.list, this);
        list.items = response.data.items.map(({ subject }) => Profile.fromView(subject, this));
        if (!options.noCacheResponse)
            this.cache.lists.set(uri, list);
        return list;
    }
    /**
     * Fetch all (up to 100, default 100) lists created by a user.
     * @param did The user's DID.
     * @param options Optional configuration.
     */
    async getUserLists(did, options) {
        const response = await this.agent.app.bsky.graph.getLists({ actor: did, ...options }).catch((e) => {
            throw new Error(`Failed to fetch user lists for ${did}.`, { cause: e });
        });
        const lists = response.data.lists.map((listView) => {
            const list = List.fromView(listView, this);
            this.cache.lists.set(list.uri, list);
            return list;
        });
        return { cursor: response.data.cursor, lists };
    }
    /**
     * Fetch a feed generator by its AT URI.
     * @param uri The feed generator's AT URI.
     * @param options Optional configuration.
     */
    async getFeedGenerator(uri, options = {}) {
        if (!options.skipCache && this.cache.feeds.has(uri)) {
            return this.cache.feeds.get(uri);
        }
        const response = await this.agent.app.bsky.feed.getFeedGenerator({ feed: uri }).catch((e) => {
            throw new Error(`Failed to fetch feed generator ${uri}`, { cause: e });
        });
        const feed = FeedGenerator.fromView(response.data.view, this);
        feed.isOnline = response.data.isOnline;
        if (!options.noCacheResponse)
            this.cache.feeds.set(uri, feed);
        return feed;
    }
    /**
     * Fetch a list of feed generators by their AT URIs.
     * @param uris The URIs of the feed generators to fetch.
     * @param options Optional configuration.
     */
    async getFeedGenerators(uris, options = {}) {
        if (!uris.length)
            return [];
        const feedViews = await this.agent.app.bsky.feed.getFeedGenerators({ feeds: uris }).catch((e) => {
            throw new Error("Failed to fetch feed generators at URIs:\n" + uris.slice(0, 3).join("\n")
                + "\n...", { cause: e });
        });
        return feedViews.data.feeds.map((feedView) => {
            const feed = FeedGenerator.fromView(feedView, this);
            if (!options.noCacheResponse)
                this.cache.feeds.set(feed.uri, feed);
            return feed;
        });
    }
    /**
     * Get the bot's home timeline.
     * @param options Optional configuration.
     */
    async getTimeline(options = {}) {
        const response = await this.agent.getTimeline(options).catch((e) => {
            throw new Error("Failed to fetch timeline.", { cause: e });
        });
        return response.data.feed.map((feedViewPost) => {
            const post = Post.fromView(feedViewPost.post, this);
            if (!options.noCacheResponse)
                this.cache.posts.set(post.uri, post);
            return post;
        });
    }
    /**
     * Fetch a labeler by its account DID.
     * @param did The DID of the labeler to fetch.
     * @param options Optional configuration.
     */
    async getLabeler(did, options = {}) {
        if (!options.skipCache && this.cache.labelers.has(did)) {
            return this.cache.labelers.get(did);
        }
        const labelers = await this.getLabelers([did]);
        if (!labelers[0])
            throw new Error(`Labeler not found for DID ${did}.`);
        if (!options.noCacheResponse)
            this.cache.labelers.set(labelers[0].uri, labelers[0]);
        return labelers[0];
    }
    /**
     * 	Fetch a list of labelers by their account DIDs.
     * 	@param dids The DIDs of the labelers to fetch.
     * 	@param options Optional configuration.
     */
    async getLabelers(dids, options = {}) {
        const response = await this.agent.getLabelers({ dids, detailed: true }).catch((e) => {
            throw new Error("Failed to fetch labelers:\n" + dids.slice(0, 3).join("\n") + "\n...", {
                cause: e,
            });
        });
        return response.data.views.map((labelerView) => {
            if (!AppBskyLabelerDefs.isLabelerView(labelerView)
                && !AppBskyLabelerDefs.isLabelerViewDetailed(labelerView)) {
                throw new Error(`Received invalid labeler view: ${JSON.stringify(labelerView)}`);
            }
            const labeler = Labeler.fromView(labelerView, this);
            if (!options.noCacheResponse)
                this.cache.labelers.set(labeler.uri, labeler);
            return labeler;
        });
    }
    /**
     * Fetch a starter pack by its AT URI.
     * @param uri The starter pack's AT URI.
     * @param options Optional configuration.
     */
    async getStarterPack(uri, options = {}) {
        if (!options.skipCache && this.cache.starterPacks.has(uri)) {
            return this.cache.starterPacks.get(uri);
        }
        const response = await this.agent.app.bsky.graph.getStarterPack({ starterPack: uri }).catch((e) => {
            throw new Error(`Failed to fetch starter pack ${uri}`, { cause: e });
        });
        if (!options.noCacheResponse) {
            this.cache.starterPacks.set(uri, StarterPack.fromView(response.data.starterPack, this));
        }
        return StarterPack.fromView(response.data.starterPack, this);
    }
    /**
     * Fetch a list of starter packs by their AT URIs.
     * @param uris The URIs of the starter packs to fetch.
     * @param options Optional configuration.
     */
    async getStarterPacks(uris, options = {}) {
        const response = await this.agent.app.bsky.graph.getStarterPacks({ uris }).catch((e) => {
            throw new Error("Failed to fetch starter packs at URIs:\n" + uris.slice(0, 3).join("\n") + "\n...", { cause: e });
        });
        return response.data.starterPacks.map((starterPackView) => {
            const starterPack = StarterPack.fromView(starterPackView, this);
            if (!options.noCacheResponse)
                this.cache.starterPacks.set(starterPack.uri, starterPack);
            return starterPack;
        });
    }
    /**
     * Fetch a list of starter packs by their creator's DID.
     * @param did The creator's DID.
     * @param options Optional configuration.
     */
    async getUserStarterPacks(did, options = {}) {
        const response = await this.agent.app.bsky.graph.getActorStarterPacks({
            actor: did,
            limit: options.limit ?? 100,
            cursor: options.cursor ?? "",
        }).catch((e) => {
            throw new Error(`Failed to fetch starter packs for creator ${did}.`, { cause: e });
        });
        return response.data.starterPacks.map((starterPackView) => {
            const starterPack = StarterPack.fromView(starterPackView, this);
            if (!options.noCacheResponse)
                this.cache.starterPacks.set(starterPack.uri, starterPack);
            return starterPack;
        });
    }
    /**
     * Fetch a conversation containing 1-10 members. If a conversation doesn't exist, it will be created.
     * @param members The DIDs of the conversation members.
     * @param options Optional configuration.
     */
    async getConversationForMembers(members, options = {}) {
        if (!this.chatProxy) {
            throw new Error("Chat proxy does not exist. Make sure to log in first.");
        }
        const response = await this.chatProxy.chat.bsky.convo.getConvoForMembers({ members }).catch((e) => {
            throw new Error("Failed to create conversation.", { cause: e });
        });
        const convo = Conversation.fromView(response.data.convo, this);
        if (!options.noCacheResponse)
            this.cache.conversations.set(convo.id, convo);
        return convo;
    }
    /**
     * Fetch a conversation by its ID.
     * @param id The conversation's ID.
     * @param options Optional configuration.
     */
    async getConversation(id, options = {}) {
        if (!options.skipCache && this.cache.conversations.has(id)) {
            return this.cache.conversations.get(id);
        }
        if (!this.chatProxy) {
            throw new Error("Chat proxy does not exist. Make sure to log in first.");
        }
        const response = await this.chatProxy.chat.bsky.convo.getConvo({ convoId: id }).catch((e) => {
            throw new Error(`Failed to fetch conversation ${id}.`, { cause: e });
        });
        const convo = Conversation.fromView(response.data.convo, this);
        if (!options.noCacheResponse)
            this.cache.conversations.set(convo.id, convo);
        return convo;
    }
    /**
     * Fetch all conversations the bot is a member of.
     * @param options Optional configuration.
     */
    async listConversations(options = {}) {
        options.limit ??= 100;
        if (!this.chatProxy) {
            throw new Error("Chat proxy does not exist. Make sure to log in first.");
        }
        const response = await this.chatProxy.chat.bsky.convo.listConvos(options).catch((e) => {
            throw new Error("Failed to list conversations.", { cause: e });
        });
        const conversations = response.data.convos.map((convoView) => {
            const convo = Conversation.fromView(convoView, this);
            if (!options.noCacheResponse)
                this.cache.conversations.set(convo.id, convo);
            return convo;
        });
        return { cursor: response.data.cursor, conversations };
    }
    /**
     * Fetch the message history for a conversation.
     * @param conversationId The ID of the conversation to fetch messages for.
     * @param options Optional configuration.
     * @returns An array of messages and a cursor for pagination.
     */
    async getConversationMessages(conversationId, options = {}) {
        options.limit ??= 100;
        if (!this.chatProxy) {
            throw new Error("Chat proxy does not exist. Make sure to log in first.");
        }
        const response = await this.chatProxy.chat.bsky.convo.getMessages({
            convoId: conversationId,
            ...options,
        }).catch((e) => {
            throw new Error(`Failed to fetch messages for conversation ${conversationId}.`, {
                cause: e,
            });
        });
        const messages = response.data.messages.map((view) => {
            if (ChatBskyConvoDefs.isMessageView(view)) {
                return ChatMessage.fromView(view, this, conversationId);
            }
            if (ChatBskyConvoDefs.isDeletedMessageView(view)) {
                return DeletedChatMessage.fromView(view, this);
            }
            throw new Error(`Invalid message view: ${JSON.stringify(view)}`);
        });
        return { cursor: response.data.cursor, messages };
    }
    /**
     * Create a post.
     * @param payload The post payload.
     * @param options Optional configuration.
     * @returns A reference to the created post.
     */
    async post(payload, options = {}) {
        options.resolveFacets ??= true;
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        // Use default langs if none are provided (an explicit empty array will be ignored)
        payload.langs ??= this.langs;
        // Use current time if none is provided
        payload.createdAt ??= new Date();
        // Resolve facets if necessary
        let text, facets = [];
        if (payload.text instanceof RichText) {
            ({ text, facets } = payload.text.build());
        }
        else if (options.resolveFacets) {
            text = payload.text;
            facets = await RichText.detectFacets(text, this);
        }
        else {
            text = payload.text;
        }
        // Override facets if provided
        if (payload.facets?.length) {
            for (const facet of payload.facets) {
                if (facet instanceof Facet)
                    facets.push(facet.toRecord());
                else
                    facets.push(facet);
            }
        }
        if (graphemeLength(text) > 300) {
            if (!options.splitLongPost) {
                throw new Error("Post exceeds maximum length of 300 graphemes.");
            }
            const segments = facetAwareSegment(text, 300, facets);
            if (segments.length <= 1) {
                throw new Error("Post is too long and could not be split into shorter posts.");
            }
            const { text: postText, facets: postFacets } = segments.shift();
            const firstPost = await this.post({ ...payload, text: postText, facets: postFacets }, options);
            let previousPost = firstPost;
            while (segments.length) {
                const { text: replyText, facets: replyFacets } = segments.shift();
                const root = payload.replyRef?.root ?? { uri: firstPost.uri, cid: firstPost.cid };
                // We don't want to copy over the entire payload; for instance, images, tags, embed, threadgate should only be on the first post
                previousPost = await this.post({
                    text: replyText,
                    facets: replyFacets,
                    labels: payload.labels,
                    langs: payload.langs,
                    createdAt: payload.createdAt,
                    replyRef: { parent: { uri: previousPost.uri, cid: previousPost.cid }, root },
                }, { ...options });
            }
            return firstPost;
        }
        // Create post labels
        const labels = payload.labels?.length
            ? {
                $type: "com.atproto.label.defs#selfLabels",
                values: payload.labels.map((label) => ({ val: label })),
            }
            : undefined;
        if (payload.images?.length && payload.quoted && !(payload.quoted instanceof Post)) {
            throw new Error("Only a post can be embedded alongside images.");
        }
        if (payload.images?.length && payload.video) {
            throw new Error("A post can only contain one of images or video.");
        }
        // Upload image blobs
        const images = [];
        if (payload.images?.length) {
            for (const image of payload.images) {
                if (!image)
                    continue;
                if (image?.data instanceof Blob) {
                    if (!image?.data.size)
                        throw new Error("Can't upload an empty image");
                    if (!image.data.type.startsWith("image/")) {
                        throw new Error("Image blob is not an image");
                    }
                }
                image.alt ??= "";
                let type, blob;
                if (typeof image.data === "string") {
                    ({ type, data: blob } =
                        await fetchMediaForBlob(image.data, "image/").catch((e) => {
                            // eslint-disable-next-line @typescript-eslint/no-base-to-string, @typescript-eslint/restrict-template-expressions
                            throw new Error(`Failed to fetch image at ${image.data}\n` + e);
                        }) ?? {});
                }
                else {
                    type = image.data.type;
                    blob = new Uint8Array(await image.data.arrayBuffer());
                }
                if (!blob || !type)
                    throw new Error("Invalid image provided.");
                const imageResponse = await this.agent.uploadBlob(blob, { encoding: type }).catch((e) => {
                    throw new Error("Failed to upload image\n" + e);
                });
                const { blob: imageBlob } = imageResponse.data;
                images.push({ ...image, alt: image.alt, image: imageBlob });
            }
        }
        // Construct the post embed
        let embed;
        if (payload.quoted) {
            const record = {
                $type: "app.bsky.embed.record",
                record: { uri: payload.quoted.uri, cid: payload.quoted.cid },
            };
            embed = images.length
                ? {
                    $type: "app.bsky.embed.recordWithMedia",
                    record,
                    media: { $type: "app.bsky.embed.images", images },
                }
                : record;
        }
        else if (payload.external) {
            if (typeof payload.external === "string") {
                const external = await fetchExternalEmbedData.call(this, payload.external).catch((e) => {
                    throw new Error("Failed to resolve external embed\n" + e);
                });
                if (external) {
                    embed = {
                        $type: "app.bsky.embed.external",
                        external,
                    };
                }
            }
            else {
                let thumbBlob;
                const image = payload.external.thumb?.data;
                if (image) {
                    if (image instanceof Blob && !image.type.startsWith("image/")) {
                        throw new Error("Image blob is not an image");
                    }
                    let type, blob;
                    if (typeof image === "string") {
                        ({ type, data: blob } =
                            await fetchMediaForBlob(image, "image/").catch((e) => {
                                throw new Error(`Failed to fetch payload.external.thumb at ${image}\n` + e);
                            }) ?? {});
                    }
                    else {
                        type = image.type;
                        blob = new Uint8Array(await image.arrayBuffer());
                    }
                    if (!blob || !type)
                        throw new Error("Invalid image provided.");
                    const thumbResponse = await this.agent.uploadBlob(blob, { encoding: type })
                        .catch((e) => {
                        throw new Error("Failed to upload thumbnail\n" + e);
                    });
                    thumbBlob = thumbResponse.data.blob;
                }
                embed = {
                    $type: "app.bsky.embed.external",
                    external: {
                        title: payload.external.title,
                        uri: payload.external.uri,
                        description: payload.external.description,
                        ...(thumbBlob ? { thumb: thumbBlob } : {}),
                    },
                };
            }
        }
        else if (images.length) {
            embed = { $type: "app.bsky.embed.images", images };
        }
        else if (payload.video) {
            if (payload.video?.data instanceof Blob) {
                if (!payload.video?.data.size)
                    throw new Error("Can't upload an empty video");
                if (!payload.video.data.type.startsWith("video/")) {
                    throw new Error("Video blob is not a video");
                }
            }
            payload.video.alt ??= "";
            let type, blob;
            if (typeof payload.video.data === "string") {
                ({ type, data: blob } =
                    await fetchMediaForBlob(payload.video.data, "video/").catch((e) => {
                        // eslint-disable-next-line @typescript-eslint/no-base-to-string, @typescript-eslint/restrict-template-expressions
                        throw new Error(`Failed to fetch video at ${payload.video?.data}\n` + e);
                    }) ?? {});
            }
            else {
                type = payload.video.data.type;
                blob = new Uint8Array(await payload.video.data.arrayBuffer());
            }
            if (!blob || !type)
                throw new Error("Invalid video provided.");
            const videoResponse = await this.agent.uploadBlob(blob, { encoding: type }).catch((e) => {
                throw new Error("Failed to upload video\n" + e);
            });
            const { blob: videoBlob } = videoResponse.data;
            embed = {
                ...payload.video,
                $type: "app.bsky.embed.video",
                video: videoBlob,
            };
        }
        // Put together the post record
        const postRecord = {
            $type: "app.bsky.feed.post",
            text,
            facets,
            createdAt: payload.createdAt.toISOString(),
            langs: payload.langs,
        };
        // @ts-expect-error â€” AppBskyFeedPost.ReplyRef has a string index signature
        if (payload.replyRef)
            postRecord.reply = payload.replyRef;
        if (embed)
            postRecord.embed = embed;
        if (labels)
            postRecord.labels = labels;
        if (payload.tags?.length)
            postRecord.tags = payload.tags;
        const { uri: postUri, cid: postCid } = await this.createRecord("app.bsky.feed.post", postRecord).catch((e) => {
            throw new Error("Error when uploading post.", { cause: e });
        });
        // Threadgate is a separate record
        if (payload.threadgate) {
            const { rkey } = new AtUri(postUri);
            const allow = [];
            if (payload.threadgate.allowFollowing) {
                allow.push({ $type: "app.bsky.feed.threadgate#followingRule" });
            }
            if (payload.threadgate.allowMentioned) {
                allow.push({ $type: "app.bsky.feed.threadgate#mentionRule" });
            }
            payload.threadgate.allowLists?.forEach((list) => {
                allow.push({
                    $type: "app.bsky.feed.threadgate#listRule",
                    list: typeof list === "string" ? list : list.uri,
                });
            });
            const threadgateRecord = {
                $type: "app.bsky.feed.threadgate",
                createdAt: new Date().toISOString(),
                post: postUri,
                allow,
            };
            // Threadgate rkey must equal the post's rkey
            await this.createRecord("app.bsky.feed.threadgate", threadgateRecord, rkey).catch((e) => {
                throw new Error(`Failed to create threadgate on post ${postUri}.`, {
                    cause: e,
                });
            });
        }
        return new PostReference({ uri: postUri, cid: postCid, replyRef: payload.replyRef }, this);
    }
    /**
     * Delete a post.
     * @param uri The post's AT URI.
     */
    async deletePost(uri) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        await this.deleteRecord(uri).catch((e) => {
            throw new Error(`Failed to delete post ${uri}.`, { cause: e });
        }).finally(() => this.cache.posts.delete(uri));
    }
    /**
     * Like a post or feed generator.
     * @param reference The post or feed generator to like.
     * @returns The like record's AT URI and CID.
     */
    async like({ uri, cid }) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        return this.agent.like(uri, cid).catch((e) => {
            throw new Error(`Failed to like post ${uri}.`, { cause: e });
        });
    }
    /**
     * Delete a like.
     * @param uri The liked record's AT URI or the like record's AT URI.
     */
    async unlike(uri) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        const likeUri = uri.includes("app.bsky.feed.like")
            ? uri
            : uri.includes("app.bsky.feed.generator")
                ? (await this.getFeedGenerator(uri)).likeUri
                : (await this.getPost(uri)).likeUri;
        if (!likeUri)
            return;
        await this.deleteRecord(likeUri).catch((e) => {
            throw new Error(`Failed to delete like ${likeUri}` + likeUri === uri ? "." : ` for record ${uri}.`, { cause: e });
        });
    }
    /**
     * Repost a post.
     * @param reference The post to repost.
     * @returns The repost record's AT URI and CID.
     */
    async repost({ uri, cid }) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        return this.agent.repost(uri, cid).catch((e) => {
            throw new Error(`Failed to repost post ${uri}.`, { cause: e });
        });
    }
    /**
     * Delete a repost.
     * @param uri The post's AT URI or the repost record's AT URI.
     */
    async deleteRepost(uri) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        const repostUri = uri.includes("app.bsky.feed.repost")
            ? uri
            : (await this.getPost(uri)).repostUri;
        if (!repostUri)
            return;
        await this.deleteRecord(repostUri).catch((e) => {
            throw new Error(`Failed to delete repost ${repostUri}` + repostUri === uri
                ? "."
                : ` for post ${uri}.`, { cause: e });
        });
    }
    /**
     * Follow a user.
     * @param did The user's DID.
     * @returns The follow record's AT URI and CID.
     */
    async follow(did) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        return this.agent.follow(did).catch((e) => {
            throw new Error(`Failed to follow user ${did}.`, { cause: e });
        });
    }
    /**
     * Delete a follow.
     * @param didOrUri The user's DID or the follow record's AT URI.
     */
    async unfollow(didOrUri) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        let followUri;
        if (didOrUri.startsWith("at://"))
            followUri = didOrUri;
        else {
            const user = await this.getProfile(didOrUri);
            if (!user)
                throw new Error(`User ${didOrUri} not found.`);
            if (!user.followUri)
                return;
            followUri = user.followUri;
        }
        await this.deleteRecord(followUri).catch((e) => {
            throw new Error(`Failed to delete follow ${didOrUri}` + followUri === didOrUri
                ? "."
                : ` for user ${didOrUri}.`, { cause: e });
        });
    }
    /**
     * Mute a user.
     * @param did The user's DID.
     */
    async mute(did) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        await this.agent.mute(did).catch((e) => {
            throw new Error(`Failed to mute user ${did}.`, { cause: e });
        });
    }
    /**
     * Delete a mute.
     * @param did The user's DID.
     */
    async unmute(did) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        await this.agent.unmute(did).catch((e) => {
            throw new Error(`Failed to delete mute for user ${did}.`, { cause: e });
        });
    }
    /**
     * Block a user.
     * @param did The user's DID.
     * @returns The block record's AT URI and CID.
     */
    async block(did) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        return this.createRecord("app.bsky.graph.block", { subject: did }).catch((e) => {
            throw new Error(`Failed to block user ${did}.`, { cause: e });
        });
    }
    /**
     * Delete a block.
     * @param didOrUri The user's DID or the block record's AT URI.
     */
    async unblock(didOrUri) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        let blockUri;
        if (didOrUri.startsWith("at://"))
            blockUri = didOrUri;
        else {
            const user = await this.getProfile(didOrUri);
            if (!user)
                throw new Error(`User ${didOrUri} not found.`);
            if (!user.blockUri)
                return;
            blockUri = user.blockUri;
        }
        await this.deleteRecord(blockUri).catch((e) => {
            throw new Error(`Failed to delete block ${didOrUri}` + blockUri === didOrUri
                ? "."
                : ` for user ${didOrUri}.`, { cause: e });
        });
    }
    /**
     * Send a message in a DM conversation.
     * @param payload The message payload.
     * @param options Optional configuration.
     * @returns The sent message.
     */
    async sendMessage(payload, options = {}) {
        options.resolveFacets ??= true;
        if (!this.chatProxy) {
            throw new Error("Chat proxy does not exist. Make sure to log in first.");
        }
        let text, facets = [];
        if (payload.text instanceof RichText) {
            ({ text, facets } = payload.text.build());
        }
        else if (options.resolveFacets) {
            text = payload.text;
            facets = await RichText.detectFacets(text, this);
        }
        else {
            text = payload.text;
        }
        if (graphemeLength(text) > 1000) {
            throw new Error("Message exceeds maximum length of 1000 graphemes.");
        }
        const response = await this.chatProxy.chat.bsky.convo.sendMessage({
            convoId: payload.conversationId,
            message: {
                text,
                facets,
                ...(payload.embed
                    ? { embed: { $type: "app.bsky.embed.record#main", record: payload.embed } }
                    : {}),
            },
        }).catch((e) => {
            throw new Error("Failed to send message.", { cause: e });
        });
        return ChatMessage.fromView(response.data, this, payload.conversationId);
    }
    /**
     * Send up to 100 private messages at once.
     * @param payload The messages payload.
     * @param options Optional configuration.
     * @returns The sent messages.
     */
    async sendMessages(payload, options = {}) {
        options.resolveFacets ??= true;
        if (!this.chatProxy) {
            throw new Error("Chat proxy does not exist. Make sure to log in first.");
        }
        const messages = await Promise.all(payload.map(async (message) => {
            let text, facets = [];
            if (message.text instanceof RichText) {
                ({ text, facets } = message.text.build());
            }
            else if (options.resolveFacets) {
                text = message.text;
                facets = await RichText.detectFacets(text, this);
            }
            else {
                text = message.text;
            }
            if (graphemeLength(text) > 1000) {
                throw new Error("Message exceeds maximum length of 1000 graphemes.");
            }
            return {
                convoId: message.conversationId,
                message: {
                    text,
                    facets,
                    ...(message.embed
                        ? { embed: { $type: "app.bsky.embed.record#main", record: message.embed } }
                        : {}),
                },
            };
        }));
        const response = await this.chatProxy.chat.bsky.convo.sendMessageBatch({ items: messages })
            .catch((e) => {
            throw new Error("Failed to send messages.", { cause: e });
        });
        return response.data.items.map((view) => ChatMessage.fromView(view, this, messages[0].convoId));
    }
    /**
     * Leave a DM conversation.
     * @param id The conversation's ID.
     */
    async leaveConversation(id) {
        if (!this.chatProxy) {
            throw new Error("Chat proxy does not exist. Make sure to log in first.");
        }
        await this.chatProxy.chat.bsky.convo.leaveConvo({ convoId: id }).catch((e) => {
            throw new Error(`Failed to leave conversation ${id}.`, { cause: e });
        });
    }
    /**
     * Label a user or record. Note that you need a running labeler server on this DID to publish labels!
     * @param options Information on the label to apply.
     * @see [@skyware/labeler | Getting Started](https://skyware.js.org/guides/labeler/introduction/getting-started/) to run a minimal labeler server.
     * @see [Self-hosting Ozone](https://github.com/bluesky-social/ozone/blob/main/HOSTING.md) for a full web UI and report handling.
     */
    async label({ reference, labels, blobCids = [], comment }) {
        const response = await this.emitLabelEvent(reference, {
            createLabelVals: labels,
            negateLabelVals: [],
            ...(comment ? { comment } : {}),
        }, blobCids);
        if (!response.success) {
            throw new Error(`Failed to label record ${"did" in reference ? reference.did : reference.uri}.`);
        }
    }
    /**
     * Negate labels previously applied to a record by the bot.
     * @param options Information on the record to negate labels on.
     */
    async negateLabels({ reference, labels, blobCids = [], comment }) {
        const response = await this.emitLabelEvent(reference, {
            createLabelVals: [],
            negateLabelVals: labels,
            ...(comment ? { comment } : {}),
        }, blobCids);
        if (!response.success) {
            throw new Error(`Failed to negate label on record ${"did" in reference ? reference.did : reference.uri}.`);
        }
    }
    async emitLabelEvent(reference, event, subjectBlobCids) {
        if (!this.profile.isLabeler) {
            throw new Error("The bot doesn't seem to have a labeler service declared.\nFor more information, see https://skyware.js.org/guides/labeler/introduction/getting-started/");
        }
        const subject = "did" in reference
            ? { $type: "com.atproto.admin.defs#repoRef", did: reference.did }
            : { $type: "com.atproto.repo.strongRef", uri: reference.uri, cid: reference.cid };
        return this.agent.withProxy("atproto_labeler", this.profile.did).tools.ozone.moderation
            .emitEvent({
            event: {
                $type: "tools.ozone.moderation.defs#modEventLabel",
                ...event,
            },
            subject,
            createdBy: this.profile.did,
            createdAt: new Date().toISOString(),
            subjectBlobCids,
        });
    }
    /**
     * Subscribe to a labeler.
     * @param did The labeler's DID.
     */
    async addLabeler(did) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        return this.agent.addLabeler(did).catch((e) => {
            throw new Error(`Failed to subscribe to labeler ${did}.`, { cause: e });
        });
    }
    /**
     * Unsubscribe from a labeler.
     * @param did The labeler's DID.
     */
    async removeLabeler(did) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        return this.agent.removeLabeler(did).catch((e) => {
            throw new Error(`Failed to unsubscribe from labeler ${did}.`, { cause: e });
        });
    }
    /**
     * Resolve a handle to a DID.
     * @param handle The handle to resolve.
     * @returns The user's DID.
     */
    async resolveHandle(handle) {
        const response = await this.agent.resolveHandle({ handle }).catch((e) => {
            throw new Error(`Failed to resolve handle ${handle}`, { cause: e });
        });
        return response.data.did;
    }
    /**
     * Update the bot's handle.
     * @param handle The new handle.
     */
    async updateHandle(handle) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        await this.agent.updateHandle({ handle }).catch((e) => {
            throw new Error("Failed to update handle.", { cause: e });
        });
        this.profile.handle = handle;
    }
    /**
     * Set the bot's preference for who can initiate a new chat conversation. This does not affect existing conversations.
     * @param preference The new preference.
     */
    async setChatPreference(preference) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        await this.putRecord("chat.bsky.actor.declaration", { allowIncoming: preference }, "self");
    }
    /**
     * Create a record.
     * @param nsid The collection's NSID.
     * @param record The record to create.
     * @param rkey The rkey to use.
     * @returns The record's AT URI and CID.
     */
    async createRecord(nsid, record, rkey) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        const response = await this.agent.com.atproto.repo.createRecord({
            collection: nsid,
            record: { $type: nsid, createdAt: new Date().toISOString(), ...record },
            repo: this.profile.did,
            ...(rkey ? { rkey } : {}),
        });
        return response.data;
    }
    /**
     * Put a record in place of an existing record.
     * @param nsid The collection's NSID.
     * @param record The record to put.
     * @param rkey The rkey to use.
     * @returns The record's AT URI and CID.
     */
    async putRecord(nsid, record, rkey) {
        if (!this.hasSession)
            throw new Error(NO_SESSION_ERROR);
        const response = await this.agent.com.atproto.repo.putRecord({
            collection: nsid,
            record: { $type: nsid, createdAt: new Date().toISOString(), ...record },
            repo: this.profile.did,
            rkey,
        });
        return response.data;
    }
    /**
     * Delete a record.
     * @param uri The record's AT URI.
     */
    async deleteRecord(uri) {
        const { host: repo, collection, rkey } = new AtUri(uri);
        if (repo !== this.profile.did)
            throw new Error("Can only delete own record.");
        await this.agent.com.atproto.repo.deleteRecord({ collection, repo, rkey });
    }
    /**
     * @param event The event to listen for.
     * @param listener The callback function, called when the event is emitted.
     */
    on(event, listener) {
        if (!this.eventEmitter && !this.chatEventEmitter) {
            throw new Error("Events are not enabled.");
        }
        // TODO: find a better solution for this
        if (event === "message" && !this.chatEventEmitter?.emitting)
            this.chatEventEmitter?.start();
        else if (!this.eventEmitter?.emitting)
            this.eventEmitter?.start();
        super.on(event, listener);
        return this;
    }
    /** Alias for {@link Bot#on}. */
    addListener(event, listener) {
        return this.on(event, listener);
    }
    /**
     * Remove an event listener.
     * @param event The event to remove the listener for.
     * @param listener The listener callback to remove.
     */
    off(event, listener) {
        super.off(event, listener);
        return this;
    }
    /** Alias for {@link Bot#off}. */
    removeListener(event, listener) {
        return this.off(event, listener);
    }
    /**
     * Remove all event listeners, or those of the specified event.
     * @param event The event to remove listeners for.
     */
    removeAllListeners(event) {
        if (!this.eventEmitter && !this.chatEventEmitter) {
            throw new Error("Events are not enabled.");
        }
        super.removeAllListeners(event);
        this.eventEmitter?.stop();
        this.chatEventEmitter?.stop();
        return this;
    }
}
/**
 * Types of posts to be included in the response to {@link Bot#getUserPosts}.
 * @enum
 */
export const GetUserPostsFilter = {
    /** All posts. */
    PostsWithReplies: "posts_with_replies",
    /** Top-level posts only. */
    PostsNoReplies: "posts_no_replies",
    /** Posts with media. */
    PostsWithMedia: "posts_with_media",
    /** Top-level posts and threads where the only author is the user. */
    PostsAndAuthorThreads: "posts_and_author_threads",
};
