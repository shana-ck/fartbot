import { cborToLexRecord, readCar } from "@atproto/repo";
import { Frame } from "@atproto/xrpc-server";
import { EventEmitter } from "node:events";
import * as WS from "ws";
export class Firehose extends EventEmitter {
    relay;
    options;
    /** WebSocket connection to the relay. */
    ws;
    /** The current cursor. */
    cursor = "";
    cursorInterval;
    /**
     * Creates a new Firehose instance.
     * @param relay The relay to connect to.
     * @param options Optional configuration.
     */
    constructor(relay = "wss://bsky.network", options = {}) {
        super();
        this.relay = relay;
        this.options = options;
        this.cursor = options.cursor ?? "";
        this.options.setCursorInterval ??= 5000;
    }
    /**
     * Opens a WebSocket connection to the relay.
     */
    start() {
        this.ws = new WS.WebSocket(`${this.relay}/xrpc/com.atproto.sync.subscribeRepos${this.cursor}`);
        this.ws.on("open", () => {
            this.emit("open");
        });
        this.ws.on("message", async (data) => {
            try {
                const message = await this.parseMessage(data);
                if ("seq" in message && message.seq && typeof message.seq === "string") {
                    this.setCursor(message.seq);
                }
                switch (message.$type) {
                    case "com.atproto.sync.subscribeRepos#handle":
                        this.emit("handle", message);
                        break;
                    case "com.atproto.sync.subscribeRepos#tombstone":
                        this.emit("tombstone", message);
                        break;
                    case "com.atproto.sync.subscribeRepos#migrate":
                        this.emit("migrate", message);
                        break;
                    case "com.atproto.sync.subscribeRepos#identity":
                        this.emit("identity", message);
                        break;
                    case "com.atproto.sync.subscribeRepos#info":
                        this.emit("info", message);
                        break;
                    case "com.atproto.sync.subscribeRepos#commit":
                        this.emit("commit", message);
                        break;
                    default:
                        this.emit("unknown", message);
                        break;
                }
            }
            catch (error) {
                this.emit("error", { cursor: this.cursor, error });
            }
        });
        this.ws.on("close", () => {
            this.emit("close", this.cursor);
        });
        this.ws.on("error", (error) => {
            this.emit("websocketError", { cursor: this.cursor, error });
        });
    }
    /**
     * Closes the WebSocket connection.
     */
    close() {
        this.ws?.close();
    }
    on(event, listener) {
        super.on(event, listener);
        return this;
    }
    async parseMessage(data) {
        let buffer;
        if (data instanceof Buffer) {
            buffer = data;
        }
        else if (data instanceof ArrayBuffer) {
            buffer = Buffer.from(data);
        }
        else if (Array.isArray(data)) {
            buffer = Buffer.concat(data);
        }
        else {
            throw new Error("Unknown message contents: " + data);
        }
        const frame = Frame.fromBytes(buffer);
        if (frame.isError())
            throw new Error(`Error: ${frame.message}\nError code: ${frame.code}`);
        if (!frame.header.t || !frame.body || typeof frame.body !== "object") {
            throw new Error("Invalid frame structure: " + JSON.stringify(frame, null, 2));
        }
        if (frame.header.t === "#commit") {
            // A commit can contain no changes
            if (!("blocks" in frame.body) || !(frame.body.blocks instanceof Uint8Array)) {
                return {
                    $type: `com.atproto.sync.subscribeRepos#commit`,
                    ...frame.body,
                    ops: [],
                };
            }
            const commit = frame.body;
            const car = await readCar(commit.blocks);
            const ops = commit.ops.map((op) => {
                const action = op.action;
                if (action === "create" || action === "update") {
                    if (!op.cid)
                        return;
                    const recordBlocks = car.blocks.get(op.cid);
                    if (!recordBlocks)
                        return;
                    return {
                        action,
                        path: op.path,
                        cid: op.cid,
                        record: cborToLexRecord(recordBlocks),
                    };
                }
                else if (action === "delete") {
                    return { action, path: op.path };
                }
                else {
                    throw new Error(`Unknown action: ${action}`);
                }
            }).filter((op) => !!op);
            return {
                $type: "com.atproto.sync.subscribeRepos#commit",
                ...commit,
                ops,
            };
        }
        return { $type: `com.atproto.sync.subscribeRepos${frame.header.t}`, ...frame.body };
    }
    /** Sets the cursor once every `setCursorInterval` milliseconds. */
    setCursor(cursor) {
        if (this.cursorInterval)
            return;
        this.cursorInterval = setTimeout(() => {
            this.cursor = cursor;
            this.cursorInterval = undefined;
        }, this.options.setCursorInterval);
    }
}
